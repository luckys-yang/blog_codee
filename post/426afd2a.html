<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>基于STM32F103宿舍指纹锁 | Luckys-Yangの小栈</title><meta name="author" content="Luckys-Yang"><meta name="copyright" content="Luckys-Yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="前言 参考文章  STM32-AS608光学指纹模块驱动(中断接收方式) 【STM32学习笔记——WIFI模块】 轻松学会WiFi模块 ESP-MQTT-AT指令连接阿里云物联网平台 连接阿里云 源码  指纹门禁系统源码 准备工作 注：链接仅供参考，可自行准备，很多其实没必要买可以画PCB顺便画上去(主要我不会，只能买现成的模块)    硬件 链接 价格     STM32F103C8T6最小系统">
<meta property="og:type" content="article">
<meta property="og:title" content="基于STM32F103宿舍指纹锁">
<meta property="og:url" content="https://mdcm.yang5201314.cn/post/426afd2a.html">
<meta property="og:site_name" content="Luckys-Yangの小栈">
<meta property="og:description" content="前言 参考文章  STM32-AS608光学指纹模块驱动(中断接收方式) 【STM32学习笔记——WIFI模块】 轻松学会WiFi模块 ESP-MQTT-AT指令连接阿里云物联网平台 连接阿里云 源码  指纹门禁系统源码 准备工作 注：链接仅供参考，可自行准备，很多其实没必要买可以画PCB顺便画上去(主要我不会，只能买现成的模块)    硬件 链接 价格     STM32F103C8T6最小系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mdcm.yang5201314.cn/img/num126.webp">
<meta property="article:published_time" content="2023-04-21T02:56:04.000Z">
<meta property="article:modified_time" content="2023-05-20T09:54:23.900Z">
<meta property="article:author" content="Luckys-Yang">
<meta property="article:tag" content="牛逼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mdcm.yang5201314.cn/img/num126.webp"><link rel="shortcut icon" href="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp"><link rel="canonical" href="https://mdcm.yang5201314.cn/post/426afd2a.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"MSZRRKNRKT","apiKey":"71e2a5ac35435ee76602cd55d727e5ff","indexName":"aaa","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于STM32F103宿舍指纹锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-20 17:54:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/rightmenu.css" media="all" onload="this.media='all'"><link rel="preconnect" href="https://s1.hdslb.com/" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/regular.css" media="all" onload="this.media='all'" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css" media="all" onload="this.media='all'" /><link rel="shortcut icon" href="#"><link href="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/css/all.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/my.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css" ><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/css/iziToast.min.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/aplayer.css" media="all" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><style>css-doodle {--color: @p(#51eaea, #fffde1, #ff9d76, #FB3569);--rule: (:doodle {@grid: 30x1 / 18vmin;--deg: @p(-180deg, 180deg);}:container {perspective: 30vmin;}:after, :before {content: '';background: var(--color); @place-cell: @r(100%) @r(100%); @size: @r(6px); @shape: heart;} @place-cell: center; @size: 100%;box-shadow: @m2(0 0 50px var(--color));background: @m100(radial-gradient(var(--color) 50%, transparent 0)@r(-20%, 120%) @r(-20%, 100%) / 1px 1px no-repeat); will-change: transform, opacity; animation: scale-up 12s linear infinite; animation-delay: calc(-12s / @I * @i); @keyframes scale-up { 0%, 95.01%, 100% {transform: translateZ(0) rotate(0);opacity: 0;}10% {opacity: 1;}95% {transform: translateZ(35vmin) rotateZ(@var(--deg));}})}</style><css-doodle use="var(--rule)"></css-doodle><script async="async" src="https://cdn.bootcdn.net/ajax/libs/css-doodle/0.32.2/css-doodle.min.js"></script></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">136</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-list-alt"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/bookmarking/"><i class="fa-fw fas fa-star"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-pen"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info-circle"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav class="fixed" id="nav"><span id="blog-info"><a href="/" title="Luckys-Yangの小栈"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/light.png"/></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-list-alt"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/bookmarking/"><i class="fa-fw fas fa-star"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-pen"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info-circle"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">基于STM32F103宿舍指纹锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-21T02:56:04.000Z" title="发表于 2023-04-21 10:56:04">2023-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-20T09:54:23.900Z" title="更新于 2023-05-20 17:54:23">2023-05-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/32%E7%B3%BB%E5%88%97/">32系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>143分钟</span></span></div></div></div><article class="post-content" id="article-container"><h2 id="前言">前言</h2>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>参考文章</p>
</div>
<p><a href="https://blog.csdn.net/weixin_56565733/article/details/124474632?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=as608%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97stm32%E5%AE%9E%E4%BE%8B&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124474632.142%5Ev85%5Einsert_down28v1,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">STM32-AS608光学指纹模块驱动(中断接收方式)</a></p>
<p><a href="https://blog.csdn.net/SBSSSSSSS/article/details/125991732?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-125991732-blog-126180831.235%5Ev32%5Epc_relevant_yljh&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">【STM32学习笔记——WIFI模块】</a></p>
<p><a href="https://blog.csdn.net/weixin_45930808/article/details/119742569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168267971416800213015662%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168267971416800213015662&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119742569-null-null.142%5Ev86%5Einsert_down28,239%5Ev2%5Einsert_chatgpt&amp;utm_term=Wifi%E6%A8%A1%E5%9D%97&amp;spm=1018.2226.3001.4187">轻松学会WiFi模块</a></p>
<p><a href="https://blog.csdn.net/weixin_45061010/article/details/120307496?spm=1001.2014.3001.5502">ESP-MQTT-AT指令连接阿里云物联网平台</a></p>
<p><a href="https://github.com/J-CHUN/STM32-Aliyun">连接阿里云</a></p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>源码</p>
</div>
<p><a href="https://github.com/luckys-yang/Dormitory_Fingerprint_Lock">指纹门禁系统源码</a></p>
<h2 id="准备工作">准备工作</h2>
<p><code>注</code>：链接仅供参考，可自行准备，很多其实没必要买可以画PCB顺便画上去(主要我不会，只能买现成的模块)</p>
<table>
<thead>
<tr>
<th style="text-align:center">硬件</th>
<th style="text-align:center">链接</th>
<th style="text-align:center">价格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STM32F103C8T6最小系统板</td>
<td style="text-align:center"><a href="https://mobile.yangkeduo.com/goods2.html?_wvx=10&amp;refer_share_uid=7089323095715&amp;share_uin=QTENDHCUMK7QV432T5H5ZZU7QA_GEXDA&amp;page_from=101&amp;_wv=41729&amp;refer_share_channel=copy_link&amp;refer_share_id=D850iZkeSppo721hEflrPl1EY96ho9D9&amp;share_uid=7089323095715&amp;pxq_secret_key=3DHRDFWVVIU65KYFNJTORD2L3T4LDD42DWL3QQCTSYWHMARVHTIQ&amp;goods_id=384306010131">拼夕夕</a></td>
<td style="text-align:center">15.6r</td>
</tr>
<tr>
<td style="text-align:center">ST003 三位按键模块</td>
<td style="text-align:center"><a href="https://mobile.yangkeduo.com/goods.html?_wvx=10&amp;refer_share_uid=7089323095715&amp;share_uin=QTENDHCUMK7QV432T5H5ZZU7QA_GEXDA&amp;page_from=101&amp;_wv=41729&amp;refer_share_channel=copy_link&amp;refer_share_id=SFGNLLUq9D50RWVWISIBsFiQ3mcqfU6T&amp;share_uid=7089323095715&amp;pxq_secret_key=3DHRDFWVVIU65KYFNJTORD2L3Q4YX7G3KDOLYJ2VDPZL2GPWWT6Q&amp;goods_id=421613641337">拼夕夕</a></td>
<td style="text-align:center">9r</td>
</tr>
<tr>
<td style="text-align:center">有源蜂鸣器模块(低电平触发)</td>
<td style="text-align:center"><a href="https://mobile.yangkeduo.com/goods1.html?_wvx=10&amp;refer_share_uid=7089323095715&amp;share_uin=QTENDHCUMK7QV432T5H5ZZU7QA_GEXDA&amp;page_from=101&amp;_wv=41729&amp;refer_share_channel=copy_link&amp;refer_share_id=JjWHhhOVBS7Tf515bWK7erwfvPvVd46w&amp;share_uid=7089323095715&amp;pxq_secret_key=3DHRDFWVVIU65KYFNJTORD2L3QJC6QDKUP3FPWG7I3J4VRM5MZKA&amp;goods_id=238532142407">拼夕夕</a></td>
<td style="text-align:center">3.2r</td>
</tr>
<tr>
<td style="text-align:center">1.3寸OLED显示屏12864–带中文字库</td>
<td style="text-align:center"><a href="https://m.tb.cn/h.UG1CQ0m?tk=OoLEdOfExKz">淘宝</a></td>
<td style="text-align:center">24r</td>
</tr>
<tr>
<td style="text-align:center">AS608光学指纹模块</td>
<td style="text-align:center"><a href="https://m.tb.cn/h.UG1y0UX?tk=Ki6LdOfvmLj">淘宝</a></td>
<td style="text-align:center">44.8r</td>
</tr>
<tr>
<td style="text-align:center">SG90舵机</td>
<td style="text-align:center"><a href="https://mobile.yangkeduo.com/goods.html?_wvx=10&amp;refer_share_uid=7089323095715&amp;share_uin=QTENDHCUMK7QV432T5H5ZZU7QA_GEXDA&amp;page_from=23&amp;_wv=41729&amp;refer_share_channel=copy_link&amp;refer_share_id=xNE0Q5GVpfhvkEODSQP9RAiIlClD1LzQ&amp;share_uid=7089323095715&amp;pxq_secret_key=3DHRDFWVVIU65KYFNJTORD2L3TS3G6DCSFBYPIAXCPQKOHMRXIHA&amp;goods_id=401226777110">拼夕夕</a></td>
<td style="text-align:center">6r</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
<td style="text-align:center">合计102.6r</td>
</tr>
</tbody>
</table>
<ul>
<li>立创画底板，用于插最小系统板还有其他模块，打板的话是立创每个月有免费次数的10*10以内好话免费(下单才知道我舵机插座忘了画)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230421113320.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230421112629.webp" alt=""></p>
<ul>
<li>连接图</li>
</ul>
<p>待写</p>
<ul>
<li>下载程序</li>
</ul>
<p>下载的话有两种方案：</p>
<ol>
<li>USB转串口模块</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">USB转串口</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3V3</td>
<td style="text-align:center">3V3</td>
</tr>
<tr>
<td style="text-align:center">GND</td>
<td style="text-align:center">GND</td>
</tr>
<tr>
<td style="text-align:center">TXD</td>
<td style="text-align:center">PA10(USART1_RX)</td>
</tr>
<tr>
<td style="text-align:center">RXD</td>
<td style="text-align:center">PA9(USART1_TX)</td>
</tr>
</tbody>
</table>
<p>然后使用 FlyMcu软件进行下载，需要设置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230421125231.webp" alt=""></p>
<p>下程序时跳线帽需要这样设置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230421130128.webp" alt=""></p>
<p>下载完后需要拔其中一个否则程序不会运行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230421130139.webp" alt=""></p>
<ol start="2">
<li>使用DAPLink</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">DAPLINK模块</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3V3</td>
<td style="text-align:center">3V3</td>
</tr>
<tr>
<td style="text-align:center">GND</td>
<td style="text-align:center">GND</td>
</tr>
<tr>
<td style="text-align:center">SWD</td>
<td style="text-align:center">SWD</td>
</tr>
<tr>
<td style="text-align:center">SWCK</td>
<td style="text-align:center">SCK</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230423143549.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230423143940.webp" alt=""></p>
<h2 id="程序框架">程序框架</h2>
<p>流程图制作可参考网站：<a href="https://www.iodraw.com/">ioDraw</a></p>
<p>大致流程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/lct324234sssss.webp" alt=""></p>
<h2 id="MX配置">MX配置</h2>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230427191552.webp","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230427191607.webp","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230427191625.webp","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230427191651.webp","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230427191709.webp","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230427191732.webp","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230427191748.webp","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230428142719.webp","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<h2 id="程序编写">程序编写</h2>
<h3 id="LED">LED</h3>
<ul>
<li>硬件连接(最小系统板自带的LED)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">LED</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LD1</td>
<td style="text-align:center">PC13</td>
</tr>
</tbody>
</table>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> Led.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 
*@Author: Yang
*@Date: 2023-04-21 15:16:50
*&#x2F;
#ifndef __LED_H
#define __LED_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; LED引脚
#define LED_PIN GPIO_PIN_13
&#x2F;&#x2F; LED灭
#define LED_OFF 0
&#x2F;&#x2F; LED亮
#define LED_ON 1

typedef struct
&#123;
    void (*vLed_Control)(uint8_t);
    void (*vLed_Flashing)(void);
&#125;Led_TypeDef;

extern Led_TypeDef Led_Data;

void vLed_Control(uint8_t swch);    &#x2F;&#x2F;控制LED亮灭
void vLed_Flashing(void);   &#x2F;&#x2F;LED闪烁
#endif
</code></pre>
              </div>
            </details>
<details ><summary> Led.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
 *@Description: LED
 *@Author: Yang
 *@Date: 2023-04-21 15:16:57
 *&#x2F;
#include &quot;Led.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
Led_TypeDef Led_Data &#x3D;
&#123;
        .vLed_Control &#x3D; &amp;vLed_Control,
        .vLed_Flashing &#x3D; &amp;vLed_Flashing
&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*
 * @description: 控制LED亮灭
 * @param: LED_OFF--灭 LED_ON--亮
 * @return: 无
 * @Date: 2023-04-21 16:51:41
 *&#x2F;
&#x2F;&#x2F; 控制LED亮灭
void vLed_Control(uint8_t swch)
&#123;
    if (LED_ON &#x3D;&#x3D; swch)
    &#123;
        HAL_GPIO_WritePin(GPIOC, LED_PIN, GPIO_PIN_RESET);
    &#125;
    else if (LED_OFF &#x3D;&#x3D; swch)
    &#123;
        HAL_GPIO_WritePin(GPIOC, LED_PIN, GPIO_PIN_SET);
    &#125;
&#125;

&#x2F;*
 * @description: LED闪烁
 * @return: 无
 * @Date: 2023-04-22 00:16:47
 *&#x2F;
&#x2F;&#x2F; LED闪烁
void vLed_Flashing(void)
&#123;
    static uint8_t Led_State &#x3D; LED_OFF;

    Led_State &#x3D; !Led_State;
    Led_Data.vLed_Control(Led_State);
&#125;
</code></pre>
              </div>
            </details>
<h3 id="按键">按键</h3>
<ul>
<li>硬件连接</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">KEY1</td>
<td style="text-align:center">PB12</td>
</tr>
<tr>
<td style="text-align:center">KEY2</td>
<td style="text-align:center">PB13</td>
</tr>
<tr>
<td style="text-align:center">KEY3</td>
<td style="text-align:center">PB14</td>
</tr>
</tbody>
</table>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> Key.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 按键
*@Author: Yang
*@Date: 2023-04-21 15:16:44
*&#x2F;
#ifndef __KEY_H
#define __KEY_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; 按键1引脚PB12
#define KEY1_PIN GPIO_PIN_12
&#x2F;&#x2F; 按键2引脚PB13
#define KEY2_PIN GPIO_PIN_13
&#x2F;&#x2F; 按键3引脚PB14
#define KEY3_PIN GPIO_PIN_14

&#x2F;&#x2F; 读取按键1电平状态
#define KEY1 HAL_GPIO_ReadPin(GPIOB,KEY1_PIN)
&#x2F;&#x2F; 读取按键2电平状态
#define KEY2 HAL_GPIO_ReadPin(GPIOB,KEY2_PIN)
&#x2F;&#x2F; 读取按键3电平状态
#define KEY3 HAL_GPIO_ReadPin(GPIOB,KEY3_PIN)
&#x2F;&#x2F; 无按键
#define KEY_NULL 0
&#x2F;&#x2F; 按键1
#define KEY1_VALUE 1
&#x2F;&#x2F; 按键2
#define KEY2_VALUE 2
&#x2F;&#x2F; 按键3
#define KEY3_VALUE 3




typedef struct
&#123;
    &#x2F;&#x2F; 标志是否处于长按状态
    bool Key_Is_Long_Press_Flag;
    &#x2F;&#x2F; 存储按键状态(3短3长)
    uint8_t Key_Down_Buff[6];
    &#x2F;&#x2F; 按键按下一瞬间
    uint8_t Key_Down;
   &#x2F;&#x2F; 按键抬起一瞬间
    uint8_t Key_Up;
   &#x2F;&#x2F; 按键键值
    uint8_t Key_Value;
   &#x2F;&#x2F; 按键按下时间
    uint16_t Key_Down_Time;
    uint8_t (*ucKey_Get_Value)(void);
    void (*vKey_Scan_Function)(void);
    void (*vKey_Run_Function)(void);
    void (*vKey_Flag_Init)(void);
&#125;Key_TypeDef;

extern Key_TypeDef Key_Data;


uint8_t ucKey_Get_Value(void);  &#x2F;&#x2F; 获取按键键值函数
void vKey_Scan_Function(void); &#x2F;&#x2F; 按键扫描函数
void vKey_Run_Function(void);    &#x2F;&#x2F; 按键功能执行函数
void vKey_Flag_Init(void);
#endif
</code></pre>
              </div>
            </details>
<details ><summary> Key.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 按键
*@Author: Yang
*@Date: 2023-04-21 15:16:38
*&#x2F;
#include &quot;Key.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
Key_TypeDef Key_Data &#x3D; 
&#123;
    .Key_Is_Long_Press_Flag &#x3D; 0,
    .Key_Down_Buff &#x3D; &#123;0&#125;,
    .Key_Down &#x3D; 0,
    .Key_Up &#x3D; 0,
    .Key_Value &#x3D; 0,
    .Key_Down_Time &#x3D; 0,
    .ucKey_Get_Value &#x3D; &amp;ucKey_Get_Value,
    .vKey_Scan_Function &#x3D; &amp;vKey_Scan_Function,
    .vKey_Run_Function &#x3D; &amp;vKey_Run_Function,
    .vKey_Flag_Init &#x3D; &amp;vKey_Flag_Init
&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*
 * @description: 获取键值
 * @return: 键值--0&#x2F;1&#x2F;2&#x2F;3
 * @Date: 2023-04-21 17:30:19
 *&#x2F;
&#x2F;&#x2F; 获取键值
uint8_t ucKey_Get_Value(void)
&#123;
    if((!KEY1) || (!KEY2) || (!KEY3))
    &#123;
        if(!KEY1)
        &#123;
            return KEY1_VALUE;
        &#125;
        else if(!KEY2)
        &#123;
            return KEY2_VALUE;
        &#125;
        else if(!KEY3)
        &#123;
            return KEY3_VALUE;
        &#125;
    &#125;
    return KEY_NULL;
&#125;

&#x2F;*
 * @description: 按键扫描函数
 * @return: 无
 * @Date: 2023-04-21 17:34:56
 *&#x2F;
&#x2F;&#x2F; 按键扫描函数
void vKey_Scan_Function(void)
&#123;
    static uint8_t Key_Old_Value &#x3D; 0;

    Key_Data.Key_Value &#x3D; Key_Data.ucKey_Get_Value();
    Key_Data.Key_Up &#x3D; ~Key_Data.Key_Value &amp; (Key_Data.Key_Value^Key_Old_Value);
    Key_Data.Key_Down &#x3D; Key_Data.Key_Value &amp; (Key_Data.Key_Value^Key_Old_Value);
    Key_Old_Value &#x3D; Key_Data.Key_Value;

    if(Key_Data.Key_Down)
    &#123;
        Key_Data.Key_Down_Time &#x3D; 0; &#x2F;&#x2F;按键计数清0开始计数
        Key_Data.Key_Is_Long_Press_Flag &#x3D; 0;
    &#125;
    &#x2F;&#x2F; 短按---&lt;1s
    if(Key_Data.Key_Down_Time &lt; 10)
    &#123;
        switch(Key_Data.Key_Up)
        &#123;
            case KEY1_VALUE:
            &#123;
                Key_Data.Key_Down_Buff[0] &#x3D; 1;
                break;
            &#125;
            case KEY2_VALUE:
            &#123;
                Key_Data.Key_Down_Buff[1] &#x3D; 1;
                break;
            &#125;
            case KEY3_VALUE:
            &#123;
                Key_Data.Key_Down_Buff[2] &#x3D; 1;
                break;
            &#125;
            default:break;
        &#125;
        Key_Data.Key_Is_Long_Press_Flag &#x3D; 0;
    &#125;
    &#x2F;&#x2F; 长按
    else
    &#123;
        if (0 &#x3D;&#x3D; Key_Data.Key_Is_Long_Press_Flag)
        &#123;
                switch (Key_Data.Key_Value)
                &#123;
                case KEY1_VALUE:
                &#123;
                    Key_Data.Key_Down_Buff[3] &#x3D; 1;
                    break;
                &#125;
                case KEY2_VALUE:
                &#123;
                    Key_Data.Key_Down_Buff[4] &#x3D; 1;
                    break;
                &#125;
                case KEY3_VALUE:
                &#123;
                    Key_Data.Key_Down_Buff[5] &#x3D; 1;
                    break;
                &#125;
                default:
                    break;
                &#125;
                Key_Data.Key_Is_Long_Press_Flag &#x3D; 1;
        &#125;
    &#125;
&#125;

&#x2F;*
 * @description: 按键功能执行函数
 * @return: 无
 * @Date: 2023-04-21 18:14:29
 *&#x2F;
&#x2F;&#x2F; 按键功能执行函数
void vKey_Run_Function(void)
&#123;
    static float x &#x3D; 0;
    if(Key_Data.Key_Down_Buff[0])
    &#123;
        Key_Data.Key_Down_Buff[0] &#x3D; 0;
        SG90_Data.vSG90_Set_Duty(SG90_ANGLE_45);
    &#125;
    if(Key_Data.Key_Down_Buff[1])
    &#123;
        Key_Data.Key_Down_Buff[1] &#x3D; 0;
        SG90_Data.vSG90_Set_Duty(SG90_ANGLE_90);
    &#125;
    if(Key_Data.Key_Down_Buff[2])
    &#123;
        Key_Data.Key_Down_Buff[2] &#x3D; 0;
        SG90_Data.vSG90_Set_Duty(SG90_ANGLE_180);
    &#125;
    if(Key_Data.Key_Down_Buff[3])
    &#123;
        Key_Data.Key_Down_Buff[3] &#x3D; 0;
        SG90_Data.vSG90_Set_Duty(SG90_ANGLE_0);
    &#125;
&#125;

&#x2F;*
 * @description: 按键按下标志位清0
 * @return &#123;*&#125;
 * @Date: 2023-04-24 23:30:03
 *&#x2F;
&#x2F;&#x2F; 按键按下标志位清0
void vKey_Flag_Init(void)
&#123;
    for(uint8_t i &#x3D; 0; i &lt; 6; i++)
    &#123;
        Key_Data.Key_Down_Buff[i] &#x3D; 0;
    &#125;
&#125;
</code></pre>
              </div>
            </details>
<h3 id="蜂鸣器">蜂鸣器</h3>
<ul>
<li>硬件连接</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">蜂鸣器</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">I/O</td>
<td style="text-align:center">PB15</td>
</tr>
</tbody>
</table>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> Buzzer.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 蜂鸣器
*@Author: Yang
*@Date: 2023-04-21 15:16:31
*&#x2F;
#ifndef __BUZZER_H
#define __BUZZER_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; 蜂鸣器引脚PB15
#define BUZZER_PIN GPIO_PIN_15
&#x2F;&#x2F; 蜂鸣器响
#define BUZZER_ON 1
&#x2F;&#x2F; 蜂鸣器不响
#define BUZZER_OFF 0
&#x2F;&#x2F; 蜂鸣器响的时间(ms)
#define BUZZER_TIME 120

typedef struct
&#123;
    &#x2F;&#x2F; 蜂鸣器开始标志位
    bool Buzzer_Open_Flag;
    uint8_t Buzzer_State;   &#x2F;&#x2F;蜂鸣器当前状态
    void (*vBuzzer_Control)(uint8_t);
    void (*vBuzzer_Ring)(void);
&#125;Buzzer_TypeDef;


extern Buzzer_TypeDef Buzzer_Data;

void vBuzzer_Control(uint8_t swch);
void vBuzzer_Ring(void);
#endif
</code></pre>
              </div>
            </details>
<details ><summary> Buzzer.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 蜂鸣器
*@Author: Yang
*@Date: 2023-04-21 15:16:25
*&#x2F;
#include &quot;Buzzer.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
Buzzer_TypeDef Buzzer_Data &#x3D; 
&#123;
    .Buzzer_Open_Flag &#x3D; 0,
    .Buzzer_State &#x3D; BUZZER_OFF,
    .vBuzzer_Control &#x3D; &amp;vBuzzer_Control,
    .vBuzzer_Ring &#x3D; &amp;vBuzzer_Ring
&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;



&#x2F;*
 * @description: 蜂鸣器控制
 * @param: BUZZER_ON--响 BUZZER_OFF--不响
 * @return: 无
 * @Date: 2023-04-21 18:28:41
 *&#x2F;
&#x2F;&#x2F; 蜂鸣器控制
void vBuzzer_Control(uint8_t swch)
&#123;
    if(BUZZER_ON &#x3D;&#x3D; swch)
    &#123;
        HAL_GPIO_WritePin(GPIOB,BUZZER_PIN,GPIO_PIN_RESET);
        Buzzer_Data.Buzzer_State &#x3D; BUZZER_ON;
    &#125;
    else if(BUZZER_OFF &#x3D;&#x3D; swch)
    &#123;
        HAL_GPIO_WritePin(GPIOB,BUZZER_PIN,GPIO_PIN_SET);
        Buzzer_Data.Buzzer_State &#x3D; BUZZER_OFF;
    &#125;
&#125;

&#x2F;*
 * @description: 蜂鸣器响一段时间
 * @return: 无
 * @Date: 2023-04-23 20:07:54
 *&#x2F;
&#x2F;&#x2F; 蜂鸣器响一段时间
void vBuzzer_Ring(void)
&#123;
    Buzzer_Data.Buzzer_Open_Flag &#x3D; 1;
&#125;
</code></pre>
              </div>
            </details>
<h3 id="OLED">OLED</h3>
<ul>
<li>接线(看模块丝印，正负极不要接反！)，因为我想把串口2的发送接收引脚空出来所以PA2,PA3改成PA6,PA7</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">OLED</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3V3</td>
<td style="text-align:center">3V3</td>
</tr>
<tr>
<td style="text-align:center">GND</td>
<td style="text-align:center">GND</td>
</tr>
<tr>
<td style="text-align:center">CLK(SCL)</td>
<td style="text-align:center">PA0</td>
</tr>
<tr>
<td style="text-align:center">MOS(SDA)</td>
<td style="text-align:center">PA1</td>
</tr>
<tr>
<td style="text-align:center">DC</td>
<td style="text-align:center">PA6</td>
</tr>
<tr>
<td style="text-align:center">CS1*</td>
<td style="text-align:center">PA7</td>
</tr>
<tr>
<td style="text-align:center">FS0</td>
<td style="text-align:center">PA4</td>
</tr>
<tr>
<td style="text-align:center">CS2*</td>
<td style="text-align:center">PA5</td>
</tr>
</tbody>
</table>
<ul>
<li>然后把商家的例程烧进去看看是否正常亮，注意引脚跟程序的引脚是否一致</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230422162305.webp" alt=""></p>
<blockquote>
<p>OLED屏幕像素是 <code>128*64(宽128高64)</code></p>
<p>显示两个字 <code>16*16</code> 的话左下角是 <code>x:0 y:6</code>，右下角是 <code>x:96 y:6</code>(因为96+16+16=128)</p>
<p><code>16*16</code>的话高是<code>0~6</code>，宽是 <code>0~128</code>，最多一行显示8个中文</p>
</blockquote>
<blockquote>
<p>还有太空人的图片.c在 <code>Space_Person_Bmp</code>文件夹就不展示了太长了</p>
</blockquote>
<blockquote>
<p>滚动的话可以这样：</p>
<p>参考：<a href="https://blog.csdn.net/cjhz2333/article/details/128005612?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=oled%E6%BB%9A%E5%8A%A8%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-1-128005612.blog_rank_default&amp;spm=1018.2226.3001.4450">STM32 OLED显示汉字及屏幕滚动-I2C协议</a></p>
<p>需要在字体后面加点空格不然可能有乱码，它是整个屏幕移动的</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Oled_Data.vOled_Clear();
Oled_Data.vOled_Write_Byte(0x2E, OLED_CMD); &#x2F;&#x2F;关闭滚动
Oled_Data.vOled_Write_Byte(0x29, OLED_CMD); &#x2F;&#x2F;向右滚动，27则向左
Oled_Data.vOled_Write_Byte(0x00, OLED_CMD); &#x2F;&#x2F;虚拟字节
Oled_Data.vOled_Write_Byte(0x00, OLED_CMD); &#x2F;&#x2F;起始页 这里为0
Oled_Data.vOled_Write_Byte(0x07, OLED_CMD); &#x2F;&#x2F;滚动速度
Oled_Data.vOled_Write_Byte(0x01, OLED_CMD); &#x2F;&#x2F;终止页
Oled_Data.vOled_Write_Byte(0x00, OLED_CMD); &#x2F;&#x2F;虚拟字节
Oled_Data.vOled_Write_Byte(0xFF, OLED_CMD); &#x2F;&#x2F;虚拟字节
Oled_Data.vOled_Display_Gb2312_String(30,0,(uint8_t*)&quot;智能嵌入式技     &quot;);
Oled_Data.vOled_Display_Gb2312_String(30,3,(uint8_t*)&quot;能大师工作室     &quot;);
Oled_Data.vOled_Display_Gb2312_String(55,6,(uint8_t*)&quot;欢迎您           &quot;);
Oled_Data.vOled_Write_Byte(0x2F, OLED_CMD); &#x2F;&#x2F;开启滚动</code></pre>
</blockquote>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> Clock.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description:
*@Author: Yang
*@Date: 2023-04-25 14:20:30
*&#x2F;
#ifndef __CLOCK_H
#define __CLOCK_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; 时间选择索引
&#x2F;&#x2F; 时
#define CLOCK_HOUR	1
&#x2F;&#x2F; 分
#define CLOCK_MIN	2
&#x2F;&#x2F; 秒
#define CLOCK_SEC	3

&#x2F;&#x2F;时间结构体
typedef struct
&#123;
    uint8_t hour;
    uint8_t min;
    uint8_t sec;
    &#x2F;&#x2F;公历日月年周
    uint16_t w_year;
    uint8_t  w_month;
    uint8_t  w_date;
    uint8_t  week;
    void (*vClock_Symbol)(uint8_t, uint8_t);
    void (*vClock_Display_Function)(void);
    void (*vClock_Get_Time_Date)(RTC_TimeTypeDef *);
    void (*vClock_Set_Time)(uint8_t, uint8_t, uint8_t);
&#125; Clock_TypeDef;

extern Clock_TypeDef Clock_Data;
extern uint8_t Clock_Arr[10];
void vClock_Symbol(uint8_t x, uint8_t y);
void vClock_Display_Function(void);
void vClock_Get_Time_Date(RTC_TimeTypeDef *sTime);
void vClock_Set_Time(uint8_t h, uint8_t m, uint8_t s);
#endif</code></pre>
              </div>
            </details>
<details ><summary> Clock.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Clock.h&quot;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
&#x2F;&#x2F; 字库数组
extern const uint8_t F11x16[][22];
extern const uint8_t F19x24[][57];

uint8_t Clock_Arr[10];
&#x2F;&#x2F; 秒数组
uint16_t num_buf[4][11];
&#x2F;&#x2F; 分数组
uint32_t num1_buf[4][19];
&#x2F;&#x2F; 时数组
uint32_t num2_buf[4][19];
extern RTC_TimeTypeDef rtc_Time;
extern RTC_DateTypeDef rtc_Date;


Clock_TypeDef Clock_Data &#x3D;
&#123;
    .0,
    .0,
    .0,
    .0,
    .0,
    .0,
    .0,
    .vClock_Symbol &#x3D; &amp;vClock_Symbol,
    .vClock_Display_Function &#x3D; &amp;vClock_Display_Function,
    .vClock_Get_Time_Date &#x3D; &amp;vClock_Get_Time_Date,
    .vClock_Set_Time &#x3D; &amp;vClock_Set_Time
&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*
 * @description: 画时钟符号 &quot;:&quot;
 * @param &#123;uint8_t&#125; x 范围0~128
 * @param &#123;uint8_t&#125; y 范围0~7
 * @return &#123;*&#125; 无
 * @Date: 2023-04-25 14:40:12
 *&#x2F;
&#x2F;&#x2F; 画时钟符号 &quot;:&quot;
void vClock_Symbol(uint8_t x, uint8_t y)
&#123;
    uint8_t i &#x3D; 0;
    uint8_t Point_Str[] &#x3D;
    &#123;
        0x00, 0xF8, 0xF8, 0xF8, 0xF8, 0x00,
        0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0x00,
        0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x00
    &#125;;

    Oled_Data.vOled_Set_Address(x, y); &#x2F;&#x2F; 设置坐标
    for (i &#x3D; 0; i &lt; 6; i++)
    &#123;
        Oled_Data.vOled_Write_Byte(Point_Str[i], 1);
    &#125;
    Oled_Data.vOled_Set_Address(x, y + 1); &#x2F;&#x2F; 设置坐标
    for (i &#x3D; 6; i &lt; 12; i++)
    &#123;
        Oled_Data.vOled_Write_Byte(Point_Str[i], 1);
    &#125;
    Oled_Data.vOled_Set_Address(x, y + 2); &#x2F;&#x2F; 设置坐标
    for (i &#x3D; 12; i &lt; 18; i++)
    &#123;
        Oled_Data.vOled_Write_Byte(Point_Str[i], 1);
    &#125;
&#125;

&#x2F;*
 * @description: 时钟显示
 * @return &#123;*&#125;
 * @Date: 2023-04-25 14:56:45
 *&#x2F;
&#x2F;&#x2F; 时钟显示
void vClock_Display_Function(void)
&#123;
    SearchResult search;
    &#x2F;&#x2F; 保存的秒数
    static uint8_t Save_Time &#x3D; 0;
    uint8_t i &#x3D; 0, x &#x3D; 0, y &#x3D; 0;
    &#x2F;&#x2F; 清屏
    Oled_Data.vOled_Clear();
    &#x2F;&#x2F; 显示字体
    Oled_Data.vOled_Display_Gb2312_String(0, 6, (uint8_t *)&quot;解锁&quot;);
    Oled_Data.vOled_Display_Gb2312_String(96, 6, (uint8_t *)&quot;功能&quot;);
    sprintf(Clock_Arr, &quot;%02d&quot;, Clock_Data.hour);
    Oled_Data.vOled_Asc_19x24(2, 2, Clock_Arr);
    Clock_Data.vClock_Symbol(2 + 2 * 22, 2);
    sprintf(Clock_Arr, &quot;%02d&quot;, Clock_Data.min);
    Oled_Data.vOled_Asc_19x24(2 + 2 * 22 + 2 + 7, 2, Clock_Arr);
    if(Admin_Data.Administrator_Flag)
    &#123;
        Oled_Data.vOled_Display_Gb2312_String(54, 6, (uint8_t *)&quot;★&quot;); &#x2F;&#x2F; 表示当前为管理员模式
    &#125;
    else
    &#123;
        Oled_Data.vOled_Display_Gb2312_String(54, 6, (uint8_t *)&quot;  &quot;);
    &#125;
    while(1)
    &#123;
        MyUSART1_Data.vUsart1_Rx_Data_Analytic();   &#x2F;&#x2F; 上位机调试数据解析
        MyUSART2_Data.vUsart2_Rx_Data_Analytic();   &#x2F;&#x2F; WiFi数据数据解析
        if(MyUSART2_Data.APP_Rx_Flag)
        &#123;
            MyUSART2_Data.APP_Rx_Flag &#x3D; 0;
            return;
        &#125;
        if(INTERFACE_6 &#x3D;&#x3D; Menu_Data.Menu_State)
        &#123;
            return;
        &#125;
        &#x2F;&#x2F; 进入管理员解锁页面(k1)
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring();        &#x2F;&#x2F; 蜂鸣器滴一下
            MyAll_Data.vTime_Out_Init();       &#x2F;&#x2F; 超时等待清0
            if (Admin_Data.Administrator_Flag) &#x2F;&#x2F; 已解锁，回到主页面
            &#123;
                Key_Data.vKey_Flag_Init();
                Menu_Data.vMenu_Admin_Pass_Interface();
            &#125;
            else &#x2F;&#x2F; 需要解锁
            &#123;
                Menu_Data.Menu_State &#x3D; INTERFACE_2;
                Menu_Data.Menu_Flag_Buff[1] &#x3D; 1;
            &#125;
            return;
        &#125;
        &#x2F;&#x2F; 进入功能页面(k3)，有些功能需要有管理员身份 Admin_Data.Administrator_Flag
        if (Key_Data.Key_Down_Buff[2])
        &#123;
            Key_Data.Key_Down_Buff[2] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring();  &#x2F;&#x2F; 蜂鸣器滴一下
            MyAll_Data.vTime_Out_Init(); &#x2F;&#x2F; 超时等待清0
            Menu_Data.Menu_State &#x3D; INTERFACE_3;
            Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
            return;
        &#125;
        if(AS608_Data.AS608_Wak_Flag)
        &#123;
            AS608_Data.AS608_Wak_Flag &#x3D; 0;
            Menu_Data.Menu_Flag_Buff[6] &#x3D; 1;
            Menu_Data.Menu_State &#x3D; INTERFACE_7;
            return;
        &#125;
        if (Save_Time !&#x3D; Clock_Data.sec)
        &#123;
            Save_Time &#x3D; Clock_Data.sec; &#x2F;&#x2F; 更新保存的秒数

            &#x2F;&#x2F; printf(&quot;Old:%d New:%d\r\n&quot;,Save_Time,Clock_Data.sec);
            y &#x3D; 0;  &#x2F;&#x2F; 置 y 为 0,用于后面的位移操作
            &#x2F;&#x2F; 将当前秒和下一秒的秒数分别转换成两个字符，并将它们转换成对应的位图矩阵存储到 num_buf 数组中
            sprintf(Clock_Arr, &quot;%02d&quot;, Clock_Data.sec);
            &#x2F;&#x2F; printf(&quot;%d\r\n&quot;,Clock_Data.sec);
            for (x &#x3D; 0; x &lt; 11; x++)
            &#123;
                num_buf[0][x] &#x3D; F11x16[Clock_Arr[0] - 0x30][x] | (uint16_t)F11x16[Clock_Arr[0] - 0x30][11 + x] &lt;&lt; 8;    &#x2F;&#x2F; 将第一个数字的位图矩阵存储到 num_buf[0] 中
                num_buf[1][x] &#x3D; F11x16[Clock_Arr[1] - 0x30][x] | (uint16_t)F11x16[Clock_Arr[1] - 0x30][11 + x] &lt;&lt; 8;    &#x2F;&#x2F; 将第二个数字的位图矩阵存储到 num_buf[1] 中
            &#125;
            sprintf(Clock_Arr, &quot;%02d&quot;, (Clock_Data.sec + 1) % 60);
            for (x &#x3D; 0; x &lt; 11; x++)
            &#123;
                num_buf[2][x] &#x3D; F11x16[Clock_Arr[0] - 0x30][x] | (uint16_t)F11x16[Clock_Arr[0] - 0x30][11 + x] &lt;&lt; 8;    &#x2F;&#x2F; 将下一个秒数的第一个数字的位图矩阵存储到 num_buf[2] 中
                num_buf[3][x] &#x3D; F11x16[Clock_Arr[1] - 0x30][x] | (uint16_t)F11x16[Clock_Arr[1] - 0x30][11 + x] &lt;&lt; 8;    &#x2F;&#x2F; 将下一个秒数的第二个数字的位图矩阵存储到 num_buf[3] 中
            &#125;

            &#x2F;&#x2F; 将当前分钟数和下一分钟数分别转换成两个字符，并将它们转换成对应的位图矩阵存储到 num1_buf 数组中
            sprintf(Clock_Arr, &quot;%02d&quot;, Clock_Data.min);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                num1_buf[0][x] &#x3D; F19x24[Clock_Arr[0] - 0x30][x] | (uint32_t)F19x24[Clock_Arr[0] - 0x30][1 * 19 + x] &lt;&lt; 8 * 1 | (uint32_t)F19x24[Clock_Arr[0] - 0x30][2 * 19 + x] &lt;&lt; 8 * 2;  &#x2F;&#x2F; 将第一个数字的位图矩阵存储到 num1_buf[0] 中
                num1_buf[1][x] &#x3D; F19x24[Clock_Arr[1] - 0x30][x] | (uint32_t)F19x24[Clock_Arr[1] - 0x30][1 * 19 + x] &lt;&lt; 8 * 1 | (uint32_t)F19x24[Clock_Arr[1] - 0x30][2 * 19 + x] &lt;&lt; 8 * 2;  &#x2F;&#x2F; 将第二个数字的位图矩阵存储到 num1_buf[1] 中
            &#125;
            sprintf(Clock_Arr, &quot;%02d&quot;, (Clock_Data.min + 1) % 60);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                num1_buf[2][x] &#x3D; F19x24[Clock_Arr[0] - 0x30][x] | (uint32_t)F19x24[Clock_Arr[0] - 0x30][1 * 19 + x] &lt;&lt; 8 * 1 | (uint32_t)F19x24[Clock_Arr[0] - 0x30][2 * 19 + x] &lt;&lt; 8 * 2;  &#x2F;&#x2F; 将下一个分钟数的第一个数字的位图矩阵存储到 num1_buf[2] 中
                num1_buf[3][x] &#x3D; F19x24[Clock_Arr[1] - 0x30][x] | (uint32_t)F19x24[Clock_Arr[1] - 0x30][1 * 19 + x] &lt;&lt; 8 * 1 | (uint32_t)F19x24[Clock_Arr[1] - 0x30][2 * 19 + x] &lt;&lt; 8 * 2;  &#x2F;&#x2F; 将下一个分钟数的第二个数字的位图矩阵存储到 num1_buf[3] 中
            &#125;

            &#x2F;&#x2F; 将当前小时数和下一个小时数分别转换成两个字符，并将它们转换成对应的位图矩阵存储到 num2_buf 数组中
            sprintf(Clock_Arr, &quot;%02d&quot;, Clock_Data.hour);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                num2_buf[0][x] &#x3D; F19x24[Clock_Arr[0] - 0x30][x] | (uint32_t)F19x24[Clock_Arr[0] - 0x30][1 * 19 + x] &lt;&lt; 8 * 1 | (uint32_t)F19x24[Clock_Arr[0] - 0x30][2 * 19 + x] &lt;&lt; 8 * 2;  &#x2F;&#x2F; 将第一个数字的位图矩阵存储到 num2_buf[0] 中
                num2_buf[1][x] &#x3D; F19x24[Clock_Arr[1] - 0x30][x] | (uint32_t)F19x24[Clock_Arr[1] - 0x30][1 * 19 + x] &lt;&lt; 8 * 1 | (uint32_t)F19x24[Clock_Arr[1] - 0x30][2 * 19 + x] &lt;&lt; 8 * 2;  &#x2F;&#x2F; 将第二个数字的位图矩阵存储到 num2_buf[1] 中
            &#125;

            sprintf(Clock_Arr, &quot;%02d&quot;, (Clock_Data.hour + 1) % 24);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                num2_buf[2][x] &#x3D; F19x24[Clock_Arr[0] - 0x30][x] | (uint32_t)F19x24[Clock_Arr[0] - 0x30][1 * 19 + x] &lt;&lt; 8 * 1 | (uint32_t)F19x24[Clock_Arr[0] - 0x30][2 * 19 + x] &lt;&lt; 8 * 2;  &#x2F;&#x2F; 将下一个小时数的第一个数字的位图矩阵存储到 num2_buf[2] 中
                num2_buf[3][x] &#x3D; F19x24[Clock_Arr[1] - 0x30][x] | (uint32_t)F19x24[Clock_Arr[1] - 0x30][1 * 19 + x] &lt;&lt; 8 * 1 | (uint32_t)F19x24[Clock_Arr[1] - 0x30][2 * 19 + x] &lt;&lt; 8 * 2;  &#x2F;&#x2F; 将下一个小时数的第二个数字的位图矩阵存储到 num2_buf[3] 中
            &#125;
        &#125;
        &#x2F;&#x2F; 如果 y 小于 19，表示数字时钟的显示还没有到达顶部
        if (y &lt; 19)
        &#123;
            for (x &#x3D; 0; x &lt; 11; x++)
            &#123;
                if (y &gt; 2)  &#x2F;&#x2F; 如果当前显示的行数大于 2，表示数字时钟的显示位于中心区域
                &#123;
                    &#x2F;&#x2F; 分两种情况更新位图矩阵：
                    &#x2F;&#x2F; 当前秒数的个位是 9 时，需要将个位的数字从上方更新到下方，将下一秒的个位数字从下方更新到上方
                    &#x2F;&#x2F; 当前秒数的个位不是 9 时，只需要将个位的数字从上方更新到下方
                    if (9 &#x3D;&#x3D; Clock_Data.sec % 10)
                    &#123;
                        num_buf[0][x] &#x3D; (num_buf[0][x] &gt;&gt; 1) | ((num_buf[2][x] &amp; 0x01) &lt;&lt; 15);  &#x2F;&#x2F; 将当前秒数的个位数字从上方更新到下方
                        num_buf[1][x] &#x3D; (num_buf[1][x] &gt;&gt; 1) | ((num_buf[3][x] &amp; 0x01) &lt;&lt; 15);  &#x2F;&#x2F; 将当前秒数的十位数字从上方更新到下方
                        num_buf[2][x] &#x3D; num_buf[2][x] &gt;&gt; 1; &#x2F;&#x2F; 将下一秒的个位数字从下方更新到上方
                        num_buf[3][x] &#x3D; num_buf[3][x] &gt;&gt; 1; &#x2F;&#x2F; 将下一秒的十位数字从下方更新到上方
                    &#125;
                    else
                    &#123;
                        num_buf[1][x] &#x3D; (num_buf[1][x] &gt;&gt; 1) | ((num_buf[3][x] &amp; 0x01) &lt;&lt; 15);  &#x2F;&#x2F; 将下一秒的十位数字从下方更新到上方
                        num_buf[3][x] &#x3D; num_buf[3][x] &gt;&gt; 1; &#x2F;&#x2F; 将下一秒的十位数字从下方更新到上方
                    &#125;
                &#125;
                else    &#x2F;&#x2F; 将下一秒的十位数字从下方更新到上方
                &#123;
                    if (9 &#x3D;&#x3D; Clock_Data.sec % 10)   &#x2F;&#x2F; 如果当前秒数的个位是 9，需要将个位的数字从上方更新到下方
                    &#123;
                        num_buf[0][x] &#x3D; (num_buf[0][x] &gt;&gt; 1);   &#x2F;&#x2F; 将当前秒数的个位数字从上方更新到下方
                    &#125;
                    num_buf[1][x] &#x3D; (num_buf[1][x] &gt;&gt; 1);   &#x2F;&#x2F; 将当前秒数的个位数字从上方更新到下方
                &#125;
            &#125;
            &#x2F;&#x2F; 更新数字时钟的显示
            &#x2F;&#x2F; 将数字时钟矩阵的数据写入 OLED 显示屏的相应位置，以更新数字时钟的显示
            Oled_Data.vOled_Set_Address(2 + 4 * 22 + 2 + 7, 3); &#x2F;&#x2F;设置坐标
            for (x &#x3D; 0; x &lt; 11; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num_buf[0][x], 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 4 * 22 + 2 + 7, 4);
            for (x &#x3D; 0; x &lt; 11; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num_buf[0][x] &gt;&gt; 8, 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 4 * 22 + 2 + 7 + 12, 3); &#x2F;&#x2F;设置坐标
            for (x &#x3D; 0; x &lt; 11; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num_buf[1][x], 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 4 * 22 + 2 + 7 + 12, 4);
            for (x &#x3D; 0; x &lt; 11; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num_buf[1][x] &gt;&gt; 8, 1);
            &#125;
        &#125;
        &#x2F;&#x2F; 如果当前显示未到达底部并且秒数为 59，则进入更新数字分钟的代码块
        if ((y &lt; 27) &amp;&amp; (59 &#x3D;&#x3D; Clock_Data.sec))
        &#123;
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                if (y &gt; 2)&#x2F;&#x2F; 如果当前显示的行数大于 2，表示数字分钟的显示位于中心区域
                &#123;
                    &#x2F;&#x2F; 分两种情况更新位图矩阵：
                    &#x2F;&#x2F; 当前分钟数的个位是 9 时，需要将个位的数字从上方更新到下方，将下一分钟的个位数字从下方更新到上方
                    &#x2F;&#x2F; 当前分钟数的个位不是 9 时，只需要将个位的数字从上方更新到下方
                    if (9 &#x3D;&#x3D; (Clock_Data.min % 10))
                    &#123;
                        num1_buf[0][x] &#x3D; (num1_buf[0][x] &gt;&gt; 1) | ((num1_buf[2][x] &amp; 0x01) &lt;&lt; 23);&#x2F;&#x2F; 将当前分钟数的个位数字从上方更新到下方
                        num1_buf[1][x] &#x3D; (num1_buf[1][x] &gt;&gt; 1) | ((num1_buf[3][x] &amp; 0x01) &lt;&lt; 23);&#x2F;&#x2F; 将当前分钟数的十位数字从上方更新到下方
                        num1_buf[2][x] &#x3D; num1_buf[2][x] &gt;&gt; 1;&#x2F;&#x2F; 将下一分钟的个位数字从下方更新到上方
                        num1_buf[3][x] &#x3D; num1_buf[3][x] &gt;&gt; 1;&#x2F;&#x2F; 将下一分钟的十位数字从下方更新到上方
                    &#125;
                    else
                    &#123;
                        num1_buf[1][x] &#x3D; (num1_buf[1][x] &gt;&gt; 1) | ((num1_buf[3][x] &amp; 0x01) &lt;&lt; 23);&#x2F;&#x2F; 将当前分钟数的十位数字从上方更新到下方
                        num1_buf[3][x] &#x3D; num1_buf[3][x] &gt;&gt; 1;&#x2F;&#x2F; 将下一分钟的十位数字从下方更新到上方
                    &#125;
                &#125;
                else&#x2F;&#x2F; 否则，表示数字分钟的显示位于顶部或底部
                &#123;
                    if (9 &#x3D;&#x3D; (Clock_Data.min % 10)) &#x2F;&#x2F; 如果当前分钟数的个位是 9，需要将个位的数字从上方更新到下方
                    &#123;
                        num1_buf[0][x] &#x3D; (num1_buf[0][x] &gt;&gt; 1);&#x2F;&#x2F; 将当前分钟数的个位数字从上方更新到下方
                    &#125;
                    num1_buf[1][x] &#x3D; (num1_buf[1][x] &gt;&gt; 1);&#x2F;&#x2F; 将当前分钟数的十位数字从上方更新到下方
                &#125;
            &#125;
            &#x2F;&#x2F;	Asc19_24(2+2*22+2+7,2,s);
            &#x2F;&#x2F; 更新数字分钟的显示
            &#x2F;&#x2F; 将数字分钟矩阵的数据写入 OLED 显示屏的相应位置，以更新数字分钟的显示
            Oled_Data.vOled_Set_Address(2 + 2 * 22 + 2 + 7, 2);    &#x2F;&#x2F;设置坐标
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num1_buf[0][x], 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 2 * 22 + 2 + 7, 3);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num1_buf[0][x] &gt;&gt; 8, 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 2 * 22 + 2 + 7, 4);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num1_buf[0][x] &gt;&gt; 16, 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 3 * 22 + 2 + 7, 2); &#x2F;&#x2F; 设置坐标
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num1_buf[1][x], 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 3 * 22 + 2 + 7, 3); &#x2F;&#x2F; 设置坐标
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num1_buf[1][x] &gt;&gt; 8, 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 3 * 22 + 2 + 7, 4); &#x2F;&#x2F; 设置坐标
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num1_buf[1][x] &gt;&gt; 16, 1);
            &#125;
        &#125;
        &#x2F;&#x2F; 如果当前显示未到达底部，并且分钟数和秒数都为 59，则进行数字小时的更新
        if ((y &lt; 27) &amp;&amp; (Clock_Data.min &#x3D;&#x3D; 59) &amp;&amp; (Clock_Data.sec &#x3D;&#x3D; 59))
        &#123;
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;

                if (y &gt; 2)&#x2F;&#x2F; 如果当前显示的行数大于 2，表示数字小时的显示位于中心区域
                &#123;
                    &#x2F;&#x2F; 根据数字小时的个位数是否为 9 或当前时间是否为 23 时判断具体更新方式：
                    &#x2F;&#x2F; 若数字小时的个位数为 9 或当前时间为 23，则需将个位数字从上方更新到下方，将下一小时的个位数字从下方更新到上方；
                    &#x2F;&#x2F; 否则，只需将个位数字从上方更新到下方。
                    if ((Clock_Data.hour % 10 &#x3D;&#x3D; 9) || (Clock_Data.hour &#x3D;&#x3D; 23))
                    &#123;
                        num2_buf[0][x] &#x3D; (num2_buf[0][x] &gt;&gt; 1) | ((num2_buf[2][x] &amp; 0x01) &lt;&lt; 23);&#x2F;&#x2F; 将当前小时数的个位数字从上方更新到下方
                        num2_buf[1][x] &#x3D; (num2_buf[1][x] &gt;&gt; 1) | ((num2_buf[3][x] &amp; 0x01) &lt;&lt; 23);&#x2F;&#x2F; 将当前小时数的十位数字从上方更新到下方
                        num2_buf[2][x] &#x3D; num2_buf[2][x] &gt;&gt; 1;&#x2F;&#x2F; 将下一小时的个位数字从下方更新到上方
                        num2_buf[3][x] &#x3D; num2_buf[3][x] &gt;&gt; 1;&#x2F;&#x2F; 将下一小时的十位数字从下方更新到上方
                    &#125;
                    else
                    &#123;
                        num2_buf[1][x] &#x3D; (num2_buf[1][x] &gt;&gt; 1) | ((num2_buf[3][x] &amp; 0x01) &lt;&lt; 23);&#x2F;&#x2F; 将当前小时数的十位数字从上方更新到下方
                        num2_buf[3][x] &#x3D; num2_buf[3][x] &gt;&gt; 1;&#x2F;&#x2F; 将下一小时的十位数字从下方更新到上方
                    &#125;
                &#125;
                else&#x2F;&#x2F; 否则，表示数字小时的显示位于顶部或底部
                &#123;
                    if (9 &#x3D;&#x3D; Clock_Data.hour % 10)
                    &#123;
                        num2_buf[0][x] &#x3D; (num2_buf[0][x] &gt;&gt; 1); &#x2F;&#x2F; 将当前小时数的个位数字从上方更新到下方
                    &#125;
                    num2_buf[1][x] &#x3D; (num2_buf[1][x] &gt;&gt; 1);&#x2F;&#x2F; 将当前小时数的十位数字从上方更新到下方
                &#125;
            &#125;
            &#x2F;&#x2F;	Asc19_24(2+2*22+2+7,2,s);
            Oled_Data.vOled_Set_Address(2, 2); &#x2F;&#x2F; 设置坐标
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num2_buf[0][x], 1);
            &#125;
            Oled_Data.vOled_Set_Address(2, 3);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num2_buf[0][x] &gt;&gt; 8, 1);
            &#125;
            Oled_Data.vOled_Set_Address(2, 4);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num2_buf[0][x] &gt;&gt; 16, 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 1 * 22, 2); &#x2F;&#x2F; 设置坐标
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num2_buf[1][x], 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 1 * 22, 3);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num2_buf[1][x] &gt;&gt; 8, 1);
            &#125;
            Oled_Data.vOled_Set_Address(2 + 1 * 22, 4);
            for (x &#x3D; 0; x &lt; 19; x++)
            &#123;
                Oled_Data.vOled_Write_Byte(num2_buf[1][x] &gt;&gt; 16, 1);
            &#125;
        &#125;
        y++;    &#x2F;&#x2F; 行数加 1
        HAL_Delay(17);  &#x2F;&#x2F; 延时，使 OLED 显示屏能够刷新完整屏幕
    &#125;
&#125;

&#x2F;*
 * @description: 获取当前时间日期
 * @param &#123;RTC_TimeTypeDef&#125; *sTime 要存到哪
 * @return &#123;*&#125;
 * @Date: 2023-04-25 16:42:55
 *&#x2F;
&#x2F;&#x2F; 获取当前时间日期
void vClock_Get_Time_Date(RTC_TimeTypeDef *sTime)
&#123;
    HAL_RTC_GetTime(&amp;hrtc, &amp;rtc_Time, RTC_FORMAT_BIN);  &#x2F;&#x2F; 获取时间
    HAL_RTC_GetDate(&amp;hrtc, &amp;rtc_Date, RTC_FORMAT_BIN);  &#x2F;&#x2F; 获取日期

    Clock_Data.sec &#x3D; sTime-&gt;Seconds;
    Clock_Data.min &#x3D; sTime-&gt;Minutes;
    Clock_Data.hour &#x3D; sTime-&gt;Hours;
&#125;

&#x2F;*
 * @description: RTC设置时间
 * @return &#123;*&#125;
 * @Date: 2023-04-25 17:55:53
 *&#x2F;
&#x2F;&#x2F; RTC设置时间
void vClock_Set_Time(uint8_t h, uint8_t m, uint8_t s)
&#123;
    rtc_Time.Hours &#x3D; h;
    rtc_Time.Minutes &#x3D; m;
    rtc_Time.Seconds &#x3D; s;
    rtc_Date.Year &#x3D; 23;
    rtc_Date.Month &#x3D; 4;
    rtc_Date.Date &#x3D; 25;
    HAL_RTC_SetDate(&amp;hrtc, &amp;rtc_Date, RTC_FORMAT_BIN);
    HAL_RTC_SetTime(&amp;hrtc, &amp;rtc_Time, RTC_FORMAT_BIN);
&#125;
</code></pre>
              </div>
            </details>
<details ><summary> Oled.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: OLED屏幕
*@Author: Yang
*@Date: 2023-04-21 15:17:10
*&#x2F;
#ifndef __OLED_H
#define __OLED_H
#include &quot;MyAll.h&quot;

&#x2F;******引脚定义*******&#x2F;
&#x2F;&#x2F; OLED SCL引脚PA0
#define OLED_SCL    GPIO_PIN_0
&#x2F;&#x2F; OLED SDA引脚PA1
#define OLED_SDA    GPIO_PIN_1
&#x2F;&#x2F; OLED DC引脚PA2
#define OLED_DC GPIO_PIN_2
&#x2F;&#x2F; OLED CS1引脚PA3
#define OLED_CS1    GPIO_PIN_3
&#x2F;&#x2F; OLED FS0引脚PA4
#define OLED_FS0    GPIO_PIN_4
&#x2F;&#x2F; OLED CS2引脚PA5
#define OLED_CS2    GPIO_PIN_5

&#x2F;******引脚置位&#x2F;读取*******&#x2F;
&#x2F;&#x2F; SCL 置0&#x2F;1
#define SCL_OUT_0  HAL_GPIO_WritePin(GPIOA,OLED_SCL,GPIO_PIN_RESET)
#define SCL_OUT_1  HAL_GPIO_WritePin(GPIOA,OLED_SCL,GPIO_PIN_SET)
&#x2F;&#x2F; SDA 置0&#x2F;1
#define SDA_OUT_0  HAL_GPIO_WritePin(GPIOA,OLED_SDA,GPIO_PIN_RESET)
#define SDA_OUT_1  HAL_GPIO_WritePin(GPIOA,OLED_SDA,GPIO_PIN_SET)
&#x2F;&#x2F; DC 置0&#x2F;1
#define DC_OUT_0  HAL_GPIO_WritePin(GPIOA,OLED_DC,GPIO_PIN_RESET)
#define DC_OUT_1  HAL_GPIO_WritePin(GPIOA,OLED_DC,GPIO_PIN_SET)
&#x2F;&#x2F; CS1 置0&#x2F;1
#define CS1_OUT_0  HAL_GPIO_WritePin(GPIOA,OLED_CS1,GPIO_PIN_RESET)
#define CS1_OUT_1  HAL_GPIO_WritePin(GPIOA,OLED_CS1,GPIO_PIN_SET)
&#x2F;&#x2F; FS0 读取电平状态
#define FS0_READ    HAL_GPIO_ReadPin(GPIOA,OLED_FS0)
&#x2F;&#x2F; CS2 置0&#x2F;1
#define CS2_OUT_0  HAL_GPIO_WritePin(GPIOA,OLED_CS2,GPIO_PIN_RESET)
#define CS2_OUT_1  HAL_GPIO_WritePin(GPIOA,OLED_CS2,GPIO_PIN_SET)


&#x2F;******其他*******&#x2F;
&#x2F;&#x2F; 写命令
#define OLED_CMD    0
&#x2F;&#x2F; 写数据
#define OLED_DATA   1
&#x2F;&#x2F; 正常
#define OLED_SET    1
&#x2F;&#x2F; 反常
#define OLED_RESET  0

&#x2F;******命令大全*******&#x2F;
&#x2F;&#x2F; 正常显示
#define CMD_NORMAL  0xA6
&#x2F;&#x2F; 反转显示
#define CMD_INVERSE  0xA7
&#x2F;&#x2F; 设置对比度控制(选择1~256，复位值0x7F)
#define CMD_SET_CONTRACT    0x7F
&#x2F;&#x2F; 电压等级设置(0x00-0.65xVCC 0x20-0.77xVCC(复位值) 0x30-0.83xVCC)
#define CMD_SET_V_LEVEL 0x20
&#x2F;&#x2F; 显示开启
#define CMD_DISPLAY_ON  0xAF
&#x2F;&#x2F; 显示关闭(睡眠模式)
#define CMD_DISPLAY_OFF 0xAE
&#x2F;&#x2F; 控制列地址0被映射到SEG0
#define CMD_RE_MAP_0    0xA0
&#x2F;&#x2F; 控制列地址127被映射到SEG0
#define CMD_RE_MAP_127    0xA1
&#x2F;&#x2F; 控制扫描方向COM0--&gt;COM[N-1]
#define CMD_DIRECTION_L_TO_R    0xC0
&#x2F;&#x2F; 控制扫描方向COM[N-1]--&gt;COM0
#define CMD_DIRECTION_R_TO_L    0xC8



typedef struct
&#123;
    uint32_t Font_Addr;
    void (*vOled_Write_Byte)(uint8_t,uint8_t);
    void (*vOled_Toggle_Display)(uint8_t);
    void (*vOled_Rotate_Display)(uint8_t);
    void (*vOled_Clear)(void);
    void (*vOled_Set_Address)(uint8_t,uint8_t);
    void (*vOled_Display_128x64_Bmp)(uint8_t*);
    void (*vOled_Display_Gb2312_String)(uint8_t,uint8_t,uint8_t*);
    void (*vOled_Display_String_5x7)(uint8_t,uint8_t,uint8_t*);
    void (*vOled_Init)(void);
    void (*vOled_Draw_Bmp)(unsigned char,unsigned char,unsigned char,unsigned char,unsigned char []);
    void (*vOled_Light_Row)(uint8_t,uint8_t);
    void (*vOled_Asc_19x24)(uint8_t,uint8_t,uint8_t []);
    void (*vOled_Painting_Pixel)(uint8_t,uint8_t,uint8_t);
&#125;Oled_TypeDef;

extern Oled_TypeDef Oled_Data;

void vOled_Write_Byte(uint8_t data, uint8_t format);
void vOled_Toggle_Display(uint8_t swch);
void vOled_Rotate_Display(uint8_t swch);
void vOled_Set_Address(uint8_t x,uint8_t y);
void vOled_Display_128x64_Bmp(uint8_t *dp);
void vOled_Clear(void);
void vOled_Display_Gb2312_String(uint8_t x, uint8_t y, uint8_t *text);
void vOled_Display_5x7(uint8_t x, uint8_t y, uint8_t *dp);
void vOled_Init(void);
void vOled_Asc_19x24(uint8_t x, uint8_t y, uint8_t ch[]);
void vOled_Painting_Pixel(uint8_t x,uint8_t y,uint8_t num);
void vOled_Light_Row(uint8_t row,uint8_t swch);
void vOled_Draw_Bmp(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, unsigned char BMP[]);
#endif
</code></pre>
              </div>
            </details>
<details ><summary> Oled.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: OLED屏幕 接线：CLK--PA0 MOS--PA1 DC--PA2 CS1--PA3 FS0--PA4 CS2--PA5
*@Author: Yang
*@Date: 2023-04-21 15:17:04
*&#x2F;
#include &quot;Oled.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;静态内部函数声明区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
static void svOled_DisPlay_Control(uint8_t swch);
static void svOled_Display_16x16(uint8_t x, uint8_t y, uint8_t *dp);
static void svOled_Display_8x16(uint8_t x, uint8_t y, uint8_t *dp);
static void svOled_Send_Command_To_Rom(uint8_t dat);
static uint8_t sucOled_Get_Data_From_Rom(void);
static void svOled_Get_Data(uint8_t addrHigh, uint8_t addrMid, uint8_t addrLow, uint8_t *pbuff, uint8_t DataLen);
static void vOled_Display_String_5x7(uint8_t x, uint8_t y, uint8_t *text);
static void svOled_Show_Decimal(uint8_t x, uint8_t y, float num1, uint8_t len);



&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;静态内部函数声明区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;



&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
extern const uint8_t F11x16[][22];
extern const uint8_t F19x24[][57];

Oled_TypeDef Oled_Data &#x3D;
&#123;
    .Font_Addr &#x3D; 0,
    .vOled_Write_Byte &#x3D; &amp;vOled_Write_Byte,
    .vOled_Toggle_Display &#x3D; &amp;vOled_Toggle_Display,
    .vOled_Rotate_Display &#x3D; &amp;vOled_Rotate_Display,
    .vOled_Clear &#x3D; &amp;vOled_Clear,
    .vOled_Set_Address &#x3D; &amp;vOled_Set_Address,
    .vOled_Display_128x64_Bmp &#x3D; &amp;vOled_Display_128x64_Bmp,
    .vOled_Display_Gb2312_String &#x3D; &amp;vOled_Display_Gb2312_String,
    .vOled_Display_String_5x7 &#x3D; &amp;vOled_Display_String_5x7,
    .vOled_Init &#x3D; &amp;vOled_Init,
    .vOled_Draw_Bmp &#x3D; &amp;vOled_Draw_Bmp,
    .vOled_Light_Row &#x3D; &amp;vOled_Light_Row,
    .vOled_Asc_19x24 &#x3D; &amp;vOled_Asc_19x24,
    .vOled_Painting_Pixel &#x3D; &amp;vOled_Painting_Pixel
&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*
 * @description: 向SSD1306写入一个字节
 * @param: 待写入数据
 * @param: 格式-- OLED_CMD(命令)  OLED_DATA(数据)
 * @return: 无
 * @Date: 2023-04-22 17:46:53
 *&#x2F;
&#x2F;&#x2F; 向SSD1306写入一个字节
void vOled_Write_Byte(uint8_t data, uint8_t format)
&#123;
    if(OLED_DATA &#x3D;&#x3D; format)
    &#123;
        DC_OUT_1;
    &#125;
    else
    &#123;
        DC_OUT_0;
    &#125;
    CS1_OUT_0;
    for (uint8_t i &#x3D; 0; i &lt; 8; i++)
    &#123;
        SCL_OUT_0;
        if(data &amp; 0x80)
        &#123;
            SDA_OUT_1;
        &#125;
        else
        &#123;
            SDA_OUT_0;
        &#125;
        SCL_OUT_1;
        data &lt;&lt;&#x3D; 1;
    &#125;
    CS1_OUT_1;
    DC_OUT_1;
&#125;

&#x2F;*
 * @description: 反显函数
 * @param : OLED_SET--正常显示 OLED_RESET--反色显示
 * @return: 无
 * @Date: 2023-04-22 17:40:54
 *&#x2F;
&#x2F;&#x2F; 反显函数
void vOled_Toggle_Display(uint8_t swch)
&#123;
    if(OLED_SET &#x3D;&#x3D; swch)
    &#123;
        Oled_Data.vOled_Write_Byte(CMD_NORMAL, OLED_CMD); &#x2F;&#x2F;正常显示
    &#125;
    else if(OLED_RESET &#x3D;&#x3D; swch)
    &#123;
        Oled_Data.vOled_Write_Byte(CMD_INVERSE, OLED_CMD);  &#x2F;&#x2F;反转显示
    &#125;
&#125;

&#x2F;*
 * @description: 屏幕旋转180度
 * @param: OLED_SET--正常显示 OLED_RESET--旋转显示
 * @return: 无
 * @Date: 2023-04-22 18:32:16
 *&#x2F;
&#x2F;&#x2F; 屏幕旋转180度
void vOled_Rotate_Display(uint8_t swch)
&#123;
    if(OLED_SET &#x3D;&#x3D; swch)
    &#123;
        Oled_Data.vOled_Write_Byte(CMD_DIRECTION_R_TO_L, OLED_CMD); &#x2F;&#x2F;正常显示
        Oled_Data.vOled_Write_Byte(CMD_RE_MAP_127, OLED_CMD);
    &#125;
    else if(OLED_RESET &#x3D;&#x3D; swch)
    &#123;
        Oled_Data.vOled_Write_Byte(CMD_DIRECTION_L_TO_R, OLED_CMD); &#x2F;&#x2F;旋转显示
        Oled_Data.vOled_Write_Byte(CMD_RE_MAP_0, OLED_CMD);
    &#125;
&#125;

&#x2F;*
 * @description: OLED显示控制
 * @param: OLED_SET--显示 OLED_RESET--不显示
 * @return: 无
 * @Date: 2023-04-22 18:36:36
 *&#x2F;
&#x2F;&#x2F; OLED显示控制
static void svOled_DisPlay_Control(uint8_t swch)
&#123;
    if (OLED_SET &#x3D;&#x3D; swch)
    &#123;
        Oled_Data.vOled_Write_Byte(0x8D, OLED_CMD); &#x2F;&#x2F; 电荷泵使能
        Oled_Data.vOled_Write_Byte(0x14, OLED_CMD); &#x2F;&#x2F; 开启电荷泵
        Oled_Data.vOled_Write_Byte(CMD_DISPLAY_ON, OLED_CMD); &#x2F;&#x2F; 点亮屏幕
    &#125;
    else if (OLED_RESET &#x3D;&#x3D; swch)
    &#123;
        Oled_Data.vOled_Write_Byte(0x8D, OLED_CMD); &#x2F;&#x2F; 电荷泵使能
        Oled_Data.vOled_Write_Byte(0x10, OLED_CMD); &#x2F;&#x2F; 关闭电荷泵
        Oled_Data.vOled_Write_Byte(CMD_DISPLAY_OFF, OLED_CMD); &#x2F;&#x2F; 关闭屏幕
    &#125;
&#125;

&#x2F;*
 * @description: 清屏函数
 * @return: 无
 * @Date: 2023-04-22 18:41:02
 *&#x2F;
&#x2F;&#x2F; 清屏函数
void vOled_Clear(void)
&#123;
    uint8_t i, n;
    for (i &#x3D; 0; i &lt; 8; i++)
    &#123;
        Oled_Data.vOled_Write_Byte(0xb0 + i, OLED_CMD); &#x2F;&#x2F; 设置页地址
        Oled_Data.vOled_Write_Byte(0x10, OLED_CMD);     &#x2F;&#x2F; 设置列地址的高4位
        Oled_Data.vOled_Write_Byte(0x02, OLED_CMD);     &#x2F;&#x2F; 设置列地址的低4位
        for (n &#x3D; 0; n &lt; 128; n++)
        &#123;
            Oled_Data.vOled_Write_Byte(0x00, OLED_DATA); &#x2F;&#x2F; 清除所有数据
        &#125;
    &#125;
&#125;

&#x2F;*
 * @description: 设置光标位置
 * @param &#123;uint8_t&#125; x
 * @param &#123;uint8_t&#125; y
 * @return: 无
 * @Date: 2023-04-22 18:45:13
 *&#x2F;
&#x2F;&#x2F; 设置光标位置
void vOled_Set_Address(uint8_t x, uint8_t y)
&#123;
    x +&#x3D; 2;
    Oled_Data.vOled_Write_Byte(0xb0 + y, OLED_CMD);             &#x2F;&#x2F;设置页地址
    Oled_Data.vOled_Write_Byte(((x &amp; 0xf0) &gt;&gt; 4) | 0x10, OLED_CMD); &#x2F;&#x2F;设置列地址的高4位
    Oled_Data.vOled_Write_Byte((x &amp; 0x0f), OLED_CMD);           &#x2F;&#x2F;设置列地址的低4位
&#125;

&#x2F;*
 * @description: 显示128x64点阵图像
 * @param &#123;uint8_t&#125; *dp
 * @return: 无
 * @Date: 2023-04-22 18:52:20
 *&#x2F;
&#x2F;&#x2F; 显示128x64点阵图像
void vOled_Display_128x64_Bmp(uint8_t *dp)
&#123;
    uint8_t i, j;
    for(i &#x3D; 0; i &lt; 8; i++)
    &#123;
        Oled_Data.vOled_Set_Address(0, i);
        for(j &#x3D; 0; j &lt; 128; j++)
        &#123;
            Oled_Data.vOled_Write_Byte(*dp, OLED_DATA); &#x2F;&#x2F;写数据到OLED,每写完一个8位的数据后列地址自动加1
            dp++;
        &#125;
    &#125;
&#125;

&#x2F;*
 * @description: 显示16x16点阵图像、汉字、生僻字或16x16点阵的其他图标
 * @param &#123;uint8_t&#125; x
 * @param &#123;uint8_t&#125; y
 * @param &#123;uint8_t&#125; *dp
 * @return: 无
 * @Date: 2023-04-22 18:54:23
 *&#x2F;
&#x2F;&#x2F; 显示16x16点阵图像、汉字、生僻字或16x16点阵的其他图标
static void svOled_Display_16x16(uint8_t x, uint8_t y, uint8_t *dp)
&#123;
    uint8_t i, j;
    for (j &#x3D; 0; j &lt; 2; j++)
    &#123;
        Oled_Data.vOled_Set_Address(x, y);
        for (i &#x3D; 0; i &lt; 16; i++)
        &#123;
            Oled_Data.vOled_Write_Byte(*dp, OLED_DATA); &#x2F;&#x2F; 写数据到OLED,每写完一个8位的数据后列地址自动加1
            dp++;
        &#125;
        y++;
    &#125;
&#125;

&#x2F;*
 * @description: 显示8x16点阵图像、ASCII, 或8x16点阵的自造字符、其他图标
 * @param &#123;uint8_t&#125; x
 * @param &#123;uint8_t&#125; y
 * @param &#123;uint8_t&#125; *dp
 * @return: 无
 * @Date: 2023-04-22 18:55:58
 *&#x2F;
&#x2F;&#x2F; 显示8x16点阵图像、ASCII, 或8x16点阵的自造字符、其他图标
static void svOled_Display_8x16(uint8_t x, uint8_t y, uint8_t *dp)
&#123;
    uint8_t i, j;
    for (j &#x3D; 0; j &lt; 2; j++)
    &#123;
        Oled_Data.vOled_Set_Address(x, y);
        for (i &#x3D; 0; i &lt; 8; i++)
        &#123;
            Oled_Data.vOled_Write_Byte(*dp, OLED_DATA); &#x2F;&#x2F; 写数据到LCD,每写完一个8位的数据后列地址自动加1
            dp++;
        &#125;
        y++;
    &#125;
&#125;

&#x2F;*
 * @description: 显示5*7点阵图像、ASCII, 或5x7点阵的自造字符、其他图标
 * @param &#123;uint8_t&#125; x
 * @param &#123;uint8_t&#125; y
 * @param &#123;uint8_t&#125; *dp
 * @return: 无
 * @Date: 2023-04-22 18:57:55
 *&#x2F;
&#x2F;&#x2F; 显示5*7点阵图像、ASCII, 或5x7点阵的自造字符、其他图标
void vOled_Display_5x7(uint8_t x, uint8_t y, uint8_t *dp)
&#123;
    uint8_t i;
    Oled_Data.vOled_Set_Address(x, y);
    for (i &#x3D; 0; i &lt; 6; i++)
    &#123;
        Oled_Data.vOled_Write_Byte(*dp, OLED_DATA);
        dp++;
    &#125;
&#125;


&#x2F;*
 * @description: 送指令到晶联讯字库IC
 * @param &#123;uint8_t&#125; dat
 * @return: 无
 * @Date: 2023-04-22 19:05:28
 *&#x2F;
&#x2F;&#x2F; 送指令到晶联讯字库IC
static void svOled_Send_Command_To_Rom(uint8_t dat)
&#123;
    uint8_t i;
    for (i &#x3D; 0; i &lt; 8; i++)
    &#123;
        SCL_OUT_0;
        if (dat &amp; 0x80)
        &#123;
            SDA_OUT_1;
        &#125;
        else
        &#123;
            SDA_OUT_0;
        &#125;
        dat &lt;&lt;&#x3D; 1;
        SCL_OUT_1;
    &#125;
&#125;

&#x2F;*
 * @description: 从晶联讯字库IC中取汉字或字符数据（1个字节）
 * @return &#123;*&#125;
 * @Date: 2023-04-22 19:13:07
 *&#x2F;
&#x2F;&#x2F; 从晶联讯字库IC中取汉字或字符数据（1个字节）
static uint8_t sucOled_Get_Data_From_Rom(void)
&#123;
    uint8_t i, read &#x3D; 0;

    for (i &#x3D; 0; i &lt; 8; i++)
    &#123;
        SCL_OUT_0;
        read &lt;&lt;&#x3D; 1;
        if (FS0_READ)
        &#123;
            read++;
        &#125;
        SCL_OUT_1;
    &#125;
    return read;
&#125;


&#x2F;*
 * @description: 连续读取
 * @param &#123;uint8_t&#125; addrHigh
 * @param &#123;uint8_t&#125; addrMid
 * @param &#123;uint8_t&#125; addrLow
 * @param &#123;uint8_t&#125; *pbuff
 * @param &#123;uint8_t&#125; DataLen
 * @return: 无
 * @Date: 2023-04-22 19:20:35
 *&#x2F;
&#x2F;&#x2F; 连续读取(从相关地址（addrHigh：地址高字节,addrMid：地址中字节,addrLow：地址低字节）中连续读出DataLen个字节的数据到 pbuff的地址)
static void svOled_Get_Data(uint8_t addrHigh, uint8_t addrMid, uint8_t addrLow, uint8_t *pbuff, uint8_t DataLen)
&#123;
    uint8_t i;
    CS2_OUT_0;
    svOled_Send_Command_To_Rom(0x03);
    svOled_Send_Command_To_Rom(addrHigh);
    svOled_Send_Command_To_Rom(addrMid);
    svOled_Send_Command_To_Rom(addrLow);
    for (i &#x3D; 0; i &lt; DataLen; i++)
    &#123;
        *(pbuff + i) &#x3D; sucOled_Get_Data_From_Rom();
    &#125;
    CS2_OUT_1;
&#125;

&#x2F;*
 * @description: 指定坐标显示GB2312字符串(16*16)
 * @param &#123;uint8_t&#125; x: 范围0~128
 * @param &#123;uint8_t&#125; y: 范围0~6
 * @param &#123;uint8_t&#125; *text : 要显示的字符串
 * @return: 无
 * @Date: 2023-04-22 19:36:42
 *&#x2F;
&#x2F;&#x2F; 指定坐标显示GB2312字符串(16*16)
void vOled_Display_Gb2312_String(uint8_t x, uint8_t y, uint8_t *text)
&#123;
    uint8_t i &#x3D; 0;
    uint8_t addrHigh, addrMid, addrLow;
    uint8_t fontbuf[32];

    while (text[i] &gt; 0x00)
    &#123;
        if ((text[i] &gt;&#x3D; 0xb0) &amp;&amp; (text[i] &lt;&#x3D; 0xf7) &amp;&amp; (text[i + 1] &gt;&#x3D; 0xa1))
        &#123;
            &#x2F;&#x2F; 国标简体（GB2312）汉字在晶联讯字库IC中的地址由以下公式来计算：
            &#x2F;&#x2F; Address &#x3D; ((MSB - 0xB0) * 94 + (LSB - 0xA1)+ 846)*32+ BaseAdd;BaseAdd&#x3D;0
            &#x2F;&#x2F; 由于担心8位单片机有乘法溢出问题，所以分三部取地址
            Oled_Data.Font_Addr &#x3D; (text[i] - 0xb0) * 94;
            Oled_Data.Font_Addr +&#x3D; (text[i + 1] - 0xa1) + 846;
            Oled_Data.Font_Addr &#x3D; (Oled_Data.Font_Addr) * 32;

            addrHigh &#x3D; (Oled_Data.Font_Addr &amp; 0xff0000) &gt;&gt; 16; &#x2F;&#x2F; 地址的高8位,共24位
            addrMid &#x3D; (Oled_Data.Font_Addr &amp; 0xff00) &gt;&gt; 8;     &#x2F;&#x2F; 地址的中8位,共24位
            addrLow &#x3D; (Oled_Data.Font_Addr &amp; 0xff);            &#x2F;&#x2F; 地址的低8位,共24位

            svOled_Get_Data(addrHigh, addrMid, addrLow, fontbuf, 32);
            &#x2F;&#x2F; 取32个字节的数据，存到&quot;fontbuf[32]&quot;
            svOled_Display_16x16(x, y, fontbuf);
            &#x2F;&#x2F; 显示汉字到LCD上，y为页地址，x为列地址，fontbuf[]为数据
            x +&#x3D; 16;
            i +&#x3D; 2;
        &#125;
        else if ((text[i] &gt;&#x3D; 0xa1) &amp;&amp; (text[i] &lt;&#x3D; 0xa3) &amp;&amp; (text[i + 1] &gt;&#x3D; 0xa1))
        &#123;

            Oled_Data.Font_Addr &#x3D; (text[i] - 0xa1) * 94;
            Oled_Data.Font_Addr +&#x3D; (text[i + 1] - 0xa1);
            Oled_Data.Font_Addr &#x3D; (Oled_Data.Font_Addr)  * 32;

            addrHigh &#x3D; (Oled_Data.Font_Addr &amp; 0xff0000) &gt;&gt; 16;
            addrMid &#x3D; (Oled_Data.Font_Addr &amp; 0xff00) &gt;&gt; 8;
            addrLow &#x3D; (Oled_Data.Font_Addr &amp; 0xff);

            svOled_Get_Data(addrHigh, addrMid, addrLow, fontbuf, 32);
            svOled_Display_16x16(x, y, fontbuf);
            x +&#x3D; 16;
            i +&#x3D; 2;
        &#125;
        else if ((text[i] &gt;&#x3D; 0x20) &amp;&amp; (text[i] &lt;&#x3D; 0x7e))
        &#123;
            unsigned char fontbuf[16];
            Oled_Data.Font_Addr &#x3D; (text[i] - 0x20);
            Oled_Data.Font_Addr &#x3D; (unsigned long)(Oled_Data.Font_Addr * 16);
            Oled_Data.Font_Addr &#x3D; (unsigned long)(Oled_Data.Font_Addr + 0x3cf80);

            addrHigh &#x3D; (Oled_Data.Font_Addr &amp; 0xff0000) &gt;&gt; 16;
            addrMid &#x3D; (Oled_Data.Font_Addr &amp; 0xff00) &gt;&gt; 8;
            addrLow &#x3D; Oled_Data.Font_Addr &amp; 0xff;

            svOled_Get_Data(addrHigh, addrMid, addrLow, fontbuf, 16);
            svOled_Display_8x16(x, y, fontbuf);
            x +&#x3D; 8;
            i +&#x3D; 1;
        &#125;
        else
            i++;
    &#125;
&#125;

&#x2F;*
 * @description: 指定坐标显示字符串(5*7)
 * @param &#123;uint8_t&#125; x
 * @param &#123;uint8_t&#125; y
 * @param &#123;uint8_t&#125; *text
 * @return: 无
 * @Date: 2023-04-22 19:41:51
 *&#x2F;
&#x2F;&#x2F; 指定坐标显示字符串(5*7)
static void vOled_Display_String_5x7(uint8_t x, uint8_t y, uint8_t *text)
&#123;
    uint8_t i &#x3D; 0;
    uint8_t addrHigh, addrMid, addrLow;

    while (text[i] &gt; 0x00)
    &#123;
        if ((text[i] &gt;&#x3D; 0x20) &amp;&amp; (text[i] &lt;&#x3D; 0x7e))
        &#123;
            uint8_t fontbuf[8];
            Oled_Data.Font_Addr &#x3D; (text[i] - 0x20);
            Oled_Data.Font_Addr &#x3D; (unsigned long)(Oled_Data.Font_Addr * 8);
            Oled_Data.Font_Addr &#x3D; (unsigned long)(Oled_Data.Font_Addr + 0x3bfc0);

            addrHigh &#x3D; (Oled_Data.Font_Addr &amp; 0xff0000) &gt;&gt; 16;
            addrMid &#x3D; (Oled_Data.Font_Addr &amp; 0xff00) &gt;&gt; 8;
            addrLow &#x3D; Oled_Data.Font_Addr &amp; 0xff;

            svOled_Get_Data(addrHigh, addrMid, addrLow, fontbuf, 8);
            vOled_Display_5x7(x, y, fontbuf);
            x +&#x3D; 6;
            i +&#x3D; 1;
        &#125;
        else
            i++;
    &#125;
&#125;

&#x2F;*
 * @description: 显示2个数字(小数)
 * @param: 起点坐标x
 * @param: 起点坐标y
 * @param: 要显示的小数
 * @param: 数字的位数
 * @return: 无
 * @Date: 2023-04-22 19:49:24
 *&#x2F;
&#x2F;&#x2F; 显示2个数字(小数)
static void svOled_Show_Decimal(uint8_t x, uint8_t y, float num1, uint8_t len)
&#123;
    uint8_t i;
    uint32_t t, num;
    x &#x3D; x + len * 8 + 8;                                    &#x2F;&#x2F; 要显示的小数最低位的横坐标
    num &#x3D; num1 * 100;                                       &#x2F;&#x2F; 将小数左移两位并转化为整数
    Oled_Data.vOled_Display_Gb2312_String(x - 24, y, (uint8_t *)&quot;.&quot;); &#x2F;&#x2F; 显示小数点
    for (i &#x3D; 0; i &lt; len; i++)
    &#123;
        t &#x3D; num % 10;   &#x2F;&#x2F; 取个位数的数值
        num &#x3D; num &#x2F; 10; &#x2F;&#x2F; 将整数右移一位
        x -&#x3D; 8;
        if (2 &#x3D;&#x3D; i)
        &#123;
            x -&#x3D; 8;
        &#125;
        &#x2F;&#x2F; 当显示出来两个小数之后，空出小数点的位置
        switch (t)
        &#123;
        case 0:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;0&quot;);
            break;
        case 1:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;1&quot;);
            break;
        case 2:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;2&quot;);
            break;
        case 3:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;3&quot;);
            break;
        case 4:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;4&quot;);
            break;
        case 5:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;5&quot;);
            break;
        case 6:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;6&quot;);
            break;
        case 7:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;7&quot;);
            break;
        case 8:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;8&quot;);
            break;
        case 9:
            Oled_Data.vOled_Display_Gb2312_String(x, y, (uint8_t *)&quot;9&quot;);
            break;
        &#125;
    &#125;
&#125;


&#x2F;*
 * @description: OLED的初始化
 * @return: 无
 * @Date: 2023-04-22 19:50:58
 *&#x2F;
&#x2F;&#x2F; OLED的初始化
void vOled_Init(void)
&#123;
    HAL_Delay(200);

    Oled_Data.vOled_Write_Byte(CMD_DISPLAY_OFF, OLED_CMD); &#x2F;*display off*&#x2F;
    Oled_Data.vOled_Write_Byte(0x02, OLED_CMD); &#x2F;*set lower column address*&#x2F;
    Oled_Data.vOled_Write_Byte(0x10, OLED_CMD); &#x2F;*set higher column address*&#x2F;
    Oled_Data.vOled_Write_Byte(0x40, OLED_CMD); &#x2F;*set display start line*&#x2F;
    Oled_Data.vOled_Write_Byte(0xB0, OLED_CMD); &#x2F;*set page address*&#x2F;
    Oled_Data.vOled_Write_Byte(0x81, OLED_CMD); &#x2F;*contract control*&#x2F;
    Oled_Data.vOled_Write_Byte(0xcf, OLED_CMD); &#x2F;*128*&#x2F;
    Oled_Data.vOled_Write_Byte(CMD_RE_MAP_127, OLED_CMD); &#x2F;*set segment remap*&#x2F;
    Oled_Data.vOled_Write_Byte(CMD_NORMAL, OLED_CMD); &#x2F;*normal &#x2F; reverse*&#x2F;
    Oled_Data.vOled_Write_Byte(0xA8, OLED_CMD); &#x2F;*multiplex ratio*&#x2F;
    Oled_Data.vOled_Write_Byte(0x3F, OLED_CMD); &#x2F;*duty &#x3D; 1&#x2F;64*&#x2F;
    Oled_Data.vOled_Write_Byte(0xad, OLED_CMD); &#x2F;*set charge pump enable*&#x2F;
    Oled_Data.vOled_Write_Byte(0x8b, OLED_CMD); &#x2F;* 0x8B 内供 VCC *&#x2F;
    Oled_Data.vOled_Write_Byte(0x33, OLED_CMD); &#x2F;*0X30---0X33 set VPP 9V *&#x2F;
    Oled_Data.vOled_Write_Byte(CMD_DIRECTION_R_TO_L, OLED_CMD); &#x2F;*Com scan direction*&#x2F;
    Oled_Data.vOled_Write_Byte(0xD3, OLED_CMD); &#x2F;*set display offset*&#x2F;
    Oled_Data.vOled_Write_Byte(0x00, OLED_CMD); &#x2F;* 0x20 *&#x2F;
    Oled_Data.vOled_Write_Byte(0xD5, OLED_CMD); &#x2F;*set osc division*&#x2F;
    Oled_Data.vOled_Write_Byte(0x80, OLED_CMD);
    Oled_Data.vOled_Write_Byte(0xD9, OLED_CMD); &#x2F;*set pre-charge period*&#x2F;
    Oled_Data.vOled_Write_Byte(0x1f, OLED_CMD); &#x2F;*0x22*&#x2F;
    Oled_Data.vOled_Write_Byte(0xDA, OLED_CMD); &#x2F;*set COM pins*&#x2F;
    Oled_Data.vOled_Write_Byte(0x12, OLED_CMD);
    Oled_Data.vOled_Write_Byte(0xdb, OLED_CMD); &#x2F;*set vcomh*&#x2F;
    Oled_Data.vOled_Write_Byte(0x40, OLED_CMD);
    Oled_Data.vOled_Clear();
    Oled_Data.vOled_Write_Byte(CMD_DISPLAY_ON, OLED_CMD); &#x2F;*display ON*&#x2F;
&#125;

&#x2F;*
 * @description: 指定大小显示BMP
 * @param &#123;unsigned char&#125; x0
 * @param &#123;unsigned char&#125; y0
 * @param &#123;unsigned char&#125; x1
 * @param &#123;unsigned char&#125; y1
 * @param &#123;unsigned char&#125; BMP
 * @return: 无
 * @Date: 2023-04-23 11:02:48
 *&#x2F;
&#x2F;&#x2F; 指定大小显示BMP
void vOled_Draw_Bmp(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, unsigned char BMP[])
&#123;
    unsigned int j &#x3D; 0;
    unsigned char x, y;
    if (y1 % 8 &#x3D;&#x3D; 0)
    &#123;
        y &#x3D; y1 &#x2F; 8;
    &#125;
    else
    &#123;
        y &#x3D; y1 &#x2F; 8 + 1;
    &#125;
    for (y &#x3D; y0; y &lt; y1; y++)
    &#123;
        Oled_Data.vOled_Set_Address(x0, y);
        for (x &#x3D; x0; x &lt; x1; x++)
        &#123;
            Oled_Data.vOled_Write_Byte(BMP[j++], OLED_DATA);
        &#125;
    &#125;
&#125;


&#x2F;*
 * @description: 点亮&#x2F;熄灭OLED屏幕某一行像素
 * @param &#123;uint8_t&#125; row
 * @return &#123;*&#125;
 * @Date: 2023-04-23 18:48:18
 *&#x2F;
&#x2F;&#x2F; 点亮&#x2F;熄灭OLED屏幕某一行像素
void vOled_Light_Row(uint8_t row, uint8_t swch)
&#123;
    &#x2F;&#x2F; 设置OLED显示范围为第row行（row从0开始计算）
    Oled_Data.vOled_Set_Address(0, row);
    &#x2F;&#x2F; 向OLED写入每个像素点的数据，可以根据需要修改该部分代码
    for (uint8_t col &#x3D; 0; col &lt; 128; col++)
    &#123;
        if(SET &#x3D;&#x3D; swch)
        &#123;
            Oled_Data.vOled_Write_Byte(0x01, OLED_DATA); &#x2F;&#x2F; 写入0x01表示该像素点为白色(0xFF则表示8行像素即1列大小)
        &#125;
        else
        &#123;
            Oled_Data.vOled_Write_Byte(0x00, OLED_DATA); &#x2F;&#x2F; 灭
        &#125;
    &#125;
&#125;

&#x2F;*
 * @description: 写入一组标准ASCII字符串	 19x24  数字字符
 * @param &#123;uint8_t&#125; x 范围0~128
 * @param &#123;uint8_t&#125; y 范围0~7
 * @param &#123;uint8_t&#125; ch 要显示的字符串
 * @return &#123;*&#125; 无
 * @Date: 2023-04-25 14:53:14
 *&#x2F;
&#x2F;&#x2F; 写入一组标准ASCII字符串	 19x24  数字字符
void vOled_Asc_19x24(uint8_t x, uint8_t y, uint8_t ch[])
&#123;
    uint8_t c &#x3D; 0, i &#x3D; 0, j &#x3D; 0;
    while (ch[j] !&#x3D; &#39;\0&#39;)
    &#123;
        c &#x3D; ch[j] - 0x30;   &#x2F;&#x2F;查字符在库中位置
        Oled_Data.vOled_Set_Address(x, y); &#x2F;&#x2F;设置坐标
        for (i &#x3D; 0; i &lt; 19; i++)
        &#123;
            Oled_Data.vOled_Write_Byte(F19x24[c][i], 1);
        &#125;
        Oled_Data.vOled_Set_Address(x, y + 1);
        for (i &#x3D; 19; i &lt; 38; i++)
        &#123;
            Oled_Data.vOled_Write_Byte(F19x24[c][i], 1);
        &#125;
        Oled_Data.vOled_Set_Address(x, y + 2);
        for (i &#x3D; 38; i &lt; 57; i++)
        &#123;
            Oled_Data.vOled_Write_Byte(F19x24[c][i], 1);
        &#125;
        x +&#x3D; 22; &#x2F;&#x2F;下个字符的x坐标
        j++;     &#x2F;&#x2F;下个字符
    &#125;
&#125;

&#x2F;*
 * @description: 画横向的短线
 * @param &#123;uint8_t&#125; x x坐标
 * @param &#123;uint8_t&#125; y y坐标
 * @param &#123;uint8_t&#125; num 需要的像素长度(左到右)
 * @return &#123;*&#125; 无
 * @Date: 2023-04-26 11:14:28
 *&#x2F;
&#x2F;&#x2F; 画横向的短线
void vOled_Painting_Pixel(uint8_t x, uint8_t y, uint8_t num)
&#123;
    for(uint8_t i &#x3D; 0; i &lt;&#x3D; num; i++)
    &#123;
        Oled_Data.vOled_Set_Address(x + i, y);
        Oled_Data.vOled_Write_Byte(0x01, OLED_DATA); &#x2F;&#x2F; 写入0x01表示该像素点为白色(0xFF则表示8行像素即1列大小)
    &#125;
&#125;</code></pre>
              </div>
            </details>
<details ><summary> Bmp.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 略</code></pre>
              </div>
            </details>
<h3 id="AS608指纹">AS608指纹</h3>
<ul>
<li>接线(看模块丝印，正负极不要接反！WAK引脚接不接无所谓看需要)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">AS608</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3V3(红色)</td>
<td style="text-align:center">3V3</td>
</tr>
<tr>
<td style="text-align:center">GND(黑色)</td>
<td style="text-align:center">GND</td>
</tr>
<tr>
<td style="text-align:center">RXD(白色)</td>
<td style="text-align:center">PB10(USART3_TX)</td>
</tr>
<tr>
<td style="text-align:center">TXD(黄色)</td>
<td style="text-align:center">PB11(USART3_RX)</td>
</tr>
<tr>
<td style="text-align:center">WAK(蓝色)</td>
<td style="text-align:center">PA15,有感应输出高电平，默认设置下拉输入即可</td>
</tr>
<tr>
<td style="text-align:center">Vt(绿色)</td>
<td style="text-align:center">触摸感应电源输入端,接3.3V(这个不接的话WAK引脚没用!)</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>需要用到一个定时器 TIM3进行串口接收时间计数</li>
<li>可以先把模块连接USB转串口模块然后打开上位机 <code>SYDemo</code> 进行测试录入等功能看看模块是否是好的</li>
<li>一般是通过判断WAK引脚来看用户是否按下，还有就是那个模块的氛围灯好像关不了找手册也没看到，看着好不舒服，我想的是按下才亮，不按就灭…</li>
</ul>
</blockquote>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> AS608.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 指纹模块
*@Author: Yang
*@Date: 2023-04-21 15:16:12
*&#x2F;
#ifndef __AS608_H
#define __AS608_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; AS608模块WAK引脚
#define AS608_WAK_PIN GPIO_PIN_15
&#x2F;&#x2F; 特征存储位置1
#define AS608_SAVE_1    0x01
&#x2F;&#x2F; 特征存储位置2
#define AS608_SAVE_2    0x02
&#x2F;&#x2F; 指纹ID最大数(看手册0~299)
#define AS608_MAX_ID    299

&#x2F;&#x2F; 指令-正确(0x00)
#define AS608_RETURN_TRUE    0x00
&#x2F;&#x2F; 指令-未搜到指纹(0x09)
#define AS608_RETURN_NOT_FOUND  0x09
&#x2F;&#x2F; 指令-处于一直把指纹放在上面状态
#define AS608_RETURN_ALWAY_LEAVE    0x17

&#x2F;&#x2F; result值~处于一直把指纹放在上面状态
#define RESULT_ALWAY_LEAVE    3
&#x2F;&#x2F; result值~默认值
#define RESULT_DEFAULT_VALUE    2

&#x2F;&#x2F; 管理员指纹ID
#define ADMIN_ID    1

&#x2F;&#x2F; LOG测试
#define AS608_LOG_1 0

&#x2F;&#x2F; 开锁后倒计时时间(s)
#define AS608_OPEN_LOCK_TIME    6

typedef struct
&#123;
	uint16_t pageID;&#x2F;&#x2F;指纹ID
	uint16_t mathscore;&#x2F;&#x2F;匹配得分
&#125;SearchResult;

typedef struct
&#123;
	uint16_t PS_max;&#x2F;&#x2F;指纹最大容量
	uint8_t  PS_level;&#x2F;&#x2F;安全等级
	uint32_t PS_addr;
	uint8_t  PS_size;&#x2F;&#x2F;通讯数据包大小
	uint8_t  PS_N;&#x2F;&#x2F;波特率基数N
&#125;SysPara;

typedef struct
&#123;
    &#x2F;&#x2F; 有效指纹个数
    uint16_t AS608_Fingerprint_Number;
    &#x2F;&#x2F; 是否有指纹按下标志位(wak引脚)
    bool AS608_Wak_Flag;
    &#x2F;&#x2F; 默认地址
    uint32_t AS608_Addr;
    uint8_t (*ucAS608_Get_Templete_Number)(uint16_t*);
    uint8_t (*ucAS608_Admin_Brush_Fingerprint)(void);
    void (*vAS608_Add_Fingerprint)(void);
    void (*vAS608_Delete_Fingerprint)(void);
    void (*vAS608_Search_Fingerprint_Number)(void);
    void (*vAS608_Verify_Fingerprint_1)(void);
    void (*vAS608_Fingerprint_Control_Function)(void);
    void (*vAS608_Empty_Fingerprint_All)(void);
&#125;AS608_TypeDef;

extern AS608_TypeDef AS608_Data;

uint8_t ucAS608_Admin_Brush_Fingerprint(void);
void vAS608_Add_Fingerprint(void);
void vAS608_Delete_Fingerprint(void);
void vAS608_Search_Fingerprint_Number(void);
void vAS608_Verify_Fingerprint_1(void);
void vAS608_Fingerprint_Control_Function(void);
void vAS608_Empty_Fingerprint_All(void);
uint8_t ucAS608_Get_Templete_Number(uint16_t *ValidN);
#endif
</code></pre>
              </div>
            </details>
<details ><summary> AS608.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
 *@Description: 指纹模块 接线：红色--&gt;3.3 黑色--&gt;GND 黄色--&gt;USART3_RX 白色--&gt;USART3_TX  蓝色--&gt;PA15 绿色--&gt;3.3V
 *@Author: Yang
 *@Date: 2023-04-21 15:07:12
 *&#x2F;
#include &quot;As608.h&quot;



&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;静态内部函数声明区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
static void svUsart3_Send_Byte(uint8_t byte_data);
static void svAS608_Send_Head(void);
static void svAS608_Send_Addr(void);
static void svAS608_Send_Flag(uint8_t flag);
static void svAS608_Send_Length(int length);
static void svAS608_Send_Cmd(uint8_t cmd);
static void svAS608_Send_Word(uint32_t word);
static void svAS608_Send_Check(uint16_t check);
static uint8_t sucAS608_Shake_Hand(uint32_t *PS_Addr);
static uint8_t *spucAS608_Wait_Str(uint16_t waittime);
static uint8_t sucAS608_Get_Image(void);
static uint8_t sucAS608_Create_Feature(uint8_t save_id);
static uint8_t sucAS608_Match(void);
static uint8_t sucAS608_Search(uint8_t save_id, uint16_t StartPage, uint16_t PageNum, SearchResult *p);
static uint8_t sucAS608_Compound_Feature(void);
static uint8_t sucAS608_Save_Template(uint8_t save_id, uint16_t PageID);
static uint8_t sucAS608_Delete_Template(uint16_t PageID, uint16_t N);
static uint8_t sucAS608_Empty_Template(void);
static uint8_t sucAS608_Write_Reg(uint8_t RegNum, uint8_t DATA);
static uint8_t sucAS608_Read_System_Parameters(SysPara *p);
static uint8_t sucAS608_Set_Addr(uint32_t PS_addr);
static uint8_t sucAS608_Write_Note(uint8_t NotePageNum, uint8_t *Byte32);
static uint8_t sucAS608_Read_Note(uint8_t NotePageNum, uint8_t *Byte32);
static uint8_t sucAS608_High_Speed_Search(uint8_t save_id, uint16_t StartPage, uint16_t PageNum, SearchResult *p);
static const char *cpcAS608_Error_Message(uint8_t ensure);
static uint8_t sucAS608_Verify_Fingerprint(SearchResult *p);
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;静态内部函数声明区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;



&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
&#x2F;&#x2F; 串口3接收数组
uint8_t Uart3_Rx_Buff[16];

AS608_TypeDef AS608_Data &#x3D;
&#123;
    .AS608_Fingerprint_Number &#x3D; 0,
    .AS608_Wak_Flag &#x3D; 0,
    .AS608_Addr &#x3D; 0xFFFFFFFF,
    .ucAS608_Get_Templete_Number &#x3D; &amp;ucAS608_Get_Templete_Number,
    .ucAS608_Admin_Brush_Fingerprint &#x3D; &amp;ucAS608_Admin_Brush_Fingerprint,
    .vAS608_Add_Fingerprint &#x3D; &amp;vAS608_Add_Fingerprint,
    .vAS608_Delete_Fingerprint &#x3D; &amp;vAS608_Delete_Fingerprint,
    .vAS608_Search_Fingerprint_Number &#x3D; &amp;vAS608_Search_Fingerprint_Number,
    .vAS608_Verify_Fingerprint_1 &#x3D; &amp;vAS608_Verify_Fingerprint_1,
    .vAS608_Fingerprint_Control_Function &#x3D; &amp;vAS608_Fingerprint_Control_Function,
    .vAS608_Empty_Fingerprint_All &#x3D; &amp;vAS608_Empty_Fingerprint_All
&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;










&#x2F;*
 * @description: 向串口3发送一个字节数据
 * @param: 要发送的数据
 * @return: 无
 * @Date: 2023-04-22 09:00:58
 *&#x2F;
&#x2F;&#x2F; 向串口3发送一个字节数据
static void svUsart3_Send_Byte(uint8_t byte_data)
&#123;
    &#x2F;&#x2F; 循环等待USART3发送寄存器（SR）的第6位标志位（TXE）变为1，表示发送缓冲区为空，可以继续发送数据
    while (0 &#x3D;&#x3D; (USART3-&gt;SR &amp; 0X40))
        ;
    &#x2F;&#x2F; 赋值给USART3数据寄存器（DR），从而实现向USART3发送数据
    USART3-&gt;DR &#x3D; byte_data;
&#125;

&#x2F;*
 * @description: 向AS608发送包头
 * @return: 无
 * @Date: 2023-04-22 09:14:27
 *&#x2F;
&#x2F;&#x2F; 向AS608发送包头
static void svAS608_Send_Head(void)
&#123;
    svUsart3_Send_Byte(0xEF);
    svUsart3_Send_Byte(0x01);
&#125;

&#x2F;*
 * @description: 向AS608发送芯片地址
 * @return: 无
 * @Date: 2023-04-22 09:20:40
 *&#x2F;
&#x2F;&#x2F; 向AS608发送芯片地址
static void svAS608_Send_Addr(void)
&#123;
    svUsart3_Send_Byte((AS608_Data.AS608_Addr) &gt;&gt; 24);
    svUsart3_Send_Byte((AS608_Data.AS608_Addr) &gt;&gt; 16);
    svUsart3_Send_Byte((AS608_Data.AS608_Addr) &gt;&gt; 8);
    svUsart3_Send_Byte(AS608_Data.AS608_Addr);
&#125;

&#x2F;*
 * @description: 向AS608发送标识符
 * @param: 标识符
 * @return: 无
 * @Date: 2023-04-22 09:22:24
 *&#x2F;
&#x2F;&#x2F; 向AS608发送标识符
static void svAS608_Send_Flag(uint8_t flag)
&#123;
    svUsart3_Send_Byte(flag);
&#125;

&#x2F;*
 * @description: 向AS608发送包长度
 * @param: 包长度
 * @return: 无
 * @Date: 2023-04-22 09:24:40
 *&#x2F;
&#x2F;&#x2F; 向AS608发送包长度
static void svAS608_Send_Length(int length)
&#123;
    svUsart3_Send_Byte(length &gt;&gt; 8);
    svUsart3_Send_Byte(length);
&#125;

&#x2F;*
 * @description: 向AS608发送命令码
 * @param: 命令码
 * @return: 无
 * @Date: 2023-04-22 09:26:00
 *&#x2F;
&#x2F;&#x2F; 向AS608发送命令码
static void svAS608_Send_Cmd(uint8_t cmd)
&#123;
    svUsart3_Send_Byte(cmd);
&#125;

&#x2F;*
 * @description: 向AS608发送口令
 * @param: 口令
 * @return: 无
 * @Date: 2023-04-22 09:28:19
 *&#x2F;
&#x2F;&#x2F; 向AS608发送口令
static void svAS608_Send_Word(uint32_t word)
&#123;
    svUsart3_Send_Byte(word &gt;&gt; 24);
    svUsart3_Send_Byte(word &gt;&gt; 16);
    svUsart3_Send_Byte(word &gt;&gt; 8);
    svUsart3_Send_Byte(word);
&#125;

&#x2F;*
 * @description: 向AS608发送校验和
 * @param: 校验和
 * @return: 无
 * @Date: 2023-04-22 09:30:06
 *&#x2F;
&#x2F;&#x2F; 向AS608发送校验和
static void svAS608_Send_Check(uint16_t check)
&#123;
    svUsart3_Send_Byte(check &gt;&gt; 8);
    svUsart3_Send_Byte(check);
&#125;

&#x2F;*
 * @description: 与AS608握手
 * @param: PS_Addr地址指针
 * @return: 新的地址(正确地址)
 * @Date: 2023-04-22 10:40:10
 *&#x2F;
&#x2F;&#x2F; 与AS608握手
static uint8_t sucAS608_Shake_Hand(uint32_t *PS_Addr)
&#123;
    svAS608_Send_Head();                        &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();                        &#x2F;&#x2F; 地址FFFFFFFF
    svAS608_Send_Flag(0X01);                    &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x0007);                &#x2F;&#x2F; 包长度:1(命令码1byte)+4(口令4byte)+2(校验码2byte)
    svAS608_Send_Cmd(0x13);                     &#x2F;&#x2F; 命令码
    svAS608_Send_Word(0x00000000);              &#x2F;&#x2F; 口令:默认为00000000
    svAS608_Send_Check(0x1b);                   &#x2F;&#x2F; 校验码为01+07+13&#x3D;1b
    HAL_UART_Receive(&amp;huart3, Uart3_Rx_Buff, 16, 100); &#x2F;&#x2F; 等待回应

    if ((0XEF &#x3D;&#x3D; Uart3_Rx_Buff[0]) &amp;&amp; (0X01 &#x3D;&#x3D; Uart3_Rx_Buff[1]) &amp;&amp; (0X07 &#x3D;&#x3D; Uart3_Rx_Buff[6])) &#x2F;&#x2F; 判断应答包
    &#123;
        *PS_Addr &#x3D; (Uart3_Rx_Buff[2] &lt;&lt; 24) + (Uart3_Rx_Buff[3] &lt;&lt; 16) + (Uart3_Rx_Buff[4] &lt;&lt; 8) + (Uart3_Rx_Buff[5]); &#x2F;&#x2F; 更新address
        return 0;
    &#125;
    return 1;
&#125;

&#x2F;*
 * @description: 判断中断接收的数组有没有应答包
 * @param: 等待中断接收数据的时间（单位1ms）
 * @return: 数据包首地址
 * @Date: 2023-04-22 10:37:32
 *&#x2F;
&#x2F;&#x2F; 判断中断接收的数组有没有应答包
static uint8_t *spucAS608_Wait_Str(uint16_t waittime)
&#123;
    char *data;
    uint8_t str[8];
    str[0] &#x3D; 0xef;
    str[1] &#x3D; 0x01;
    str[2] &#x3D; (AS608_Data.AS608_Addr) &gt;&gt; 24;
    str[3] &#x3D; (AS608_Data.AS608_Addr) &gt;&gt; 16;
    str[4] &#x3D; (AS608_Data.AS608_Addr) &gt;&gt; 8;
    str[5] &#x3D; AS608_Data.AS608_Addr;
    str[6] &#x3D; 0x07;
    str[7] &#x3D; &#39;\0&#39;;

    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    while (--waittime)
    &#123;
        HAL_Delay(1);
        if (MyUSART3_Data.Usart3_Rx_Sta &amp; 0x8000) &#x2F;&#x2F; 接收到一次数据
        &#123;
            data &#x3D; strstr((const char *)MyUSART3_Data.Usart3_Rx_Buff, (const char *)str); &#x2F;&#x2F; 比较接收到的包
            if (data)
            &#123;
                return (uint8_t *)data;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;

&#x2F;*
 * @description: 录入图像(探测手指，探测到后录入指纹图像存于ImageBuffer)
 * @return: 返回确认字
 * @Date: 2023-04-22 10:51:47
 *&#x2F;
&#x2F;&#x2F; 录入图像(探测手指，探测到后录入指纹图像存于ImageBuffer)
static uint8_t sucAS608_Get_Image(void)
&#123;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x03);
    svAS608_Send_Cmd(0x01);
    svAS608_Send_Check(0x0005);
    data &#x3D; spucAS608_Wait_Str(500); &#x2F;&#x2F; 500
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 生成特征(将ImageBuffer中的原始图像生成指纹特征文件存于AS608_SAVE_1或AS608_SAVE_2)
 * @param: AS608_SAVE_1:0x01	AS608_SAVE_2:0x02
 * @return: 返回确认字
 * @Date: 2023-04-22 11:07:42
 *&#x2F;
&#x2F;&#x2F; 生成特征
static uint8_t sucAS608_Create_Feature(uint8_t save_id)
&#123;
    uint16_t temp;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x04);
    svAS608_Send_Cmd(0x02);
    svUsart3_Send_Byte(save_id);
    temp &#x3D; 0x01 + 0x04 + 0x02 + save_id;
    svAS608_Send_Check(temp);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 精确比对两枚指纹特征(精确比对AS608_SAVE_1 与AS608_SAVE_2 中的特征文件)
 * @return: 返回确认字
 * @Date: 2023-04-22 11:15:05
 *&#x2F;
&#x2F;&#x2F; 精确比对两枚指纹特征
static uint8_t sucAS608_Match(void)
&#123;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x03);
    svAS608_Send_Cmd(0x03);
    svAS608_Send_Check(0x0007);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 搜索指纹(以AS608_SAVE_1或AS608_SAVE_2 中的特征文件搜索整个或部分指纹库.若搜索到，则返回页码)
 * @param: 特征存储位置1&#x2F;2
 * @param: 某一页开始
 * @param: 到若干页
 * @param: 搜索结果存储到结构体变量p中
 * @return: 确认字，页码（相配指纹模板）
 * @Date: 2023-04-22 11:19:46
 *&#x2F;
&#x2F;&#x2F; 搜索指纹
static uint8_t sucAS608_Search(uint8_t save_id, uint16_t StartPage, uint16_t PageNum, SearchResult *p)
&#123;
    uint16_t temp;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x08);
    svAS608_Send_Cmd(0x04);
    svUsart3_Send_Byte(save_id);
    svUsart3_Send_Byte(StartPage &gt;&gt; 8); &#x2F;&#x2F; 因为为2byte数据
    svUsart3_Send_Byte(StartPage);
    svUsart3_Send_Byte(PageNum &gt;&gt; 8);
    svUsart3_Send_Byte(PageNum);
    temp &#x3D; 0x01 + 0x08 + 0x04 + save_id + (StartPage &gt;&gt; 8) + (uint8_t)StartPage + (PageNum &gt;&gt; 8) + (uint8_t)PageNum;
    svAS608_Send_Check(temp);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
        p-&gt;pageID &#x3D; (data[10] &lt;&lt; 8) + data[11];
        p-&gt;mathscore &#x3D; (data[12] &lt;&lt; 8) + data[13];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 合并特征（生成模板）(将AS608_SAVE_1与AS608_SAVE_2中的特征文件合并生成 模板,结果存于AS608_SAVE_1与AS608_SAVE_2)
 * @return: 返回确认字
 * @Date: 2023-04-22 11:31:24
 *&#x2F;
&#x2F;&#x2F; 生成模板
static uint8_t sucAS608_Compound_Feature(void)
&#123;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x03);
    svAS608_Send_Cmd(0x05);
    svAS608_Send_Check(0x0009);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 储存模板(将 AS608_SAVE_1 或 AS608_SAVE_2 中的模板文件存到 PageID 号flash数据库位置)
 * @param: AS608_SAVE_1&#x2F;AS608_SAVE_2
 * @param: 指纹库位置号
 * @return: 返回确认字
 * @Date: 2023-04-22 11:36:52
 *&#x2F;
&#x2F;&#x2F; 储存模板
static uint8_t sucAS608_Save_Template(uint8_t save_id, uint16_t PageID)
&#123;
    uint16_t temp;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x06);
    svAS608_Send_Cmd(0x06);
    svUsart3_Send_Byte(save_id);
    svUsart3_Send_Byte(PageID &gt;&gt; 8);
    svUsart3_Send_Byte(PageID);
    temp &#x3D; 0x01 + 0x06 + 0x06 + save_id + (PageID &gt;&gt; 8) + (uint8_t)PageID;
    svAS608_Send_Check(temp);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 删除模板(删除flash数据库中指定ID号开始的连续N个指纹模板)
 * @param: 指纹库模板号
 * @param: 删除的模板个数
 * @return: 返回确认字
 * @Date: 2023-04-22 11:41:24
 *&#x2F;
&#x2F;&#x2F; 删除单个模板
static uint8_t sucAS608_Delete_Template(uint16_t PageID, uint16_t N)
&#123;
    uint16_t temp;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x07);
    svAS608_Send_Cmd(0x0C);
    svUsart3_Send_Byte(PageID &gt;&gt; 8);
    svUsart3_Send_Byte(PageID);
    svUsart3_Send_Byte(N &gt;&gt; 8);
    svUsart3_Send_Byte(N);
    temp &#x3D; 0x01 + 0x07 + 0x0C + (PageID &gt;&gt; 8) + (uint8_t)PageID + (N &gt;&gt; 8) + (uint8_t)N;
    svAS608_Send_Check(temp);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 清空指纹库(删除flash数据库中所有指纹模板)
 * @return: 返回确认字
 * @Date: 2023-04-22 11:45:51
 *&#x2F;
&#x2F;&#x2F; 清空指纹库(删除flash数据库中所有指纹模板)
static uint8_t sucAS608_Empty_Template(void)
&#123;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x03);
    svAS608_Send_Cmd(0x0D);
    svAS608_Send_Check(0x0011);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 写系统寄存器(写模块寄存器)
 * @param: 寄存器序号RegNum:4\5\6
 * @param: 数据
 * @return: 返回确认字
 * @Date: 2023-04-22 11:54:03
 *&#x2F;
&#x2F;&#x2F; 写系统寄存器(写模块寄存器)
static uint8_t sucAS608_Write_Reg(uint8_t RegNum, uint8_t DATA)
&#123;
    uint16_t temp;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x05);
    svAS608_Send_Cmd(0x0E);
    svUsart3_Send_Byte(RegNum);
    svUsart3_Send_Byte(DATA);
    temp &#x3D; RegNum + DATA + 0x01 + 0x05 + 0x0E;
    svAS608_Send_Check(temp);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 读系统基本参数(读取模块的基本参数（波特率，包大小等))
 * @param: 结构体指针
 * @return: 返回确认字 + 基本参数（16bytes）
 * @Date: 2023-04-22 12:01:40
 *&#x2F;
&#x2F;&#x2F; 读系统基本参数(读取模块的基本参数（波特率，包大小等))
static uint8_t sucAS608_Read_System_Parameters(SysPara *p)
&#123;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x03);
    svAS608_Send_Cmd(0x0F);
    svAS608_Send_Check(0x0013);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
        p-&gt;PS_max &#x3D; (data[14] &lt;&lt; 8) + data[15];                                        &#x2F;&#x2F; 模块最大指纹容量
        p-&gt;PS_level &#x3D; data[17];                                                        &#x2F;&#x2F; 对比等级
        p-&gt;PS_addr &#x3D; (data[18] &lt;&lt; 24) + (data[19] &lt;&lt; 16) + (data[20] &lt;&lt; 8) + data[21]; &#x2F;&#x2F; 地址
        p-&gt;PS_size &#x3D; data[23];
        p-&gt;PS_N &#x3D; data[25];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 设置模块地址
 * @param: 地址
 * @return: 返回确认字
 * @Date: 2023-04-22 12:05:59
 *&#x2F;
&#x2F;&#x2F; 设置模块地址
static uint8_t sucAS608_Set_Addr(uint32_t PS_addr)
&#123;
    uint16_t temp;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x07);
    svAS608_Send_Cmd(0x15);
    svUsart3_Send_Byte(PS_addr &gt;&gt; 24);
    svUsart3_Send_Byte(PS_addr &gt;&gt; 16);
    svUsart3_Send_Byte(PS_addr &gt;&gt; 8);
    svUsart3_Send_Byte(PS_addr);
    temp &#x3D; 0x01 + 0x07 + 0x15 + (uint8_t)(PS_addr &gt;&gt; 24) + (uint8_t)(PS_addr &gt;&gt; 16) + (uint8_t)(PS_addr &gt;&gt; 8) + (uint8_t)PS_addr;
    svAS608_Send_Check(temp);
    AS608_Data.AS608_Addr &#x3D; PS_addr; &#x2F;&#x2F; 发送完指令，更换地址
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    AS608_Data.AS608_Addr &#x3D; PS_addr;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 写入记事本(模块内部为用户开辟了256bytes的FLASH空间用于存用户记事本该记事本逻辑上被分成 16 个页)
 * @param: 0~15
 * @param: 要写入的内容
 * @return：返回确认字
 * @Date: 2023-04-22 12:10:12
 *&#x2F;
&#x2F;&#x2F; 写入记事本
static uint8_t sucAS608_Write_Note(uint8_t NotePageNum, uint8_t *Byte32)
&#123;
    uint16_t temp;
    uint8_t ensure, i;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(36);
    svAS608_Send_Cmd(0x18);
    svUsart3_Send_Byte(NotePageNum);
    for (i &#x3D; 0; i &lt; 32; i++)
    &#123;
        svUsart3_Send_Byte(Byte32[i]);
        temp +&#x3D; Byte32[i];
    &#125;
    temp &#x3D; 0x01 + 36 + 0x18 + NotePageNum + temp;
    svAS608_Send_Check(temp);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 读记事(读取FLASH用户区的128bytes数据)
 * @param: 0~15
 * @param: 存储读到的数据
 * @return: 返回确认字+用户信息
 * @Date: 2023-04-22 12:14:35
 *&#x2F;
&#x2F;&#x2F; 读记事
static uint8_t sucAS608_Read_Note(uint8_t NotePageNum, uint8_t *Byte32)
&#123;
    uint16_t temp;
    uint8_t ensure, i;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x04);
    svAS608_Send_Cmd(0x19);
    svUsart3_Send_Byte(NotePageNum);
    temp &#x3D; 0x01 + 0x04 + 0x19 + NotePageNum;
    svAS608_Send_Check(temp);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
        for (i &#x3D; 0; i &lt; 32; i++)
        &#123;
            Byte32[i] &#x3D; data[10 + i];
        &#125;
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 高速搜索(以 AS608_SAVE_1 或 AS608_SAVE_2 中的特征文件高速搜索整个或部分指纹库。若搜索到，则返回页码,该指令对于的确存在于指纹库中 ，且登录时质量很好的指纹，会很快给出搜索结果。)
 * @param: AS608_SAVE_1&#x2F;AS608_SAVE_2
 * @param: 起始页
 * @param: 页数
 * @param: 存储指针
 * @return: 返回确认字+页码（相配指纹模板）
 * @Date: 2023-04-22 12:18:37
 *&#x2F;
&#x2F;&#x2F; 高速搜索指纹库
static uint8_t sucAS608_High_Speed_Search(uint8_t save_id, uint16_t StartPage, uint16_t PageNum, SearchResult *p)
&#123;
    uint16_t temp;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x08);
    svAS608_Send_Cmd(0x1b);
    svUsart3_Send_Byte(save_id);
    svUsart3_Send_Byte(StartPage &gt;&gt; 8);
    svUsart3_Send_Byte(StartPage);
    svUsart3_Send_Byte(PageNum &gt;&gt; 8);
    svUsart3_Send_Byte(PageNum);
    temp &#x3D; 0x01 + 0x08 + 0x1b + save_id + (StartPage &gt;&gt; 8) + (uint8_t)StartPage + (PageNum &gt;&gt; 8) + (uint8_t)PageNum;
    svAS608_Send_Check(temp);
    data &#x3D; spucAS608_Wait_Str(600);
    if (data)
    &#123;
        ensure &#x3D; data[9];
        p-&gt;pageID &#x3D; (data[10] &lt;&lt; 8) + data[11];
        p-&gt;mathscore &#x3D; (data[12] &lt;&lt; 8) + data[13];
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 读有效模板个数
 * @param: 存储读取结果
 * @return: 返回确认字+有效模板个数ValidN
 * @Date: 2023-04-22 12:24:55
 *&#x2F;
&#x2F;&#x2F; 读有效模板个数(需要初始化时读取一次否则后面第一次读取是错误然后才正常)
uint8_t ucAS608_Get_Templete_Number(uint16_t *ValidN)
&#123;
    uint8_t ensure;
    uint8_t *data;

    svAS608_Send_Head();     &#x2F;&#x2F; 包头EF01
    svAS608_Send_Addr();     &#x2F;&#x2F; 地址
    svAS608_Send_Flag(0X01); &#x2F;&#x2F; 包标识:命令
    svAS608_Send_Length(0x03);
    svAS608_Send_Cmd(0x1d);
    svAS608_Send_Check(0x0021);
    data &#x3D; spucAS608_Wait_Str(500);
    if (data)
    &#123;
        ensure &#x3D; data[9];
        *ValidN &#x3D; (data[10] &lt;&lt; 8) + data[11]; &#x2F;&#x2F; 有效指纹数
    &#125;
    else
    &#123;
        ensure &#x3D; 0xFF;
    &#125;
    memset(MyUSART3_Data.Usart3_Rx_Buff, 0, MyUSART3_Data.Usart3_Rx_Sta &amp; 0x7FFF);
    MyUSART3_Data.Usart3_Rx_Sta &#x3D; 0;
    return ensure;
&#125;

&#x2F;*
 * @description: 各种错误信息输出
 * @param: 错误编号
 * @return: 字符串
 * @Date: 2023-04-22 12:28:56
 *&#x2F;
&#x2F;&#x2F; 各种错误信息输出
static const char *cpcAS608_Error_Message(uint8_t ensure)
&#123;
    const char *p;
    switch (ensure)
    &#123;
    case AS608_RETURN_TRUE:
    &#123;
        p &#x3D; &quot;OK&quot;;
        break;
    &#125;
    case 0x01:
    &#123;
        p &#x3D; &quot;数据包接收错误&quot;;
        break;
    &#125;
    case 0x02:
        p &#x3D; &quot;传感器上没有手指&quot;;
        break;
    case 0x03:
    &#123;
        p &#x3D; &quot;录入指纹图像失败&quot;;
        break;
    &#125;
    case 0x04:
    &#123;
        p &#x3D; &quot;指纹图像太干、太淡而生不成特征&quot;;
        break;
    &#125;
    case 0x05:
    &#123;
        p &#x3D; &quot;指纹图像太湿、太糊而生不成特征&quot;;
        break;
    &#125;
    case 0x06:
    &#123;
        p &#x3D; &quot;指纹图像太乱而生不成特征&quot;;
        break;
    &#125;
    case 0x07:
    &#123;
        p &#x3D; &quot;指纹图像正常，但特征点太少（或面积太小）而生不成特征&quot;;
        break;
    &#125;
    case 0x08:
    &#123;
        p &#x3D; &quot;指纹不匹配&quot;;
        break;
    &#125;
    case AS608_RETURN_NOT_FOUND:
    &#123;
        p &#x3D; &quot;没搜索到指纹&quot;;
        break;
    &#125;
    case 0x0a:
    &#123;
        p &#x3D; &quot;特征合并失败&quot;;
        break;
    &#125;
    case 0x0b:
    &#123;
        p &#x3D; &quot;访问指纹库时地址序号超出指纹库范围&quot;;
        break;
    &#125;
    case 0x10:
    &#123;
        p &#x3D; &quot;删除模板失败&quot;;
        break;
    &#125;
    case 0x11:
    &#123;
        p &#x3D; &quot;清空指纹库失败&quot;;
        break;
    &#125;
    case 0x15:
    &#123;
        p &#x3D; &quot;缓冲区内没有有效原始图而生不成图像&quot;;
        break;
    &#125;
    case 0x18:
    &#123;
        p &#x3D; &quot;读写 FLASH 出错&quot;;
        break;
    &#125;
    case 0x19:
    &#123;
        p &#x3D; &quot;未定义错误&quot;;
        break;
    &#125;
    case 0x1a:
    &#123;
        p &#x3D; &quot;无效寄存器号&quot;;
        break;
    &#125;
    case 0x1b:
    &#123;
        p &#x3D; &quot;寄存器设定内容错误&quot;;
        break;
    &#125;
    case 0x1c:
    &#123;
        p &#x3D; &quot;记事本页码指定错误&quot;;
        break;
    &#125;
    case 0x1f:
    &#123;
        p &#x3D; &quot;指纹库满&quot;;
        break;
    &#125;
    case 0x20:
    &#123;
        p &#x3D; &quot;地址错误&quot;;
        break;
    &#125;
    case AS608_RETURN_ALWAY_LEAVE:
    &#123;
        p &#x3D; &quot;处于一直把指纹放在上面状态&quot;;
        break;
    &#125;
    default:
    &#123;
        p &#x3D; &quot;模块返回确认码有误&quot;;
        break;
    &#125;
    &#125;
    return p;
&#125;

&#x2F;*******************************************应用层**************************************&#x2F;
&#x2F;*
 * @description: 验证指纹
 * @return &#123;*&#125; 验证成功-FINGERPRINT_TRUE 验证失败-FINGERPRINT_FALSE
 * @Date: 2023-04-24 12:01:10
 *&#x2F;
&#x2F;&#x2F; 验证指纹
static uint8_t sucAS608_Verify_Fingerprint(SearchResult *p)
&#123;
    uint8_t ensure;
    uint8_t result;
    while (1)
    &#123;
        ensure &#x3D; sucAS608_Get_Image();
        if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure) &#x2F;&#x2F; 获取图像成功
        &#123;
            ensure &#x3D; sucAS608_Create_Feature(AS608_SAVE_2);
            if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure) &#x2F;&#x2F; 生成特征成功
            &#123;
                ensure &#x3D; sucAS608_High_Speed_Search(AS608_SAVE_2, 0, AS608_MAX_ID, (SearchResult *)p);
#if AS608_LOG_1
                printf(&quot;%d\r\n&quot;, ensure);
                printf(&quot;%s\r\n&quot;, cpcAS608_Error_Message(ensure));
                printf(&quot;R:%d---%d\r\n&quot;, p-&gt;pageID, p-&gt;mathscore);
#endif
                if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure) &#x2F;&#x2F; 搜索成功
                &#123;
                    result &#x3D; FINGERPRINT_TRUE;
                    break;
                &#125;
                else if (AS608_RETURN_NOT_FOUND &#x3D;&#x3D; ensure) &#x2F;&#x2F; 搜索不到
                &#123;
                    result &#x3D; FINGERPRINT_FALSE;
                    break;
                &#125;
                else if (AS608_RETURN_ALWAY_LEAVE &#x3D;&#x3D; ensure)
                &#123;
                    result &#x3D; RESULT_ALWAY_LEAVE;
                    break;
                &#125;
            &#125;
            else
            &#123;
                result &#x3D; RESULT_DEFAULT_VALUE;
                break;
            &#125;
        &#125;
        else
        &#123;
            result &#x3D; RESULT_DEFAULT_VALUE;
            break;
        &#125;
    &#125;
    return result;
&#125;

&#x2F;*
 * @description: 管理员刷指纹验证
 * @return &#123;*&#125; 验证成功-FINGERPRINT_TRUE 验证失败-FINGERPRINT_FALSE
 * @Date: 2023-04-24 10:58:37
 *&#x2F;
&#x2F;&#x2F; 管理员刷指纹验证
uint8_t ucAS608_Admin_Brush_Fingerprint(void)
&#123;
    uint8_t result &#x3D; RESULT_DEFAULT_VALUE;
    SearchResult search;

    result &#x3D; sucAS608_Verify_Fingerprint(&amp;search);
    if (FINGERPRINT_TRUE &#x3D;&#x3D; result) &#x2F;&#x2F; 验证成功
    &#123;
        if (Admin_Data.Admin_Fingerprint_ID &#x3D;&#x3D; search.pageID) &#x2F;&#x2F; 对比ID号
        &#123;
            Buzzer_Data.vBuzzer_Ring();
            &#x2F;&#x2F; 回到主页面
            printf(&quot;%d\r\n&quot;, search.pageID);
            Menu_Data.Menu_State &#x3D; INTERFACE_1;
            Menu_Data.Menu_Flag_Buff[0] &#x3D; 0;
            Admin_Data.Administrator_Flag &#x3D; 1;
        &#125;
        &#x2F;&#x2F; printf(&quot;L:%d---%d\r\n&quot;,search.pageID,search.mathscore);
    &#125;
    return result;
&#125;

&#x2F;*
 * @description: 添加指纹，存储到指定ID
 * @return &#123;*&#125;
 * @Date: 2023-04-24 15:02:54
 *&#x2F;
&#x2F;&#x2F; 添加指纹，存储到指定ID
void vAS608_Add_Fingerprint(void)
&#123;
    uint8_t ensure;
    &#x2F;&#x2F; 执行步骤索引
    uint8_t Add_Index &#x3D; 1;
    &#x2F;&#x2F; 可选择ID范围0~299(但是一般不要用0,1~299即可)
    uint16_t id &#x3D; 1;
    uint8_t arr[20];

    Oled_Data.vOled_Clear();
    Oled_Data.vOled_Light_Row(5, SET); &#x2F;&#x2F; 显示一行像素
    Oled_Data.vOled_Display_Gb2312_String(2, 6, (uint8_t *)&quot;返回&quot;);
    &#x2F;&#x2F; 当录指纹成功或者按返回才会回到上一级菜单
    while (1)
    &#123;
        switch (Add_Index)
        &#123;
        case 1:
        &#123;
            &#x2F;&#x2F; 显示文字
            Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;请按指纹&quot;);
            ensure &#x3D; sucAS608_Get_Image();
            if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure) &#x2F;&#x2F; 等待模块发回指令
            &#123;
                Buzzer_Data.vBuzzer_Ring();
                HAL_Delay(100); &#x2F;&#x2F; 这里需要延时一下，模块内部处理图像需要时间
                ensure &#x3D; sucAS608_Create_Feature(AS608_SAVE_1);
                if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure)
                &#123;
                    Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;指纹正常&quot;);
                    HAL_Delay(MESSAGE_TIME);
                    Add_Index++; &#x2F;&#x2F; 跳到下一步
                &#125;
                else
                &#123;
                    printf(&quot;%s\r\n&quot;, cpcAS608_Error_Message(ensure));
                &#125;
            &#125;
            else
            &#123;
                printf(&quot;%s\r\n&quot;, cpcAS608_Error_Message(ensure));
            &#125;
            break;
        &#125;
        case 2:
        &#123;
            Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;再按一次&quot;);
            ensure &#x3D; sucAS608_Get_Image();
            if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure) &#x2F;&#x2F; 等待模块发回指令
            &#123;
                Buzzer_Data.vBuzzer_Ring();
                HAL_Delay(100); &#x2F;&#x2F; 这里需要延时一下，模块内部处理图像需要时间
                ensure &#x3D; sucAS608_Create_Feature(AS608_SAVE_2);
                if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure)
                &#123;
                    Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;指纹正常&quot;);
                    HAL_Delay(MESSAGE_TIME);
                    Add_Index++; &#x2F;&#x2F; 跳到下一步
                &#125;
                else
                &#123;
                    printf(&quot;%s\r\n&quot;, cpcAS608_Error_Message(ensure));
                    Add_Index &#x3D; 1;
                &#125;
            &#125;
            else
            &#123;
                printf(&quot;%s\r\n&quot;, cpcAS608_Error_Message(ensure));
            &#125;
            break;
        &#125;
        case 3:
        &#123;
            Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;对比指纹&quot;);
            HAL_Delay(MESSAGE_TIME);
            ensure &#x3D; sucAS608_Match();
            if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure) &#x2F;&#x2F; 对比成功
            &#123;
                Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;对比成功&quot;);
                HAL_Delay(MESSAGE_TIME);
                Add_Index++; &#x2F;&#x2F; 跳到下一步
            &#125;
            else &#x2F;&#x2F; 对比失败
            &#123;
                Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;对比失败&quot;);
                HAL_Delay(MESSAGE_TIME);
                Add_Index &#x3D; 1; &#x2F;&#x2F; 回到第一步
            &#125;
            break;
        &#125;
        case 4:
        &#123;
            Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;生成模板&quot;);
            HAL_Delay(MESSAGE_TIME);
            ensure &#x3D; sucAS608_Compound_Feature();
            if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure) &#x2F;&#x2F; 生成模板成功
            &#123;
                Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;生成成功&quot;);
                HAL_Delay(MESSAGE_TIME);
                Add_Index++; &#x2F;&#x2F; 跳到下一步
            &#125;
            else
            &#123;
                Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;生成失败&quot;);
                HAL_Delay(MESSAGE_TIME);
                Add_Index &#x3D; 1; &#x2F;&#x2F; 回到第一步
            &#125;
            break;
        &#125;
        case 5: &#x2F;&#x2F; 选择存储ID
        &#123;
            Oled_Data.vOled_Display_Gb2312_String(2, 6, (uint8_t *)&quot;返回&quot;);
            Oled_Data.vOled_Display_Gb2312_String(47, 6, (uint8_t *)&quot;加减&quot;);
            Oled_Data.vOled_Display_Gb2312_String(96, 6, (uint8_t *)&quot;确认&quot;);
            if (Key_Data.Key_Down_Buff[1]) &#x2F;&#x2F; K2短按++
            &#123;
                Key_Data.Key_Down_Buff[1] &#x3D; 0;
                Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
                id++;
                if (id &gt; 299)
                &#123;
                    id &#x3D; 1;
                &#125;
                Oled_Data.vOled_Clear();
            &#125;
            else if (Key_Data.Key_Down_Buff[4]) &#x2F;&#x2F; K2长按
            &#123;
                Key_Data.Key_Down_Buff[4] &#x3D; 0;
                Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
                if (id &gt; 1)
                &#123;
                    id--;
                &#125;
                Oled_Data.vOled_Clear();
            &#125;
            else if (Key_Data.Key_Down_Buff[2]) &#x2F;&#x2F; K3短按确认
            &#123;
                Key_Data.Key_Down_Buff[2] &#x3D; 0;
                Buzzer_Data.vBuzzer_Ring();                        &#x2F;&#x2F; 蜂鸣器滴一下
                ensure &#x3D; sucAS608_Save_Template(AS608_SAVE_2, id); &#x2F;&#x2F; 把第二次按下的存储
                if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure)
                &#123;
                    Oled_Data.vOled_Clear();
                    snprintf(arr, sizeof(arr), &quot;添加成功,ID为%d&quot;, id);
                    Oled_Data.vOled_Display_Gb2312_String(10, 2, (uint8_t *)arr);
                    HAL_Delay(MESSAGE_TIME);
                    Menu_Data.Menu_State &#x3D; INTERFACE_3;
                    Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
                    return;
                &#125;
                else
                &#123;
                    Oled_Data.vOled_Clear();
                    Oled_Data.vOled_Display_Gb2312_String(27, 2, (uint8_t *)&quot;添加失败&quot;);
                    HAL_Delay(MESSAGE_TIME);
                    Add_Index &#x3D; 1; &#x2F;&#x2F; 回到第一步
                &#125;
            &#125;
            snprintf(arr, sizeof(arr), &quot;选择存储ID为:%d&quot;, id);
            Oled_Data.vOled_Display_Gb2312_String(0, 2, (uint8_t *)arr);
            break;
        &#125;
        &#125;
        &#x2F;&#x2F; 回到功能页面
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            Menu_Data.Menu_State &#x3D; INTERFACE_3;
            Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
            return;
        &#125;
        MyUSART1_Data.vUsart1_Rx_Data_Analytic(); &#x2F;&#x2F; 不要忘记串口数据解析(因为这是死循环所以不放这接收不到)
    &#125;
&#125;

&#x2F;*
 * @description: 指定ID删除单个指纹
 * @return &#123;*&#125;
 * @Date: 2023-04-24 18:05:44
 *&#x2F;
&#x2F;&#x2F; 指定ID删除单个指纹
void vAS608_Delete_Fingerprint(void)
&#123;
    uint8_t ensure;
    uint8_t Add_Index &#x3D; 1;
    &#x2F;&#x2F; 可选择ID范围0~299
    uint16_t id &#x3D; 0;
    uint8_t arr[30];

    Oled_Data.vOled_Clear();
    while (1)
    &#123;
        switch (Add_Index)
        &#123;
        case 1:
        &#123;
            Oled_Data.vOled_Light_Row(5, SET); &#x2F;&#x2F; 显示一行像素
            snprintf(arr, sizeof(arr), &quot;要删除的ID为:%d&quot;, id);
            Oled_Data.vOled_Display_Gb2312_String(0, 2, (uint8_t *)arr);
            Oled_Data.vOled_Display_Gb2312_String(2, 6, (uint8_t *)&quot;返回&quot;);
            Oled_Data.vOled_Display_Gb2312_String(47, 6, (uint8_t *)&quot;加减&quot;);
            Oled_Data.vOled_Display_Gb2312_String(96, 6, (uint8_t *)&quot;确认&quot;);
            if (Key_Data.Key_Down_Buff[1])
            &#123;
                Key_Data.Key_Down_Buff[1] &#x3D; 0;
                Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
                id++;
                if (id &gt;&#x3D; 299)
                &#123;
                    id &#x3D; 299;
                &#125;
                Oled_Data.vOled_Clear();
            &#125;
            if (Key_Data.Key_Down_Buff[4])
            &#123;
                Key_Data.Key_Down_Buff[4] &#x3D; 0;
                Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
                if (id !&#x3D; 0)
                &#123;
                    id--;
                &#125;
                Oled_Data.vOled_Clear();
            &#125;
            if (Key_Data.Key_Down_Buff[2]) &#x2F;&#x2F; 确认
            &#123;
                Key_Data.Key_Down_Buff[2] &#x3D; 0;
                Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
                snprintf(arr, sizeof(arr), &quot;确认要删除id%d吗?&quot;, id);
                Oled_Data.vOled_Clear();
                Oled_Data.vOled_Display_Gb2312_String(0, 2, (uint8_t *)arr);
                Oled_Data.vOled_Display_Gb2312_String(2, 6, (uint8_t *)&quot;取消&quot;);
                Oled_Data.vOled_Display_Gb2312_String(96, 6, (uint8_t *)&quot;确认&quot;);
                Add_Index++;
            &#125;
            break;
        &#125;
        case 2:
        &#123;
            if (Key_Data.Key_Down_Buff[0]) &#x2F;&#x2F; 取消
            &#123;
                Key_Data.Key_Down_Buff[0] &#x3D; 0;
                Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
                id &#x3D; 0;
                Oled_Data.vOled_Clear();
                Add_Index &#x3D; 1;
            &#125;
            if (Key_Data.Key_Down_Buff[2]) &#x2F;&#x2F; 确认
            &#123;
                Key_Data.Key_Down_Buff[2] &#x3D; 0;
                Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
                ensure &#x3D; sucAS608_Delete_Template(id, 1);
                if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure)
                &#123;
                    Oled_Data.vOled_Clear();
                    Oled_Data.vOled_Light_Row(5, SET); &#x2F;&#x2F; 显示一行像素
                    snprintf(arr, sizeof(arr), &quot;删除ID%d成功&quot;, id);
                    Oled_Data.vOled_Display_Gb2312_String(0, 2, (uint8_t *)arr);
                    HAL_Delay(MESSAGE_TIME);
                    Menu_Data.Menu_State &#x3D; INTERFACE_3;
                    Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
                    return;
                &#125;
                else
                &#123;
                    Oled_Data.vOled_Clear();
                    Oled_Data.vOled_Light_Row(5, SET); &#x2F;&#x2F; 显示一行像素
                    memset(arr, 0, sizeof(arr));
                    snprintf(arr, sizeof(arr), &quot;删除ID%d失败&quot;, id);
                    Oled_Data.vOled_Display_Gb2312_String(0, 2, (uint8_t *)arr);
                    HAL_Delay(MESSAGE_TIME);
                    Oled_Data.vOled_Clear();
                    Add_Index &#x3D; 1;
                &#125;
            &#125;
            break;
        &#125;
        &#125;
        &#x2F;&#x2F; 回到功能页面
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            Menu_Data.Menu_State &#x3D; INTERFACE_3;
            Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
            return;
        &#125;
        MyUSART1_Data.vUsart1_Rx_Data_Analytic(); &#x2F;&#x2F; 不要忘记串口数据解析(因为这是死循环所以不放这接收不到)
    &#125;
&#125;

&#x2F;*
 * @description: 指纹数量
 * @return &#123;*&#125;
 * @Date: 2023-04-24 19:24:54
 *&#x2F;
&#x2F;&#x2F; 指纹数量
void vAS608_Search_Fingerprint_Number(void)
&#123;
    uint8_t arr[20];
    uint8_t ensure;
    Oled_Data.vOled_Clear();
    Oled_Data.vOled_Light_Row(5, SET); &#x2F;&#x2F; 显示一行像素
    Oled_Data.vOled_Display_Gb2312_String(2, 6, (uint8_t *)&quot;返回&quot;);
    ensure &#x3D; AS608_Data.ucAS608_Get_Templete_Number(&amp;AS608_Data.AS608_Fingerprint_Number);
    while (1)
    &#123;
        if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure)
        &#123;
            snprintf(arr, sizeof(arr), &quot;已用ID:%d 个&quot;, AS608_Data.AS608_Fingerprint_Number);
            Oled_Data.vOled_Display_Gb2312_String(10, 0, (uint8_t *)arr);
            snprintf(arr, sizeof(arr), &quot;剩余ID:%d 个&quot;, AS608_MAX_ID - AS608_Data.AS608_Fingerprint_Number);
            Oled_Data.vOled_Display_Gb2312_String(10, 2, (uint8_t *)arr);
        &#125;
        else
        &#123;
            Oled_Data.vOled_Display_Gb2312_String(10, 1, (uint8_t *)&quot;查询失败!!!&quot;);
            HAL_Delay(MESSAGE_TIME);
            Menu_Data.Menu_State &#x3D; INTERFACE_3;
            Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
        &#125;
        &#x2F;&#x2F; 回到功能页面
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            Menu_Data.Menu_State &#x3D; INTERFACE_3;
            Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
            return;
        &#125;
        if (INTERFACE_6 &#x3D;&#x3D; Menu_Data.Menu_State)
        &#123;
            return;
        &#125;
        MyUSART1_Data.vUsart1_Rx_Data_Analytic(); &#x2F;&#x2F; 串口通信
    &#125;
&#125;

&#x2F;*
 * @description: 验证指纹---功能区
 * @return &#123;*&#125; 无
 * @Date: 2023-04-26 13:00:23
 *&#x2F;
&#x2F;&#x2F; 验证指纹---功能区
void vAS608_Verify_Fingerprint_1(void)
&#123;
    uint8_t v_Flag &#x3D; 0;
    SearchResult search;
    uint8_t result &#x3D; RESULT_DEFAULT_VALUE;
    uint8_t arr[20];

    while (1)
    &#123;
        MyUSART1_Data.vUsart1_Rx_Data_Analytic(); &#x2F;&#x2F; 串口通信
        &#x2F;&#x2F; 回到功能页面
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            Menu_Data.Menu_State &#x3D; INTERFACE_3;
            Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
            return;
        &#125;
        if (0 &#x3D;&#x3D; v_Flag)
        &#123;
            v_Flag &#x3D; 1;
            Menu_Data.vMenu_Admin_Verify_Interface();
        &#125;
        result &#x3D; sucAS608_Verify_Fingerprint(&amp;search);
        MyAll_Data.vTime_Out_Init();    &#x2F;&#x2F; 超时等待清0
        if (FINGERPRINT_TRUE &#x3D;&#x3D; result) &#x2F;&#x2F; 验证成功
        &#123;
            Buzzer_Data.vBuzzer_Ring();
            Oled_Data.vOled_Clear();
            snprintf(arr, sizeof(arr), &quot;验证成功,ID为%d&quot;, search.pageID);
            Oled_Data.vOled_Display_Gb2312_String(0, 2, (uint8_t *)arr);
            HAL_Delay(MESSAGE_TIME);
            v_Flag &#x3D; 0;
            result &#x3D; RESULT_DEFAULT_VALUE;
        &#125;
        else if (FINGERPRINT_FALSE &#x3D;&#x3D; result)
        &#123;
            Buzzer_Data.vBuzzer_Ring();
            Oled_Data.vOled_Clear();
            snprintf(arr, sizeof(arr), &quot;验证失败!!!&quot;);
            Oled_Data.vOled_Display_Gb2312_String(10, 2, (uint8_t *)arr);
            HAL_Delay(MESSAGE_TIME);
            &#x2F;&#x2F; 回到主页面
            v_Flag &#x3D; 0;
            result &#x3D; RESULT_DEFAULT_VALUE;
        &#125;
        else if (RESULT_ALWAY_LEAVE &#x3D;&#x3D; result)
        &#123;
            Buzzer_Data.vBuzzer_Ring();
            Oled_Data.vOled_Clear();
            snprintf(arr, sizeof(arr), &quot;勿一直放传感器上&quot;);
            Oled_Data.vOled_Display_Gb2312_String(0, 2, (uint8_t *)arr);
            HAL_Delay(MESSAGE_TIME);
            v_Flag &#x3D; 0;
            result &#x3D; RESULT_DEFAULT_VALUE;
        &#125;
    &#125;
&#125;

&#x2F;*
 * @description: 指纹控制函数
 * @return &#123;*&#125;
 * @Date: 2023-04-26 18:30:45
 *&#x2F;
&#x2F;&#x2F; 指纹控制函数
void vAS608_Fingerprint_Control_Function(void)
&#123;
    uint8_t arr[20];
    SearchResult search;
    uint8_t result &#x3D; RESULT_DEFAULT_VALUE;

    result &#x3D; sucAS608_Verify_Fingerprint(&amp;search);
    MyAll_Data.vTime_Out_Init();    &#x2F;&#x2F; 超时等待清0
    if (FINGERPRINT_TRUE &#x3D;&#x3D; result) &#x2F;&#x2F; 验证成功
    &#123;
        SG90_Data.vSG90_Mode_switch();
        result &#x3D; RESULT_DEFAULT_VALUE;
    &#125;
    else if (FINGERPRINT_FALSE &#x3D;&#x3D; result)
    &#123;
        Buzzer_Data.vBuzzer_Ring();
        Oled_Data.vOled_Clear();
        snprintf(arr, sizeof(arr), &quot;验证失败!!!&quot;);
        Oled_Data.vOled_Display_Gb2312_String(20, 2, (uint8_t *)arr);
        HAL_Delay(MESSAGE_TIME);
        result &#x3D; RESULT_DEFAULT_VALUE;
    &#125;
&#125;

&#x2F;*
 * @description: 清空指纹库界面 【功能】
 * @return &#123;*&#125;
 * @Date: 2023-04-27 14:46:13
 *&#x2F;
&#x2F;&#x2F; 清空指纹库界面 【功能】
void vAS608_Empty_Fingerprint_All(void)
&#123;
    uint8_t arr[20];
    uint8_t ensure;
    Oled_Data.vOled_Clear();
    Oled_Data.vOled_Light_Row(5, SET); &#x2F;&#x2F; 显示一行像素
    Oled_Data.vOled_Display_Gb2312_String(0, 0, (uint8_t *)&quot;是否真的要清空?&quot;);
    Oled_Data.vOled_Display_Gb2312_String(2, 6, (uint8_t *)&quot;取消&quot;);
    Oled_Data.vOled_Display_Gb2312_String(96, 6, (uint8_t *)&quot;确认&quot;);

    while (1)
    &#123;
        &#x2F;&#x2F; 取消清空 回到功能页面
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            Menu_Data.Menu_State &#x3D; INTERFACE_3;
            Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
            return;
        &#125;
        &#x2F;&#x2F; 删除!!!
        if (Key_Data.Key_Down_Buff[2])
        &#123;
            Key_Data.Key_Down_Buff[2] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            ensure &#x3D; sucAS608_Empty_Template();
            if (AS608_RETURN_TRUE &#x3D;&#x3D; ensure)
            &#123;
                Oled_Data.vOled_Display_Gb2312_String(30, 0, (uint8_t *)&quot;已清空&quot;);
                HAL_Delay(MESSAGE_TIME);
                Menu_Data.Menu_State &#x3D; INTERFACE_3;
                Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
                return;
            &#125;
            else
            &#123;
                Oled_Data.vOled_Display_Gb2312_String(10, 1, (uint8_t *)&quot;清空失败!!!&quot;);
                HAL_Delay(MESSAGE_TIME);
                Menu_Data.Menu_State &#x3D; INTERFACE_3;
                Menu_Data.Menu_Flag_Buff[2] &#x3D; 1;
                return;
            &#125;
        &#125;
        if (INTERFACE_6 &#x3D;&#x3D; Menu_Data.Menu_State)
        &#123;
            return;
        &#125;
        MyUSART1_Data.vUsart1_Rx_Data_Analytic(); &#x2F;&#x2F; 串口通信
    &#125;
&#125;
</code></pre>
              </div>
            </details>
<h3 id="SG90">SG90</h3>
<ul>
<li>接线</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">SG90</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">VCC(红色)</td>
<td style="text-align:center">5V</td>
</tr>
<tr>
<td style="text-align:center">GND(棕色)</td>
<td style="text-align:center">GND</td>
</tr>
<tr>
<td style="text-align:center">PWM线(橙色)</td>
<td style="text-align:center">PB8(TIM4_CH3)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>需要在MX设置PWM频率为50HZ</p>
</blockquote>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> SG90.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifndef __SG90_H
#define __SG90_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; SG90定时器的arr计数值
#define SG90_ARR_VALUE  200
&#x2F;&#x2F; SG90--0度所需占空比
#define SG90_ANGLE_0 2.5
&#x2F;&#x2F; SG90--45度所需占空比
#define SG90_ANGLE_45 5
&#x2F;&#x2F; SG90--90度所需占空比
#define SG90_ANGLE_90 7.5
&#x2F;&#x2F; SG90--180度所需占空比
#define SG90_ANGLE_180 12.5

typedef struct
&#123;
    void (*vSG90_Set_Duty)(float);
    void (*vSG90_Control_Angle)(uint8_t);
    void (*vSG90_Mode_switch)(void);
&#125; SG90_TypeDef;

extern SG90_TypeDef SG90_Data;

void vSG90_Set_Duty(float duty);
void vSG90_Control_Angle(uint8_t angle);
void vSG90_Mode_switch(void);
#endif</code></pre>
              </div>
            </details>
<details ><summary> SG90.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: SG90舵机
*@Author: Yang
*@Date: 2023-04-26 14:46:43
*&#x2F;
#include &quot;SG90.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
SG90_TypeDef SG90_Data &#x3D;
&#123;
    .vSG90_Set_Duty &#x3D; &amp;vSG90_Set_Duty,
    .vSG90_Control_Angle &#x3D; &amp;vSG90_Control_Angle,
    .vSG90_Mode_switch &#x3D; &amp;vSG90_Mode_switch
&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*
 * @description: 设置SG90占空比
 * @param &#123;float&#125; duty 占空比范围(0~100)
 * @return &#123;*&#125;
 * @Date: 2023-04-26 15:18:03
 *&#x2F;
&#x2F;&#x2F; 设置SG90占空比
void vSG90_Set_Duty(float duty)
&#123;
    TIM4-&gt;CCR3 &#x3D; SG90_ARR_VALUE * (duty &#x2F; 100.0f); &#x2F;&#x2F; 设置占空比
&#125;

&#x2F;*
 * @description: 控制舵机转动0~180度(通过斜率公式计算)
 * @param &#123;uint8_t&#125; angle 范围0~180
 * @return &#123;*&#125; 无
 * @Date: 2023-04-26 17:38:07
 *&#x2F;
&#x2F;&#x2F; 控制舵机转动0~180度
void vSG90_Control_Angle(uint8_t angle)
&#123;
    float duty_temp &#x3D; 0;

    duty_temp &#x3D; (0.055f * angle) + 2.55;
    SG90_Data.vSG90_Set_Duty(duty_temp);
&#125;

&#x2F;*
 * @description: 舵机开关门动作及显示函数
 * @return &#123;*&#125;
 * @Date: 2023-05-02 19:08:32
 *&#x2F;
&#x2F;&#x2F; 舵机开关门动作及显示函数
void vSG90_Mode_switch(void)
&#123;
    uint8_t arr[20];

    Oled_Data.vOled_Clear();
    Buzzer_Data.vBuzzer_Ring();
    SG90_Data.vSG90_Control_Angle(180); &#x2F;&#x2F; 开锁
    Oled_Data.vOled_Light_Row(1, SET);  &#x2F;&#x2F; 显示一行像素
    Oled_Data.vOled_Light_Row(4, SET);  &#x2F;&#x2F; 显示一行像素
    Oled_Data.vOled_Display_Gb2312_String(35, 2, (uint8_t *)&quot;已开锁&quot;);
    MyUSART2_Data.WIFI_printf(&quot;Open\r\n&quot;);
    for (uint8_t i &#x3D; AS608_OPEN_LOCK_TIME; i &gt; 0; i--)
    &#123;
        MyAll_Data.vTime_Out_Init(); &#x2F;&#x2F; 超时等待清0
        snprintf(arr, sizeof(arr), &quot;将在%02d秒后上锁&quot;, i);
        Oled_Data.vOled_Display_Gb2312_String(0, 6, (uint8_t *)arr);
        HAL_Delay(1000);
    &#125;
    Oled_Data.vOled_Clear();
    SG90_Data.vSG90_Control_Angle(0);  &#x2F;&#x2F; 上锁
    Oled_Data.vOled_Light_Row(1, SET); &#x2F;&#x2F; 显示一行像素
    Oled_Data.vOled_Light_Row(4, SET); &#x2F;&#x2F; 显示一行像素
    Oled_Data.vOled_Display_Gb2312_String(35, 2, (uint8_t *)&quot;已上锁&quot;);
    HAL_Delay(MESSAGE_TIME);
&#125;</code></pre>
              </div>
            </details>
<h3 id="通用">通用</h3>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> MyAll.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 总头文件
*@Author: Yang
*@Date: 2023-04-21 16:19:37
*&#x2F;
#ifndef __MYALL_H
#define __MYALL_H
#include &quot;main.h&quot;
#include &quot;dma.h&quot;
#include &quot;tim.h&quot;
#include &quot;usart.h&quot;
#include &quot;gpio.h&quot;
#include &quot;rtc.h&quot;
#include &quot;iwdg.h&quot;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;math.h&gt;
#include &lt;stdarg.h&gt;

#include &quot;As608.h&quot;
#include &quot;Led.h&quot;
#include &quot;Key.h&quot;
#include &quot;Oled.h&quot;
#include &quot;Buzzer.h&quot;
#include &quot;MyUSART1.h&quot;
#include &quot;MyUSART2.h&quot;
#include &quot;MyUSART3.h&quot;
#include &quot;Menu.h&quot;
#include &quot;Clock.h&quot;
#include &quot;SG90.h&quot;
#include &quot;ESP8266.h&quot;


&#x2F;&#x2F; 按键扫描(单位：ms)
#define KEY_TASK_TIME 10
&#x2F;&#x2F; LED间隔闪烁(单位：ms)
#define LED_TASK_TIME 300
&#x2F;&#x2F; 喂狗间隔(单位: ms)MX设置是6s
#define IWDG_TIME   5800
&#x2F;&#x2F; 打印测试
#define MY_ALL_LOG_1    0
&#x2F;&#x2F; 打印测试
#define MENU_LOG_1    0

typedef struct
&#123;
    void (*vHardware_Init)(void);
    uint8_t (*vPassword_Contrast)(uint8_t *, uint8_t *);
    void (*vTime_Out_Init)(void);
&#125; MyAll_TypeDef;

extern MyAll_TypeDef MyAll_Data;

void vHardware_Init(void);
uint8_t vPassword_Contrast(uint8_t *Old_str, uint8_t *New_str);
void vTime_Out_Init(void);
#endif
</code></pre>
              </div>
            </details>
<details ><summary> MyAll.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
 *@Description: 通用
 *@Author: Yang
 *@Date: 2023-04-21 16:22:56
 *&#x2F;
#include &quot;MyAll.h&quot;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
MyAll_TypeDef MyAll_Data &#x3D;
&#123;
    .vHardware_Init &#x3D; &amp;vHardware_Init,
    .vPassword_Contrast &#x3D; &amp;vPassword_Contrast,
    .vTime_Out_Init &#x3D; &amp;vTime_Out_Init
&#125;;

&#x2F;&#x2F; RTC时间结构体
RTC_TimeTypeDef rtc_Time &#x3D; &#123;0&#125;;
&#x2F;&#x2F; RTC日期结构体
RTC_DateTypeDef rtc_Date &#x3D; &#123;0&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*
 * @description: 外设初始化
 * @return: 无
 * @Date: 2023-04-21 17:03:30
 *&#x2F;
&#x2F;&#x2F; 外设初始化
void vHardware_Init(void)
&#123;
    printf(&quot;KEY1:模拟按键1\r\n&quot;);
    printf(&quot;KEY2:模拟按键2\r\n&quot;);
    printf(&quot;KEY3:模拟按键3\r\n&quot;);
    printf(&quot;KEY2_L:模拟按键2长按\r\n&quot;);
    printf(&quot;ROOT:管理员身份\r\n&quot;);
    TIM3-&gt;CNT &#x3D; 0;
    HAL_TIM_Base_Stop_IT(&amp;htim3);
    HAL_UART_Receive_IT(&amp;huart3, (uint8_t *)&amp;MyUSART3_Data.Usart3_New_Data, 1);
    Oled_Data.vOled_Init();
    Oled_Data.vOled_Toggle_Display(OLED_SET);
    Oled_Data.vOled_Rotate_Display(OLED_SET);
    AS608_Data.ucAS608_Get_Templete_Number(&amp;AS608_Data.AS608_Fingerprint_Number);  &#x2F;&#x2F; 获取一次指纹数量
    Menu_Data.vMenu_Start_Interface();
    __HAL_RCC_RTC_ENABLE(); &#x2F;&#x2F; 使能RTC
    HAL_TIM_PWM_Start(&amp;htim4, TIM_CHANNEL_3);   &#x2F;&#x2F; 使能PWM通道
    SG90_Data.vSG90_Control_Angle(0); &#x2F;&#x2F;初始化舵机0度
    Clock_Data.vClock_Get_Time_Date(&amp;rtc_Time);    &#x2F;&#x2F;获取时间日期
    ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_RESTORE, ESP8266_RETURN_OK, ESP8266_WAIT_TIME);
&#125;

&#x2F;*
 * @description: 中断服务函数(需要去删除stm32f1xx_it.c里的)
 * @return: 无
 * @Date: 2023-04-22 00:04:33
 *&#x2F;
void SysTick_Handler(void)
&#123;
    &#x2F;&#x2F; LED计数
    static uint16_t Led_Timer_Cnt &#x3D; 0;
    &#x2F;&#x2F; 按键长按计数
    static uint8_t Key_Timer_Cnt &#x3D; 0;
    &#x2F;&#x2F; 按键按下计数
    static uint8_t Key_Down_Cnt &#x3D; 0;
    &#x2F;&#x2F; 蜂鸣器响计数
    static uint8_t Buzzer_Set_Timer_Cnt &#x3D; 0;
    &#x2F;&#x2F; 太空人刷新计数
    static uint8_t Bmp_Space_Person_Cnt &#x3D; 0;
    &#x2F;&#x2F; 时钟计数
    static uint16_t Standby_Cnt &#x3D; 0;
    &#x2F;&#x2F; 看门狗计数
    static uint16_t IWDG_Cnt &#x3D; 0;

    HAL_IncTick();
    Key_Down_Cnt++;
    Led_Timer_Cnt++;
    Key_Timer_Cnt++;
    Bmp_Space_Person_Cnt++;
    Standby_Cnt++;
    IWDG_Cnt++;

    if(IWDG_TIME &#x3D;&#x3D; IWDG_Cnt)
    &#123;
        IWDG_Cnt &#x3D; 0;
        HAL_IWDG_Refresh(&amp;hiwdg);   &#x2F;&#x2F; 喂狗
    &#125;
    if (1000 &#x3D;&#x3D; Standby_Cnt)
    &#123;
        Standby_Cnt &#x3D; 0;
        Clock_Data.vClock_Get_Time_Date(&amp;rtc_Time); &#x2F;&#x2F; 时间赋值
        Menu_Data.Time_Out_Standby_Count++;
        if ((TIME_OUT_MAX_TIME &#x3D;&#x3D; Menu_Data.Time_Out_Standby_Count) &amp;&amp; (1 &#x3D;&#x3D; Menu_Data.Standby_Choose_Flag))
        &#123;
            Menu_Data.Menu_Flag_Buff[5] &#x3D; 1;
            Menu_Data.Menu_State &#x3D; INTERFACE_6;
        &#125;
    &#125;
    if (130 &#x3D;&#x3D; Bmp_Space_Person_Cnt)
    &#123;
        Bmp_Space_Person_Cnt &#x3D; 0;
        Menu_Data.Bmp_Space_Person_Flag &#x3D; 1;
    &#125;
    if (Buzzer_Data.Buzzer_Open_Flag)
    &#123;
        Buzzer_Data.vBuzzer_Control(BUZZER_ON);
        Buzzer_Set_Timer_Cnt++;
        if (BUZZER_TIME &#x3D;&#x3D; Buzzer_Set_Timer_Cnt)
        &#123;
            Buzzer_Set_Timer_Cnt &#x3D; 0;
            Buzzer_Data.vBuzzer_Control(BUZZER_OFF);
            Buzzer_Data.Buzzer_Open_Flag &#x3D; 0;
        &#125;
    &#125;
    if (100 &#x3D;&#x3D; Key_Down_Cnt)
    &#123;
        Key_Down_Cnt &#x3D; 0;
        Key_Data.Key_Down_Time++;
    &#125;
    if (LED_TASK_TIME &#x3D;&#x3D; Led_Timer_Cnt)
    &#123;
        Led_Timer_Cnt &#x3D; 0;
        Led_Data.vLed_Flashing();
    &#125;
    if (KEY_TASK_TIME &#x3D;&#x3D; Key_Timer_Cnt)
    &#123;
        Key_Timer_Cnt &#x3D; 0;
        Key_Data.vKey_Scan_Function();
        if (SET &#x3D;&#x3D; HAL_GPIO_ReadPin(GPIOA, AS608_WAK_PIN))
        &#123;
            if (SET &#x3D;&#x3D; HAL_GPIO_ReadPin(GPIOA, AS608_WAK_PIN))
            &#123;
                AS608_Data.AS608_Wak_Flag &#x3D; 1;
            &#125;
        &#125;
    &#125;
&#125;

&#x2F;*
 * @description: 定时器中断回调函数
 * @param &#123;TIM_HandleTypeDef&#125; *htim
 * @return &#123;*&#125;
 * @Date: 2023-04-24 02:01:50
 *&#x2F;
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
&#123;
    if(&amp;htim3 &#x3D;&#x3D; htim)
    &#123;
        MyUSART3_Data.Usart3_Rx_Sta |&#x3D; 1 &lt;&lt; 15;
        HAL_TIM_Base_Stop_IT(&amp;htim3);
    &#125;
&#125;

&#x2F;*
 * @description: 管理员密码对比
 * @param &#123;uint8_t&#125; Old_str 旧
 * @param &#123;uint8_t&#125; New_str 输入的
 * @return: 正确---PASSWORD_TRUE  错误---PASSWORD_FALSE
 * @Date: 2023-04-24 02:06:19
 *&#x2F;
&#x2F;&#x2F; 管理员密码对比
uint8_t vPassword_Contrast(uint8_t *Old_str, uint8_t *New_str)
&#123;
    uint8_t result &#x3D; PASSWORD_TRUE;
    for (uint8_t i &#x3D; 0; i &lt; 3; i++)
    &#123;
        if (Old_str[i] !&#x3D; New_str[i])
        &#123;
            result &#x3D; PASSWORD_FALSE;
        &#125;
    &#125;
#if MY_ALL_LOG_1
    printf(&quot;Password:%d\r\n&quot;, result);
#endif
    return result;
&#125;

&#x2F;*
 * @description: 超时等待时间清0
 * @return &#123;*&#125;
 * @Date: 2023-04-25 05:46:55
 *&#x2F;
&#x2F;&#x2F; 超时等待时间清0
void vTime_Out_Init(void)
&#123;
    Menu_Data.Time_Out_Standby_Count &#x3D; 0;
&#125;</code></pre>
              </div>
            </details>
<h3 id="串口">串口</h3>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> MyUSART1.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 串口
*@Author: Yang
*@Date: 2023-04-21 19:02:50
*&#x2F;
#ifndef __MYUSART1_H
#define __MYUSART1_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; USART1接收的最大长度数据
#define USART1_MAX_LEN 50

typedef struct
&#123;
    &#x2F;&#x2F; USART1接收数组
    uint8_t Usart1_Rx_Buff[USART1_MAX_LEN];
    &#x2F;&#x2F; USART1接收长度
    uint8_t Usart1_Rx_Len;
    &#x2F;&#x2F; USART1接收完成标志位
    bool Usart1_Rx_Over_Flag;
    void (*vUsart1_Rx_Data_Analytic)(void);
&#125; MyUSART1_TypeDef;

extern MyUSART1_TypeDef MyUSART1_Data;

void vUsart1_Rx_Data_Analytic(void);
#endif
</code></pre>
              </div>
            </details>
<details ><summary> MyUSART1.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
 *@Description: 串口1--9600bound  串口3--57600bound
 *@Author: Yang
 *@Date: 2023-04-21 19:02:39
 *&#x2F;
#include &quot;MyUSART1.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
MyUSART1_TypeDef MyUSART1_Data &#x3D;
&#123;
    .Usart1_Rx_Buff &#x3D; &#123;0&#125;,
    .Usart1_Rx_Len &#x3D; 0,
    .Usart1_Rx_Over_Flag &#x3D; 0,
    .vUsart1_Rx_Data_Analytic &#x3D; &amp;vUsart1_Rx_Data_Analytic
&#125;;

extern DMA_HandleTypeDef hdma_usart1_rx;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*
 * @description: USART1数据解析
 * @return: 无
 * @Date: 2023-04-22 00:45:56
 *&#x2F;
&#x2F;&#x2F; USART1数据解析
void vUsart1_Rx_Data_Analytic(void)
&#123;
    if (MyUSART1_Data.Usart1_Rx_Over_Flag)
    &#123;
        MyUSART1_Data.Usart1_Rx_Over_Flag &#x3D; 0;
        if ((MyUSART1_Data.Usart1_Rx_Len &gt; 1) &amp;&amp; Menu_Data.Menu_Usart1_State)   &#x2F;&#x2F; 需要打开通信
        &#123;
            &#x2F;&#x2F; 比较
            if(0 &#x3D;&#x3D; strncmp(MyUSART1_Data.Usart1_Rx_Buff, &quot;KEY1&quot;, 4))
            &#123;
                Key_Data.Key_Down_Buff[0] &#x3D; 1;
            &#125;
            &#x2F;&#x2F; 比较
            else if(0 &#x3D;&#x3D; strncmp(MyUSART1_Data.Usart1_Rx_Buff, &quot;KEY2&quot;, 4))
            &#123;
                if(4 &#x3D;&#x3D; MyUSART1_Data.Usart1_Rx_Len)
                &#123;
                    Key_Data.Key_Down_Buff[1] &#x3D; 1;
                &#125;
            &#125;
            &#x2F;&#x2F; 比较
            else if(0 &#x3D;&#x3D; strncmp(MyUSART1_Data.Usart1_Rx_Buff, &quot;KEY3&quot;, 4))
            &#123;
                Key_Data.Key_Down_Buff[2] &#x3D; 1;
            &#125;
            &#x2F;&#x2F; 比较
            else if(0 &#x3D;&#x3D; strncmp(MyUSART1_Data.Usart1_Rx_Buff, &quot;KEY2_L&quot;, 6))
            &#123;
                if(6 &#x3D;&#x3D; MyUSART1_Data.Usart1_Rx_Len)
                &#123;
                    Key_Data.Key_Down_Buff[4] &#x3D; 1;
                &#125;
            &#125;
            &#x2F;&#x2F; 比较
            else if(0 &#x3D;&#x3D; strncmp(MyUSART1_Data.Usart1_Rx_Buff, &quot;ROOT&quot;, 4))
            &#123;
                if(4 &#x3D;&#x3D; MyUSART1_Data.Usart1_Rx_Len)
                &#123;
                    Admin_Data.Administrator_Flag &#x3D; 1;
                &#125;
            &#125;
            MyAll_Data.vTime_Out_Init();    &#x2F;&#x2F;超时等待清0
        &#125;
        HAL_UART_Transmit(&amp;huart1, (uint8_t *)MyUSART1_Data.Usart1_Rx_Buff, strlen(MyUSART1_Data.Usart1_Rx_Buff), 0xffff);
        memset(MyUSART1_Data.Usart1_Rx_Buff, 0, sizeof(MyUSART1_Data.Usart1_Rx_Buff));
        &#x2F;&#x2F; 重新打开DMA接收
        HAL_UART_Receive_DMA(&amp;huart1, (uint8_t *)MyUSART1_Data.Usart1_Rx_Buff, USART1_MAX_LEN);
    &#125;
&#125;

&#x2F;*
 * @description: USART1中断函数(需要在stm32f1xx_it.c删除)
 * @return: 无
 * @Date: 2023-04-22 00:33:28
 *&#x2F;
void USART1_IRQHandler(void)
&#123;
    HAL_UART_IRQHandler(&amp;huart1);
    &#x2F;&#x2F; 触发空闲中断
    if(SET &#x3D;&#x3D; __HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_IDLE))
    &#123;
        &#x2F;&#x2F; 清除空闲中断标志位
        __HAL_UART_CLEAR_IDLEFLAG(&amp;huart1);
        &#x2F;&#x2F; 停止DMA接收
        HAL_UART_DMAStop(&amp;huart1);
        &#x2F;&#x2F; 计算长度
        MyUSART1_Data.Usart1_Rx_Len &#x3D; USART1_MAX_LEN - __HAL_DMA_GET_COUNTER(&amp;hdma_usart1_rx);
        &#x2F;&#x2F; 接收标志位置1
        MyUSART1_Data.Usart1_Rx_Over_Flag &#x3D; 1;
    &#125;
&#125;

&#x2F;*
 * @description: 重定向printf
 * @param &#123;int&#125; ch
 * @param &#123;FILE&#125; *f
 * @return: int
 * @Date: 2023-04-22 03:01:47
 *&#x2F;
int fputc(int ch, FILE *f)
&#123;
    uint32_t temp &#x3D; ch;
    HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;temp, 1, 1000);
    return ch;
&#125;</code></pre>
              </div>
            </details>
<details ><summary> MyUSART3.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifndef __MYUSART3_H
#define __MYUSART3_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; USART3接收的最大长度数据
#define USART3_MAX_LEN 50

typedef struct
&#123;
    uint16_t Usart3_Rx_Sta;
    &#x2F;&#x2F; USART3接收数组
    uint8_t Usart3_Rx_Buff[USART3_MAX_LEN];
    &#x2F;&#x2F; USART3接收长度
    uint8_t Usart3_Rx_Len;
    &#x2F;&#x2F; USART3接收完成标志位
    bool Usart3_Rx_Over_Flag;
    &#x2F;&#x2F; 接收的最新数据
    uint8_t Usart3_New_Data;
&#125; MyUSART3_TypeDef;

extern MyUSART3_TypeDef MyUSART3_Data;

#endif
</code></pre>
              </div>
            </details>
<details ><summary> MyUSART3.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 串口3
*@Author: Yang
*@Date: 2023-04-22 13:17:59
*&#x2F;
#include &quot;MyUSART3.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
MyUSART3_TypeDef MyUSART3_Data &#x3D;
&#123;
    .Usart3_Rx_Sta &#x3D; 0,
    .Usart3_Rx_Buff &#x3D; &#123;0&#125;,
    .Usart3_Rx_Len &#x3D; 0,
    .Usart3_Rx_Over_Flag &#x3D; 0,
    .Usart3_New_Data &#x3D; 0
&#125;;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
&#123;
    if(&amp;huart3 &#x3D;&#x3D; huart)
    &#123;
        &#x2F;&#x2F; 接收完的一批数据,还没有被处理,则不再接收其他数据
        if(0 &#x3D;&#x3D; (MyUSART3_Data.Usart3_Rx_Sta &amp; (1 &lt;&lt; 15)))
        &#123;
            if(MyUSART3_Data.Usart3_Rx_Sta &lt; USART3_MAX_LEN)	&#x2F;&#x2F;还可以接收数据
            &#123;
                TIM3-&gt;CNT &#x3D; 0;&#x2F;&#x2F;计数器清空
                if(0 &#x3D;&#x3D; MyUSART3_Data.Usart3_Rx_Sta) 				&#x2F;&#x2F;使能定时器7的中断
                &#123;
                    HAL_TIM_Base_Start_IT(&amp;htim3);
                &#125;
                MyUSART3_Data.Usart3_Rx_Buff[MyUSART3_Data.Usart3_Rx_Sta++] &#x3D; MyUSART3_Data.Usart3_New_Data;	&#x2F;&#x2F;记录接收到的值
            &#125;
            else
            &#123;
                MyUSART3_Data.Usart3_New_Data |&#x3D; 1 &lt;&lt; 15;				&#x2F;&#x2F;强制标记接收完成
            &#125;
        &#125;
        HAL_UART_Receive_IT(&amp;huart3, (uint8_t *)&amp;MyUSART3_Data.Usart3_New_Data, 1); &#x2F;&#x2F; 串口3接收中断
    &#125;
&#125;</code></pre>
              </div>
            </details>
<details ><summary> MyUSART2.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 串口2
*@Author: Yang
*@Date: 2023-04-29 07:33:42
*&#x2F;
#ifndef __MYUSART2_H
#define __MYUSART2_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; USART2接收的最大长度数据
#define USART2_MAX_LEN 100

typedef struct
&#123;
    &#x2F;&#x2F; 接收app发送过来的有效命令标志位
    bool APP_Rx_Flag;
    &#x2F;&#x2F; USART2接收数组
    uint8_t Usart2_Rx_Buff[USART2_MAX_LEN];
    &#x2F;&#x2F; USART2接收长度
    uint8_t Usart2_Rx_Len;
    &#x2F;&#x2F; USART2接收完成标志位
    bool Usart2_Rx_Over_Flag;
    void (*vUsart2_Rx_Data_Analytic)(void);
    void (*WIFI_printf)(char *, ...);
    void (*WIFI_TCP_Send)(char *, ...);
&#125; MyUSART2_TypeDef;

extern MyUSART2_TypeDef MyUSART2_Data;
extern uint16_t Client_Id;

void vUsart2_Rx_Data_Analytic(void);
void WIFI_printf (char *fmt, ...);
void WIFI_TCP_Send(char *fmt, ...);
#endif</code></pre>
              </div>
            </details>
<details ><summary> MyUSART2.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description: 串口2
*@Author: Yang
*@Date: 2023-04-29 07:33:32
*&#x2F;
#include &quot;MyUSART2.h&quot;


&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
MyUSART2_TypeDef MyUSART2_Data &#x3D;
&#123;
    .APP_Rx_Flag &#x3D; 0,
    .Usart2_Rx_Buff &#x3D; &#123;0&#125;,
    .Usart2_Rx_Len &#x3D; 0,
    .Usart2_Rx_Over_Flag &#x3D; 0,
    .vUsart2_Rx_Data_Analytic &#x3D; &amp;vUsart2_Rx_Data_Analytic,
    .WIFI_printf &#x3D; &amp;WIFI_printf,
    .WIFI_TCP_Send &#x3D; &amp;WIFI_TCP_Send
&#125;;
extern DMA_HandleTypeDef hdma_usart2_rx;
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

uint16_t Client_Id &#x3D; 0;


&#x2F;*
 * @description: USART2数据解析 【接收格式：0x0D0x0A+IPD,&lt;link ID&gt;,&lt;len&gt;:后面是数据内容】数据格式：0x55 0xXX 0xXX 0xXX 0xBB
 * @return: 无
 * @Date: 2023-04-22 00:45:56
 *&#x2F;
&#x2F;*
帧头--0x55 帧尾--0xBB
-----------------------------------------------------------
| 主指令 | 副指令[1] | 副指令[2] |   说明        |
|-----------|--------------|--------------|-----------------|
| 0x01    |	 0x01	  |   0x00    |打开舵机
|------------|-------------|--------------|-----------------|
|            |	       	   |              |
|------------|-------------|--------------|-----------------|
*&#x2F;
&#x2F;&#x2F; USART2数据解析(只在待机和主页面才执行这个函数)
void vUsart2_Rx_Data_Analytic(void)
&#123;
    if (MyUSART2_Data.Usart2_Rx_Over_Flag)
    &#123;
        MyUSART2_Data.Usart2_Rx_Over_Flag &#x3D; 0;
        if((0x0D &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[0]) &amp;&amp;
                (0x0A &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[1]) &amp;&amp;
                (&#39;+&#39; &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[2]) &amp;&amp;
                (&#39;I&#39; &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[3]) &amp;&amp;
                (&#39;P&#39; &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[4]) &amp;&amp;
                (&#39;D&#39; &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[5]))
        &#123;
            if((0x55 &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[11]) &amp;&amp; (0xBB &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[15])) &#x2F;&#x2F; 判断帧头
            &#123;
                Client_Id &#x3D; MyUSART2_Data.Usart2_Rx_Buff[7] - &#39;0&#39;;
                switch(MyUSART2_Data.Usart2_Rx_Buff[12])    &#x2F;&#x2F; 判断主指令
                &#123;
                case 0x01:
                &#123;
                    &#x2F;&#x2F; 控制舵机开
                    if((0x01 &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[13]) &amp;&amp; 0x00 &#x3D;&#x3D; MyUSART2_Data.Usart2_Rx_Buff[14])    &#x2F;&#x2F; 判断副1,2
                    &#123;
                        SG90_Data.vSG90_Mode_switch();
                        Menu_Data.Menu_State &#x3D; INTERFACE_1;
                        Menu_Data.Menu_Flag_Buff[0] &#x3D; 0;
                        WIFI_TCP_Send(&quot;OK\r\n&quot;);
                    &#125;
                    break;
                &#125;
                default:
                    break;
                &#125;
                MyUSART2_Data.APP_Rx_Flag &#x3D; 1;
            &#125;
        &#125;
        MyAll_Data.vTime_Out_Init();    &#x2F;&#x2F;超时等待清0
        memset(MyUSART2_Data.Usart2_Rx_Buff, 0, sizeof(MyUSART2_Data.Usart2_Rx_Buff));
    &#125;
&#125;

void USART2_IRQHandler(void)
&#123;
    HAL_UART_IRQHandler(&amp;huart2);
    &#x2F;&#x2F; 触发空闲中断
    if (SET &#x3D;&#x3D; __HAL_UART_GET_FLAG(&amp;huart2, UART_FLAG_IDLE))
    &#123;
        &#x2F;&#x2F; 清除空闲中断标志位
        __HAL_UART_CLEAR_IDLEFLAG(&amp;huart2);
        &#x2F;&#x2F; 停止DMA接收
        HAL_UART_DMAStop(&amp;huart2);
        &#x2F;&#x2F; 计算长度
        MyUSART2_Data.Usart2_Rx_Len &#x3D; USART2_MAX_LEN - __HAL_DMA_GET_COUNTER(&amp;hdma_usart2_rx);
        &#x2F;&#x2F; 接收标志位置1
        MyUSART2_Data.Usart2_Rx_Over_Flag &#x3D; 1;
    &#125;
    &#x2F;&#x2F; 重新打开DMA接收
    HAL_UART_Receive_DMA(&amp;huart2, (uint8_t *)MyUSART2_Data.Usart2_Rx_Buff, USART2_MAX_LEN);
&#125;

&#x2F;*
 * @description: 发送到串口2函数
 * @param &#123;char&#125; *fmt
 * @return &#123;*&#125;
 * @Date: 2023-04-29 09:02:55
 *&#x2F;
&#x2F;&#x2F; 发送到串口2函数
void WIFI_printf (char *fmt, ...)
&#123;
    char buff[USART2_MAX_LEN + 1]; &#x2F;&#x2F;用于存放转换后的数据 [长度]
    uint16_t i &#x3D; 0;
    __va_list arg_ptr;
    va_start(arg_ptr, fmt);
    vsnprintf(buff, USART2_MAX_LEN + 1, fmt, arg_ptr); &#x2F;&#x2F;数据转换
    i &#x3D; strlen(buff); &#x2F;&#x2F;得出数据长度
    if(strlen(buff) &gt; USART2_MAX_LEN)
    &#123;
        i &#x3D; USART2_MAX_LEN; &#x2F;&#x2F;如果长度大于最大值，则长度等于最大值（多出部分忽略）
    &#125;
    HAL_UART_Transmit(&amp;huart2, (uint8_t *)buff, i, 0xffff); &#x2F;&#x2F;串口发送函数（串口号，内容，数量，溢出时间）
    va_end(arg_ptr);
&#125;

&#x2F;*
 * @description: TCP模式下的数据发送
 * @param &#123;char&#125; *fmt
 * @return &#123;*&#125;
 * @Date: 2023-05-03 15:06:14
 *&#x2F;
&#x2F;&#x2F; TCP模式下的数据发送
void WIFI_TCP_Send(char *fmt, ...)
&#123;
    char buff[USART2_MAX_LEN + 1]; &#x2F;&#x2F;用于存放转换后的数据 [长度]
    uint16_t i &#x3D; 0;
    va_list arg_ptr;
    va_start(arg_ptr, fmt);
    vsnprintf(buff, USART2_MAX_LEN + 1, fmt, arg_ptr); &#x2F;&#x2F;数据转换
    i &#x3D; strlen(buff); &#x2F;&#x2F;得出数据长度
    if(strlen(buff) &gt; USART2_MAX_LEN)
    &#123;
        i &#x3D; USART2_MAX_LEN; &#x2F;&#x2F;如果长度大于最大值，则长度等于最大值（多出部分忽略）
    &#125;
    MyUSART2_Data.WIFI_printf(&quot;AT+CIPSEND&#x3D;%d,%d\r\n&quot;, Client_Id, i); &#x2F;&#x2F;先发送AT指令和数据数量
    HAL_Delay(150);&#x2F;&#x2F;毫秒延时等待WIFI模块返回&quot;&gt;&quot;，此处没做返回是不是&quot;&gt;&quot;的判断。稳定性要求高的项目要另加判断。
    HAL_UART_Transmit(&amp;huart2, (uint8_t *)buff, i, 0xffff); &#x2F;&#x2F;发送数据内容（串口号，内容，数量，溢出时间）
    va_end(arg_ptr);
&#125;</code></pre>
              </div>
            </details>
<h3 id="看门狗">看门狗</h3>
<p>定时6s，然后5.8s在滴答定时器中断里进行喂狗一次</p>
<h3 id="WiFi">WiFi</h3>
<ul>
<li>接线(看模块丝印，正负极不要接反！)，这里只需要接5个脚就够了</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230429111328.webp" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">STM32管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">GND</td>
<td style="text-align:center">GND</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">RX</td>
<td style="text-align:center">USART2_TX</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">TX</td>
<td style="text-align:center">USART2_RX</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">EN</td>
<td style="text-align:center">3.3V</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">VCC</td>
<td style="text-align:center">3.3V</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">GPIO2</td>
<td style="text-align:center">看情况</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">GPIO0</td>
<td style="text-align:center">烧固件需要接地</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">RST</td>
<td style="text-align:center">悬空，烧固件需要快速接地然后悬空，否则一直显示等待上电</td>
</tr>
</tbody>
</table>
<ul>
<li>三种模式</li>
</ul>
<p><code>STA(MODE1)</code>：类似一个接收模式，就是开启该模式后，你只能通过串口给他发送信息，ESP8266只负责接收，而不会产生一个热点(手机或其他设备是找不到热点的)</p>
<blockquote>
<p>这种模式更加适用于需要联网，ESP8266作为一种物联网设备，需要通过Wi-Fi接入互联网，以便与其他设备进行通信、远程监测和控制等操作，可以使用ESP8266的STA模式通过互联网连接到远程服务器，以便实现设备的远程监控和控制</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;tcp服务器
AT+CWMODE&#x3D;1    	                	设置成sta模式	
AT+RST				                重启生效	
AT+CWMODE?			                查询WiFi模块的模式
AT+CWJAP&#x3D;&quot;111&quot;,&quot;12345678&quot;		    连接wifi名字以及密码
AT+CIPMUX&#x3D;1				            设置多连接
AT+CIPSERVER&#x3D;1,8899		            设置端口号
AT+CIFSR	                        查询路由器分配的ip地址
&#x2F;&#x2F; 服务器发送给客户端数据格式是
AT+CIPSEND&#x3D;ID,LEN	&#x2F;&#x2F; ID是客户端的ID因为连接到ESP8266有很多个它不能全部都发送只能发送给指定ID，LEN是发送的数据长度    </code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;tcp客户端
AT+CWMODE&#x3D;2      	                	设置成sta模式	
AT+RST				                	重启生效	
AT+CWMODE?			                	查询WiFi模块的模式
AT+CWJAP&#x3D;&quot;111&quot;,&quot;12345678&quot; 				连接wifi名字以及密码
AT+CIPMUX&#x3D;0				                设置单连接
AT+CIPSTART&#x3D;&quot;TCP&quot;,&quot;10.128.19.xxx&quot;,1121  这个需要根据手机端打开的tcp服务器的ip地址和端口号来修改
AT+CIPMODE&#x3D;1                          	开启透传模式（仅单连接 客服端时支持）
AT+CIPSEND                              开始传送数据</code></pre>
</blockquote>
<p><code>AP(MODE2)</code>：发出去一个热点，供手机或其他设备连接，如果要实现手机连热点来控制单片机，那么该模式就要开启了</p>
<blockquote>
<p>下面两种主要区别是esp8266当做客户端时可以自动发送采集的数据给手机端服务器端，适用于一直采集接收的场景；esp8266当做服务器端时不会主动发送采集的数据给手机客户端，需要手机客户端发送请求命令才能，适用于比如控制模块、设备状态查询等功能</p>
<blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; tcp服务器
AT+CWMODE&#x3D;2      	                设置成ap模式	
AT+RST				                重启生效	
AT+CWMODE?			                查询WiFi模块的模式
AT+CWSAP&#x3D;&quot;ESP8266&quot;,&quot;12345678&quot;,11,0  设置要产生的wifi名字以及密码
AT+CIPMUX&#x3D;1				            设置多接入点模式
AT+CIPSERVER&#x3D;1,8899		            设置端口号
AT+CIFSR	                        查询路由器分配的ip地址</code></pre>
<p>设置完上面后，手机下载WiFi调试助手，选择 <code>TCP客户端</code>，写上WiFI模块的IP地址还有端口号即可连接，然后可以进行发送数据，在程序里串口接收需要判断发送过来的数据，格式为: <code>0x0D0x0A+IPD,&lt;link ID&gt;,&lt;len&gt;:后面是数据内容</code>，其中0x0D0x0A是换行，<link ID> 表示连接标识符，标识着网络连接的唯一性，一个 ESP8266 模块可以同时与多个客户端建立 TCP 或 UDP 连接，每个连接都有一个唯一的标识符，CP 和 UDP 连接的 link ID 编号从 0 开始递增，根据连接建立的顺序，越早建立的连接 link ID 越小；<len>表示数据的长度大小</p>
<p>定好通讯协议，我的通讯协议是：</p>
<p>0x55 0xXX 0xXX 0xXX 0xBB，其中0x55表示帧头，第一个0xXX是主指令，第二个0xXX是副1指令，第三个0xXX是副2指令，0xBB是帧尾，这里我没加校验和因为手机发送的话需要计算校验和比较麻烦</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; tcp客户端
AT+CWMODE&#x3D;2      	                	设置成ap模式	
AT+RST				                	重启生效	
AT+CWMODE?			                	查询WiFi模块的模式
AT+CWSAP&#x3D;&quot;ESP8266&quot;,&quot;12345678&quot;,11,0  	设置要产生的wifi名字以及密码
AT+CIPMUX&#x3D;0				                设置单连接
AT+CIPSTART&#x3D;&quot;TCP&quot;,&quot;10.128.19.xxx&quot;,1121  这个需要根据手机端打开的tcp服务器的ip地址和端口号来修改
AT+CIPMODE&#x3D;1                          	开启透传模式（仅单连接 客服端时支持）
AT+CIPSEND                              开始传送数据</code></pre>
</blockquote>
<p><code>STA+AP(MODE3)</code>：以上两种同时实现</p>
<ul>
<li>传输方式一般选择透传</li>
</ul>
<p>如果不采用透传模式，那么每发送一次数据都要发送一次 <code>AT+CIPSEND=&lt;param&gt;</code>的指令就显得尤为麻烦，因此模式一般设置为透传模式，退出透传模式就给指令 <code>+++</code> 即可</p>
<ul>
<li>一般下ESP8266会生成一个固定的IP地址，根据不同模块地址也不一样(我的是192.168.4.1)，然而如果有其他设备比如手机连接到这个ESP8266则该手机会被分配一个固定IP地址(192.168.4.x)，用于跟ESP8266进行通信的</li>
</ul>
<h4 id="程序编写-2">程序编写</h4>
<details ><summary> ESP8266.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
*@Description:
*@Author: Yang
*@Date: 2023-04-29 07:35:05
*&#x2F;
#ifndef __ESP8266_H
#define __ESP8266_H
#include &quot;MyAll.h&quot;

&#x2F;&#x2F; ESP8266返回值--成功
#define ESP8266_PASS    1
&#x2F;&#x2F; ESP8266返回值--失败
#define ESP8266_FAIL    0
&#x2F;&#x2F; 响应值--OK
#define ESP8266_RETURN_OK   &quot;OK&quot;
&#x2F;&#x2F; 发一条AT普通指令所等待时间，需要*10才是最终所等待的时间ms
#define ESP8266_WAIT_TIME   100
&#x2F;&#x2F; 宏参数转字符串常量
#define TO_STRING(x)    #x

&#x2F;***********用户数据*************&#x2F;
&#x2F;&#x2F; 热点&#x2F;路由器名称(看实际改)
#define SSID    &quot;yang520&quot;
&#x2F;&#x2F; 热点&#x2F;路由器密码(看实际改)
#define SSID_PASSWORD   &quot;00000000&quot;
&#x2F;&#x2F; 云服务器IP地址【必须按您的实际情况修改】
# define TCP_IP &quot;iot-06z00b2xuy7fxl9.mqtt.iothub.aliyuncs.com&quot;
&#x2F;&#x2F; 云服务器端口号
# define TCP_PORT   1883

&#x2F;********常用指令(以下指令都是掉电不保存)********&#x2F;
&#x2F;&#x2F; 查看模块是否在线&#x2F;正常
#define ESP8266_CMD_ONLINE  &quot;AT&quot;
&#x2F;&#x2F; 设置工作模式为STA
#define ESP8266_CMD_MODE_STA &quot;AT+CWMODE&#x3D;1&quot;
&#x2F;&#x2F; 设置工作模式为AP
#define ESP8266_CMD_MODE_AP &quot;AT+CWMODE&#x3D;2&quot;
&#x2F;&#x2F; 设置工作模式为STA+AP
#define ESP8266_CMD_MODE_STAAP &quot;AT+CWMODE&#x3D;3&quot;
&#x2F;&#x2F; 恢复出厂设置(擦除所有Flash参数恢复为默认值，会导致模块重启)
#define ESP8266_CMD_RESTORE &quot;AT+RESTORE&quot;
&#x2F;&#x2F; 模块重启
#define ESP8266_CMD_REBOOT  &quot;AT+RST&quot;
&#x2F;&#x2F; 设置ESP8266的名称，密码，通道号，加密方式(AP模式下此命令才有效)
#define ESP8266_CMD_SETTING &quot;AT+CWSAP&#x3D;\&quot;ESP8266_401\&quot;,\&quot;66666666\&quot;,1,4&quot;
&#x2F;&#x2F; 上电是否自动连接AP(0--不自动 1--自动)
#define ESP8266_CMD_CONNECT_AP(num) &quot;AT+CWAUTOCONN&#x3D;&quot;TO_STRING(num)
&#x2F;&#x2F; 是否开启回显(0--关闭 1--开启)
#define ESP8266_CMD_SWCH_ECHO(num)   &quot;ATE&quot;TO_STRING(num)
&#x2F;&#x2F; 设置DHCP(参1:模式1&#x2F;2&#x2F;3 参2：0-关闭 1-开启)
#define ESP8266_CMD_DHCP    &quot;AT+CWDHCP&#x3D;1,1&quot;
&#x2F;&#x2F; 进入单路&#x2F;多路连接模式(0--单  1--多)
#define ESP8266_CMD_ENTER_MUX(num)  &quot;AT+CIPMUX&#x3D;&quot;TO_STRING(num)
&#x2F;&#x2F; 进入透传模式
#define ESP8266_CMD_MUX_MODE    &quot;AT+CIPMODE&#x3D;1&quot;
&#x2F;&#x2F; 开始传输数据(如果需要发命令需退出透传)
#define ESP8266_CMD_MUX_START   &quot;AT+CIPSEND&quot;
&#x2F;&#x2F; 设置端口号(参1:1-建立服务器 0-关闭服务器 参2:端口号默认333范围是1~65535)
#define ESP8266_CMD_SET_PORT    &quot;AT+CIPSERVER&#x3D;1,8899&quot;
&#x2F;&#x2F; 查询路由分配的IP地址
#define ESP8266_CMD_FIND_IP &quot;AT+CIFSR&quot;


typedef struct
&#123;
    &#x2F;&#x2F; 当前ESP8266属于哪种状态(1--设为服务器端 2--设为客户端 0--无)
    uint8_t ESP8266_State;
    &#x2F;&#x2F; 透传标志位(0--非透传 1--透传)
    bool MUX_Flag;
    &#x2F;&#x2F; ESP连接服务器时IP的最后一位
    uint16_t Server_IP_Number;
    &#x2F;&#x2F; ESP连接服务器时的端口
    uint16_t Server_Port_Number;
    &#x2F;&#x2F; AP模式下端口号
    uint16_t ESP8266_AP_Port;
    uint8_t (*ucESP8266_Send_Cmd)(uint8_t *, uint8_t *, uint16_t);
    uint8_t (*ucESP8266_Check_Cmd)(uint8_t *);
    char *(*cpcESP8266_Success_Message)(uint8_t);
    uint8_t (*ucESP8266_Quit_Mux)(void);
    uint8_t (*ucESP8266_Connect_AP)(void);
    uint8_t (*ucESP8266_Connect_Server)(char *, uint16_t);
    uint8_t (*ucESP8266_Set_Server)(void);
    char *(*pcESP8266_Check_IP)(void);
    uint8_t (*ucESP8266_Set_Client)(void);
&#125; ESP8266_TypeDef;

extern ESP8266_TypeDef ESP8266_Data;

uint8_t ucESP8266_Send_Cmd(uint8_t *cmd, uint8_t *ack, uint16_t wait_time);
uint8_t ucESP8266_Check_Cmd(uint8_t *str);
const char *cpcESP8266_Success_Message(uint8_t ensure);
uint8_t ucESP8266_Quit_Mux(void);
uint8_t ucESP8266_Connect_AP(void);
uint8_t ucESP8266_Connect_Server(char *str, uint16_t _port);
uint8_t ucESP8266_Set_Server(void);
char *pcESP8266_Check_IP(void);
uint8_t ucESP8266_Set_Client(void);
#endif</code></pre>
              </div>
            </details>
<details ><summary> ESP8266.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;ESP8266.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区 BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
ESP8266_TypeDef ESP8266_Data &#x3D;
&#123;
    .ESP8266_State &#x3D; 0,
    .MUX_Flag &#x3D; 0,
    .Server_IP_Number &#x3D; 0,
    .Server_Port_Number &#x3D; 8000,
    .ESP8266_AP_Port &#x3D; 0,
    .ucESP8266_Send_Cmd &#x3D; &amp;ucESP8266_Send_Cmd,
    .ucESP8266_Check_Cmd &#x3D; &amp;ucESP8266_Check_Cmd,
    .cpcESP8266_Success_Message &#x3D; &amp;cpcESP8266_Success_Message,
    .ucESP8266_Quit_Mux &#x3D; &amp;ucESP8266_Quit_Mux,
    .ucESP8266_Connect_AP &#x3D; &amp;ucESP8266_Connect_AP,
    .ucESP8266_Connect_Server &#x3D; &amp;ucESP8266_Connect_Server,
    .ucESP8266_Set_Server &#x3D; &amp;ucESP8266_Set_Server,
    .pcESP8266_Check_IP &#x3D; &amp;pcESP8266_Check_IP,
    .ucESP8266_Set_Client &#x3D; &amp;ucESP8266_Set_Client
&#125;;


&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;变量区    END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

&#x2F;*
 * @description: 设置为客户端
 * @return &#123;*&#125; 设置成功返回0 其余返回表示失败
 * @Date: 2023-05-03 16:16:24
 *&#x2F;
&#x2F;&#x2F; 设置为客户端
uint8_t ucESP8266_Set_Client(void)
&#123;
    uint16_t ip &#x3D; 0;
    uint16_t port &#x3D; 8000;
    uint8_t arr[40] &#x3D; &#123;0&#125;;

    Oled_Data.vOled_Clear();
    Oled_Data.vOled_Display_Gb2312_String(0, 0, (uint8_t *)&quot;正在设置...&quot;);
    ESP8266_Data.ucESP8266_Quit_Mux();
    if(ESP8266_FAIL &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_MODE_AP, ESP8266_RETURN_OK, ESP8266_WAIT_TIME))
    &#123;
        return 3;
    &#125;
    if(ESP8266_FAIL &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_REBOOT, ESP8266_RETURN_OK, ESP8266_WAIT_TIME))
    &#123;
        return 6;
    &#125;
    HAL_Delay(5000);
    if(ESP8266_FAIL &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_ONLINE, ESP8266_RETURN_OK, ESP8266_WAIT_TIME))
    &#123;
        return 1;
    &#125;
    ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_SETTING, ESP8266_RETURN_OK, ESP8266_WAIT_TIME);
    if(ESP8266_FAIL &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_ENTER_MUX(0), ESP8266_RETURN_OK, ESP8266_WAIT_TIME))
    &#123;
        return 11;
    &#125;
    Oled_Data.vOled_Clear();
    Oled_Data.vOled_Display_Gb2312_String(0, 0, (uint8_t *)&quot;TCP服务端IP&quot;);
    Oled_Data.vOled_Display_Gb2312_String(0, 6, (uint8_t *)&quot;返回&quot;);
    Oled_Data.vOled_Display_Gb2312_String(47, 6, (uint8_t *)&quot;增&#x2F;减&quot;);
    Oled_Data.vOled_Display_Gb2312_String(96, 6, (uint8_t *)&quot;确认&quot;);
    while(1)
    &#123;
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            return 16;
        &#125;
        else if(Key_Data.Key_Down_Buff[1])
        &#123;
            Key_Data.Key_Down_Buff[1] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            ip++;
            if(ip &gt;&#x3D; 250)
            &#123;
                ip &#x3D; 250;
            &#125;
        &#125;
        else if(Key_Data.Key_Down_Buff[4])
        &#123;
            Key_Data.Key_Down_Buff[4] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            while(ip !&#x3D; 0)
            &#123;
                ip--;
                break;
            &#125;
        &#125;
        else if(Key_Data.Key_Down_Buff[2])
        &#123;
            Key_Data.Key_Down_Buff[2] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            break;
        &#125;
        snprintf(arr, sizeof(arr), &quot;IP: 192.168.4.%d&quot;, ip);
        Oled_Data.vOled_Display_String_5x7(0, 3, (uint8_t *)arr);
    &#125;
    Oled_Data.vOled_Clear();
    Oled_Data.vOled_Display_Gb2312_String(0, 0, (uint8_t *)&quot;TCP端口输入&quot;);
    Oled_Data.vOled_Display_Gb2312_String(0, 6, (uint8_t *)&quot;返回&quot;);
    Oled_Data.vOled_Display_Gb2312_String(47, 6, (uint8_t *)&quot;增&#x2F;减&quot;);
    Oled_Data.vOled_Display_Gb2312_String(96, 6, (uint8_t *)&quot;确认&quot;);
    while(1)
    &#123;
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            return 16;
        &#125;
        else if(Key_Data.Key_Down_Buff[1])
        &#123;
            Key_Data.Key_Down_Buff[1] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            port++;
            if(port &gt;&#x3D; 9000)
            &#123;
                port &#x3D; 9000;
            &#125;
        &#125;
        else if(Key_Data.Key_Down_Buff[4])
        &#123;
            Key_Data.Key_Down_Buff[4] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            while(port !&#x3D; 8000)
            &#123;
                port--;
                break;
            &#125;
        &#125;
        else if(Key_Data.Key_Down_Buff[2])
        &#123;
            Key_Data.Key_Down_Buff[2] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            break;
        &#125;
        snprintf(arr, sizeof(arr), &quot;端口: %d&quot;, port);
        Oled_Data.vOled_Display_Gb2312_String(0, 3, (uint8_t *)arr);
    &#125;
    ESP8266_Data.Server_IP_Number &#x3D; ip;
    ESP8266_Data.Server_Port_Number &#x3D; port;
    memset(arr, 0, sizeof(arr));
    snprintf(arr, sizeof(arr), &quot;192.168.4.%d&quot;, ESP8266_Data.Server_IP_Number);
    ESP8266_Data.ucESP8266_Connect_Server(arr, ESP8266_Data.Server_Port_Number);
    ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_MUX_MODE, ESP8266_RETURN_OK, ESP8266_WAIT_TIME);
    ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_MUX_START, ESP8266_RETURN_OK, ESP8266_WAIT_TIME);
    ESP8266_Data.MUX_Flag &#x3D; 1;
    return 0;
&#125;

&#x2F;*
 * @description: 查找ESP8266模块的IP
 * @return &#123;*&#125; 返回IP地址
 * @Date: 2023-05-03 13:19:06
 *&#x2F;
&#x2F;&#x2F; 查找ESP8266模块的IP
char *pcESP8266_Check_IP(void)
&#123;
    ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_FIND_IP, &quot;APIP&quot;, 1000);
    char *ptr &#x3D; strstr(MyUSART2_Data.Usart2_Rx_Buff, &quot;APIP&quot;); &#x2F;&#x2F; 查找 &quot;APIP&quot; 子字符串的位置
    if (ptr !&#x3D; NULL)
    &#123;
        char *qtr &#x3D; strchr(ptr, &#39;\&quot;&#39;); &#x2F;&#x2F; 查找第一个双引号位置
        if (qtr !&#x3D; NULL)
        &#123;
            char *rtr &#x3D; strchr(qtr + 1, &#39;\&quot;&#39;); &#x2F;&#x2F; 查找第二个双引号位置
            if (rtr !&#x3D; NULL)
            &#123;
                char *ip &#x3D; (char *) malloc(rtr - qtr); &#x2F;&#x2F; 使用malloc()函数分配空间
                memset(ip, 0, rtr - qtr);           &#x2F;&#x2F; 初始化缓冲区(不要用sizeof不然末尾有一个乱码字符R)
                strncpy(ip, qtr + 1, rtr - qtr - 1); &#x2F;&#x2F; 拷贝 IP 地址到缓冲区
                return ip;
            &#125;
        &#125;
    &#125;
    return NULL;
&#125;

&#x2F;*
 * @description: 设为服务器端
 * @return &#123;*&#125; 返回0表示设置成功 其余失败
 * @Date: 2023-05-02 16:34:54
 *&#x2F;
&#x2F;&#x2F; 设为服务器端
uint8_t ucESP8266_Set_Server(void)
&#123;
    uint8_t arr[30];
    uint16_t Port &#x3D; 8000;   &#x2F;&#x2F; 端口
    char *p &#x3D; (char *)malloc(50);   &#x2F;&#x2F; 分配存储空间的指针

    Oled_Data.vOled_Clear();
    Oled_Data.vOled_Display_Gb2312_String(0, 0, (uint8_t *)&quot;正在设置...&quot;);
    ESP8266_Data.ucESP8266_Quit_Mux();
    if(ESP8266_FAIL &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_MODE_AP, ESP8266_RETURN_OK, ESP8266_WAIT_TIME))
    &#123;
        return 3;
    &#125;
    if(ESP8266_FAIL &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_REBOOT, ESP8266_RETURN_OK, ESP8266_WAIT_TIME))
    &#123;
        return 6;
    &#125;
    HAL_Delay(5000);
    if(ESP8266_FAIL &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_ONLINE, ESP8266_RETURN_OK, ESP8266_WAIT_TIME))
    &#123;
        return 1;
    &#125;
    ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_SETTING, ESP8266_RETURN_OK, ESP8266_WAIT_TIME);
    if(ESP8266_FAIL &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_ENTER_MUX(1), ESP8266_RETURN_OK, ESP8266_WAIT_TIME))
    &#123;
        return 11;
    &#125;
    Oled_Data.vOled_Display_Gb2312_String(0, 6, (uint8_t *)&quot;返回&quot;);
    Oled_Data.vOled_Display_Gb2312_String(47, 6, (uint8_t *)&quot;增&#x2F;减&quot;);
    Oled_Data.vOled_Display_Gb2312_String(96, 6, (uint8_t *)&quot;确认&quot;);
    while(1)
    &#123;
        if (Key_Data.Key_Down_Buff[0])
        &#123;
            Key_Data.Key_Down_Buff[0] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            return 14;
        &#125;
        else if(Key_Data.Key_Down_Buff[1])
        &#123;
            Key_Data.Key_Down_Buff[1] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            Port +&#x3D; 2;
            if(Port &gt;&#x3D; 9000)
            &#123;
                Port &#x3D; 9000;
            &#125;
        &#125;
        else if(Key_Data.Key_Down_Buff[4])
        &#123;
            Key_Data.Key_Down_Buff[4] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            Port -&#x3D; 2;
            if(Port &lt;&#x3D; 8000)
            &#123;
                Port &#x3D; 8000;
            &#125;
        &#125;
        else if(Key_Data.Key_Down_Buff[2])
        &#123;
            Key_Data.Key_Down_Buff[2] &#x3D; 0;
            Buzzer_Data.vBuzzer_Ring(); &#x2F;&#x2F; 蜂鸣器滴一下
            ESP8266_Data.ESP8266_AP_Port &#x3D; Port;
            sprintf((char *)p, &quot;AT+CIPSERVER&#x3D;1,%d&quot;, ESP8266_Data.ESP8266_AP_Port); &#x2F;&#x2F; 发送连接AT指令
            ESP8266_Data.ucESP8266_Send_Cmd(p, ESP8266_RETURN_OK, ESP8266_WAIT_TIME);
            free(p);    &#x2F;&#x2F; 释放分配的空间和指针
            Oled_Data.vOled_Clear();
            Oled_Data.vOled_Display_Gb2312_String(0, 0, (uint8_t *)&quot;正在设置...&quot;);
            break;
        &#125;
        snprintf(arr, sizeof(arr), &quot;选择端口:%d&quot;, Port);
        Oled_Data.vOled_Display_Gb2312_String(0, 2, (uint8_t *)arr);
    &#125;
    return 0;
&#125;

&#x2F;*
 * @description: ESP8266连接到服务器
 * @return &#123;*&#125;
 * @Date: 2023-04-29 15:11:21
 *&#x2F;
&#x2F;&#x2F; ESP8266连接到服务器
uint8_t ucESP8266_Connect_Server(char *str, uint16_t _port)
&#123;
    uint8_t i &#x3D; 10;
    char *p &#x3D; (char *)malloc(50); &#x2F;&#x2F;分配存储空间的指针
    sprintf((char *)p, &quot;AT+CIPSTART&#x3D;\&quot;TCP\&quot;,\&quot;%s\&quot;,%d&quot;, str, _port);
    while(i)
    &#123;
        if(ESP8266_PASS &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(p, &quot;CONNECT&quot;, 1000))
        &#123;
            break;
        &#125;
        i--;
    &#125;
    free(p);    &#x2F;&#x2F; 释放分配的空间和指针
    if(i)
    &#123;
        return ESP8266_PASS;
    &#125;
    else
    &#123;
        return ESP8266_FAIL;
    &#125;
&#125;

&#x2F;*
 * @description: ESP8266连接AP设备（无线路由器）
 * @return &#123;*&#125;
 * @Date: 2023-04-29 14:49:55
 *&#x2F;
&#x2F;&#x2F;ESP8266连接AP设备（无线路由器）
uint8_t ucESP8266_Connect_AP(void)
&#123;
    uint8_t i &#x3D; 10;
    char *p &#x3D; (char *)malloc(50);   &#x2F;&#x2F; 分配存储空间的指针

    sprintf((char *)p, &quot;AT+CWJAP&#x3D;\&quot;%s\&quot;,\&quot;%s\&quot;&quot;, SSID, SSID_PASSWORD); &#x2F;&#x2F; 发送连接AT指令
    while(i)   &#x2F;&#x2F; 循环判断等待连接AP的结果
    &#123;
        if(ESP8266_PASS &#x3D;&#x3D; ESP8266_Data.ucESP8266_Send_Cmd(p, &quot;WIFI GOT IP&quot;, 1000))
        &#123;
            break;
        &#125;
        i--;
    &#125;
    free(p);    &#x2F;&#x2F; 释放分配的空间和指针
    if(i)
    &#123;
        return ESP8266_PASS;
    &#125;
    else
    &#123;
        return ESP8266_FAIL;
    &#125;
&#125;

&#x2F;*
 * @description: 退出透传模式
 * @return &#123;*&#125;
 * @Date: 2023-04-29 14:31:09
 *&#x2F;
&#x2F;&#x2F; 退出透传模式
uint8_t ucESP8266_Quit_Mux(void)
&#123;
    uint8_t result;

    MyUSART2_Data.WIFI_printf(&quot;+++&quot;);
    HAL_Delay(1000);
    MyUSART2_Data.WIFI_printf(&quot;+++&quot;);
    HAL_Delay(1000);
    ESP8266_Data.MUX_Flag &#x3D; 0;
    result &#x3D; ESP8266_Data.ucESP8266_Send_Cmd(ESP8266_CMD_ONLINE, ESP8266_RETURN_OK, ESP8266_WAIT_TIME);
    return result;
&#125;

&#x2F;*
 * @description: 向ESP8266发送指令
 * @param &#123;uint8_t&#125; *cmd 指令字串符
 * @param &#123;uint8_t&#125; *ack 响应字串符
 * @param &#123;uint16_t&#125; wait_time 超时等待
 * @return &#123;*&#125; ESP8266_FAIL--失败  ESP8266_PASS--成功
 * @Date: 2023-04-29 11:42:56
 *&#x2F;
&#x2F;&#x2F; 向ESP8266发送指令
uint8_t ucESP8266_Send_Cmd(uint8_t *cmd, uint8_t *ack, uint16_t wait_time)
&#123;
    uint8_t res &#x3D; ESP8266_PASS;

    MyUSART2_Data.Usart2_Rx_Over_Flag &#x3D; 0;  &#x2F;&#x2F; 接收标志位清0
    memset(MyUSART2_Data.Usart2_Rx_Buff, 0, sizeof(MyUSART2_Data.Usart2_Rx_Buff));  &#x2F;&#x2F; 接收数组清0
    MyUSART2_Data.WIFI_printf(&quot;%s\r\n&quot;, cmd);   &#x2F;&#x2F; 发送指令
    if (ack &amp;&amp; wait_time)   &#x2F;&#x2F; 响应值不为NULL且超时时间不为0则进入if
    &#123;
        while (--wait_time)
        &#123;
            HAL_Delay(10);  &#x2F;&#x2F; 延时
            if (MyUSART2_Data.Usart2_Rx_Over_Flag)  &#x2F;&#x2F; 判断接收标志位是否置1
            &#123;
                if (ESP8266_Data.ucESP8266_Check_Cmd(ack))  &#x2F;&#x2F; 检查ESP8266回传的响应值是否跟ack一致
                &#123;
                    res &#x3D; ESP8266_PASS;
                &#125;
                else
                &#123;
                    res &#x3D; ESP8266_FAIL;
                &#125;
                MyUSART2_Data.Usart2_Rx_Over_Flag &#x3D; 0;
                return res;
            &#125;
        &#125;
        if (0 &#x3D;&#x3D; wait_time)
        &#123;
            res &#x3D; ESP8266_FAIL;
        &#125;
    &#125;
    return res;
&#125;

&#x2F;*
 * @description: ESP8266检查指令
 * @param &#123;uint8_t&#125; *str    需要查找的字符串
 * @return &#123;*&#125; ESP8266_FAIL--失败  ESP8266_PASS--成功
 * @Date: 2023-04-29 11:55:25
 *&#x2F;
&#x2F;&#x2F; ESP8266检查指令
uint8_t ucESP8266_Check_Cmd(uint8_t *str)
&#123;
    uint8_t res &#x3D; ESP8266_FAIL;

    if (MyUSART2_Data.Usart2_Rx_Over_Flag)
    &#123;
        if (strstr((const char *)MyUSART2_Data.Usart2_Rx_Buff, (const char *)str))  &#x2F;&#x2F; 查找str在串口接收数组中第一次出现的位置，找到返回对应位置指针，找不到返回NULL
        &#123;
            res &#x3D; ESP8266_PASS;
        &#125;
    &#125;
    return res;
&#125;

&#x2F;*
 * @description: 各种失败信息
 * @param &#123;uint8_t&#125; ensure 错误信息编号
 * @return &#123;*&#125; 失败信息字符串
 * @Date: 2023-04-29 13:53:04
 *&#x2F;
&#x2F;&#x2F; 各种失败信息
const char *cpcESP8266_Success_Message(uint8_t ensure)
&#123;
    const char *p;

    Oled_Data.vOled_Clear();
    switch(ensure)
    &#123;
    case 1:
    &#123;
        p &#x3D; &quot;模块不在线&quot;;
        break;
    &#125;
    case 2:
    &#123;
        p &#x3D; &quot;设置为STA失败&quot;;
        break;
    &#125;
    case 3:
    &#123;
        p &#x3D; &quot;设置为AP失败&quot;;
        break;
    &#125;
    case 4:
    &#123;
        p &#x3D; &quot;设置为STP失败&quot;;
        break;
    &#125;
    case 5:
    &#123;
        p &#x3D; &quot;恢复出厂设置失败&quot;;
        break;
    &#125;
    case 6:
    &#123;
        p &#x3D; &quot;模块重启失败&quot;;
        break;
    &#125;
    case 7:
    &#123;
        p &#x3D; &quot;设置模块参数失败&quot;;
        break;
    &#125;
    case 8:
    &#123;
        p &#x3D; &quot;设置自动连接失败&quot;;
        break;
    &#125;
    case 9:
    &#123;
        p &#x3D; &quot;设置回显失败&quot;;
        break;
    &#125;
    case 10:
    &#123;
        p &#x3D; &quot;设置DHCP失败&quot;;
        break;
    &#125;
    case 11:
    &#123;
        p &#x3D; &quot;进入单多连接失败&quot;;
        break;
    &#125;
    case 12:
    &#123;
        p &#x3D; &quot;进入透传模式失败&quot;;
        break;
    &#125;
    case 13:
    &#123;
        p &#x3D; &quot;开始传输数据失败&quot;;
        break;
    &#125;
    case 14:
    &#123;
        p &#x3D; &quot;设置端口号失败&quot;;
        break;
    &#125;
    case 15:
    &#123;
        p &#x3D; &quot;查询IP地址失败&quot;;
        break;
    &#125;
    case 16:
    &#123;
        p &#x3D; &quot;连接服务器失败&quot;;
        break;
    &#125;
    case 17:
    &#123;
        p &#x3D; &quot;退出透传失败&quot;;
        break;
    &#125;
    case 18:
    &#123;
        p &#x3D; &quot;连接路由失败&quot;;
        break;
    &#125;
    case 19:
    &#123;
        p &#x3D; &quot;开启SNTP失败&quot;;
        break;
    &#125;
    case 20:
    &#123;
        p &#x3D; &quot;配置信息失败&quot;;
        break;
    &#125;
    case 21:
    &#123;
        p &#x3D; &quot;连接URL失败&quot;;
        break;
    &#125;
    case 22:
    &#123;
        p &#x3D; &quot;订阅失败&quot;;
        break;
    &#125;
    case 23:
    &#123;
        p &#x3D; &quot;发布失败&quot;;
        break;
    &#125;
    default:
        break;
    &#125;
    return p;
&#125;</code></pre>
              </div>
            </details>
<h4 id="固件烧录">固件烧录</h4>
<p>以下步骤是在 <code>ESP8266-01S</code> 型号下进行的</p>
<p>WiFi烧固件除了上面所说的引脚要接外还有 <code>GPIO0</code> 引脚需要接地（接地为下载状态；悬空为工作状态）； <code>RST引脚需要悬空</code>，当提示等待上电同步时接地并迅速悬空，复位模块</p>
<ul>
<li>烧录MQTT固件步骤</li>
</ul>
<blockquote>
<ol>
<li>使用USB转串口按上面要求接线好</li>
<li>前往<a href="https://docs.ai-thinker.com/%E5%9B%BA%E4%BB%B6%E6%B1%87%E6%80%BB">安信可官网</a>找到 <code>固件号：1471</code> 下载</li>
<li>打开烧录软件 <code>flash_download_tool_v3.8.5.exe</code> ，点击 <code>ESP8266 DownloadTool</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430144720.webp" alt=""></p>
<ul>
<li>这是一般参数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430144839.webp" alt=""></p>
<ol start="4">
<li>下载完成测试</li>
</ol>
<p>将ESP8266-01s的引脚IO0拉高（不接GND/置空）</p>
<p>ESP8266-01s模块重新上电，打开串口助手</p>
<p>在串口助手发送AT+GMR指令,输出版本信息则说明下载成功</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430145030.webp" alt=""></p>
</blockquote>
<h4 id="串口助手连接MQTT">串口助手连接MQTT</h4>
<p>下面是使用串口来进行MQTT的连接测试</p>
<ul>
<li>创建产品那些就不写了普通步骤，创建完后点击添加自定义功能设置一下参数，添加一个功能属性，设置完成之后点击发布上线。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430161029.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430160955.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430161248.webp" alt=""></p>
<ul>
<li>开始在串口助手那输入命令进行连接(前提是ESP8266已经烧了MQTT固件)</li>
</ul>
<ol>
<li>复位</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+RST</code></pre>
<ol start="2">
<li>恢复出厂设置(这个不会把你烧的固件也恢复到出厂的放心…)</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+RESTORE</code></pre>
<ol start="3">
<li>配置为STA模式</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+CWMODE&#x3D;1</code></pre>
<ol start="4">
<li>开启SNTP服务器，8时域，SNTP服务器为阿里云域名(这样ESP8266 就可以通过 <a href="http://ntp1.aliyun.com/">ntp1.aliyun.com</a> 获取准确的网络时间，在进行短信发送、数据上传等操作时能够更加精确地记录时间戳)</li>
</ol>
<p><code>CIPSNTPCFG：设置 SNTP（简单网络时间协议）配置参数</code></p>
<p><code>1：SNTP 服务器数量，这里设置为 1</code></p>
<p><code>8：时区偏移量，这里设置为 GMT+8（东八区）</code></p>
<p><code>&quot;ntp1.aliyun.com&quot;：SNTP 服务器地址，这里设置为阿里云提供的ntp1.aliyun.com，如果使用别的物联网平台需要看它的这个地址是哪个</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+CIPSNTPCFG&#x3D;1,8,&quot;ntp1.aliyun.com&quot;</code></pre>
<ol start="5">
<li>连接手机热点或者其他路由</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+CWJAP&#x3D;&quot;yang520&quot;,&quot;00000000&quot;</code></pre>
<ol start="6">
<li>配置 MQTT 用户属性</li>
</ol>
<blockquote>
<p>username和password可以在 <code>设备</code> – <code>设备信息</code> – <code>MQTT连接参数</code> 那查看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430162210.webp" alt=""></p>
</blockquote>
<p><code>MQTTUSERCFG</code>：设置 MQTT 用户名和密码</p>
<p><code>0</code>：MQTT 客户端编号</p>
<p><code>1</code>: MQTT 服务器的 SECUREMODE，这里设置为 1，即使用 SSL 安全连接</p>
<p><code>&quot;NULL&quot;</code>: MQTT 服务器的 CA 证书地址，这里设置为 NULL，表示不需要 CA 证书验证</p>
<p><code>&quot;username&quot;</code>：MQTT 服务器的用户名</p>
<p><code>&quot;passwd&quot;：MQTT 服务器的密码</code></p>
<p><code>0：MQTT 连接的会话类型，这里设置为 0，即非持久化会话</code></p>
<p><code>0：MQTT 连接的 KEEPALIVE 参数，这里设置为 0，表示不启用 KEEPALIVE</code></p>
<p><code>&quot;&quot;：MQTT 连接的遗嘱主题，这里设置为 &quot;&quot;，表示不需要遗嘱功能</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+MQTTUSERCFG&#x3D;0,1,&quot;NULL&quot;,&quot;username&quot;,&quot;passwd&quot;,0,0,&quot;&quot;

# 示例
AT+MQTTUSERCFG&#x3D;0,1,&quot;NULL&quot;,&quot;ESP8266&amp;ikjy4ej7BOp&quot;,&quot;67078699f9d2d3d42be9fe3e141b1cd752c46d226cf4d5c88275c1a260815136&quot;,0,0,&quot;&quot;</code></pre>
<ol start="7">
<li>配置 MQTT 客户端 ID</li>
</ol>
<blockquote>
<p>clientId可以在 <code>设备</code> – <code>设备信息</code> – <code>MQTT连接参数</code> 那查看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430163520.webp" alt=""></p>
<p><code>注意</code>：第二个参数中有逗号的需在逗号前添加 \</p>
</blockquote>
<p><code>MQTTCLIENTID：设置 MQTT 客户端 ID</code></p>
<p><code>0：MQTT 客户端编号</code></p>
<p><code>&quot;clientId&quot;：MQTT 客户</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+MQTTCLIENTID&#x3D;0,&quot;clientId&quot;

# 示例
AT+MQTTCLIENTID&#x3D;0,&quot;ikjy4ej7BOp.ESP8266|securemode&#x3D;2\,signmethod&#x3D;hmacsha256\,timestamp&#x3D;1682842914176|&quot;</code></pre>
<ol start="8">
<li>连接/查询 MQTT Broker</li>
</ol>
<blockquote>
<p>mqttHostUrl和port可以在 <code>设备</code> – <code>设备信息</code> – <code>MQTT连接参数</code> 那查看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430163912.webp" alt=""></p>
</blockquote>
<p><code>MQTTCONN：建立 MQTT 连接</code></p>
<p><code>0：MQTT 客户端编号</code></p>
<p><code>&quot;mqttHostUrl&quot;：MQTT 服务器的 URL 地址</code></p>
<p><code>port：MQTT 服务器的端口号，通常为 1883</code></p>
<p><code>1：MQTT 连接的 CLEAN SESSION 参数，这里设置为 1，即每次连接时清除会话信息</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+MQTTCONN&#x3D;0,&quot;mqttHostUrl&quot;,port,1

# 示例
AT+MQTTCONN&#x3D;0,&quot;iot-06z00b2xuy7fxl9.mqtt.iothub.aliyuncs.com&quot;,1883,1</code></pre>
<ol start="9">
<li>订阅指令</li>
</ol>
<blockquote>
<p><code>$&#123;deviceName&#125;</code> 需要替换你的设备名称</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430164622.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430164432.webp" alt=""></p>
</blockquote>
<p><code>MQTTSUB：订阅 MQTT 主题</code></p>
<p><code>0：MQTT 客户端编号</code></p>
<p><code>&quot;topic&quot;：要订阅的 MQTT 主题</code></p>
<p><code>1：MQTT 订阅的 QoS 等级，可以为 0、1 或 2</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+MQTTSUB&#x3D;0,&quot;topic&quot;,1

# 示例
AT+MQTTSUB&#x3D;0,&quot;&#x2F;ikjy4ej7BOp&#x2F;ESP8266&#x2F;user&#x2F;get&quot;,1</code></pre>
<ol start="10">
<li>发布指令</li>
</ol>
<blockquote>
<p><code>$&#123;deviceName&#125;</code> 需要替换你的设备名称</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430164622.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230430164444.webp" alt=""></p>
</blockquote>
<p><code>MQTTPUB：发布 MQTT 消息</code></p>
<p><code>0：MQTT 客户端编号</code></p>
<p><code>&quot;topic&quot;：要发布的 MQTT 主题</code></p>
<p><code>&quot;Json格式内容&quot;：要发布的 MQTT 消息内容</code></p>
<p><code>1：MQTT 消息的 QoS 等级，可以为 0、1 或 2</code></p>
<p><code>0：MQTT 消息的 RETAIN 标志，可以为 0 或 1</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+MQTTPUB&#x3D;0,&quot;topic&quot;,&quot;Json格式内容&quot;,1,0

# 示例
AT+MQTTPUB&#x3D;0,&quot;&#x2F;ikjy4ej7BOp&#x2F;ESP8266&#x2F;user&#x2F;update&quot;,&quot;Json格式内容&quot;,1,0</code></pre>
<p>其他指令</p>
<p>断开MQTT连接</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AT+MQTTCLEAN&#x3D;0</code></pre>
<p>其他知识</p>
<p>在 MQTT 协议中，发布消息（Publish）指的是客户端向服务器发送消息，而订阅消息（Subscribe）则是客户端接收服务器发送给它的消息</p>
<p>对于 ESP8266 设备而言，如果您需要将设备采集的数据上传至 MQTT 服务器，就需要通过发布消息的方式将数据发送给服务器。而当服务器需要向 ESP8266 发送特定的控制命令或其他数据时，则需要通过订阅 ESP8266 订阅的主题（Topic），向其发送消息</p>
<h2 id="注意-遇到的问题">注意/遇到的问题</h2>
<div class="note simple"><p>USART1串口接收需要注意卡死问题，<code>__HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_RXNE)</code> 不需要开启，两条就够了，还有发送字符串含中文会乱码的情况，可以去Keil勾选C库那个选项，但是还是有警告不用管因为是V6编译，虽然速度快但是对中文还是不太支持，使用V5的话就没那个警告，然后回到vscode重新打开窗口编译即可，也可以重定向printf来发送</p>
</div>
<div class="note simple"><p>OLED显示中文需要把中文字符串所在的 .c 文件设置为 <code>GB2312</code> 编码，不然显示乱码</p>
</div>
<div class="note simple"><p>使用RTC时，我丢滴答定时器里一直闪烁的LED忽然不会闪了一直亮，我以为是代码哪里不小心注释了，结果看了半天没看到，然后想想可能是RTC的问题，果然在MX配置里PC13引脚是RTC相关引脚，通常用于检测备份电源的状态或检测外部事件，如果想控制PC13的话需要在MX里选择输出为无，这样LED正常闪烁了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230427192954.webp" alt=""></p>
</div>
<div class="note simple"><details ><summary> setting.json </summary>
              <div class='content'>
              <pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &quot;files.associations&quot;: &#123;
        &quot;my.h&quot;: &quot;c&quot;,
        &quot;tim.h&quot;: &quot;c&quot;,
        &quot;as608.h&quot;: &quot;c&quot;,
        &quot;myall.h&quot;: &quot;c&quot;,
        &quot;buzzer.h&quot;: &quot;c&quot;,
        &quot;key.h&quot;: &quot;c&quot;,
        &quot;led.h&quot;: &quot;c&quot;,
        &quot;oled.h&quot;: &quot;c&quot;,
        &quot;usart.h&quot;: &quot;c&quot;,
        &quot;string&quot;: &quot;c&quot;,
        &quot;string_view&quot;: &quot;c&quot;,
        &quot;array&quot;: &quot;c&quot;,
        &quot;myusart3.h&quot;: &quot;c&quot;,
        &quot;sstream&quot;: &quot;c&quot;,
        &quot;menu.h&quot;: &quot;c&quot;,
        &quot;bmp.h&quot;: &quot;c&quot;,
        &quot;functional&quot;: &quot;c&quot;,
        &quot;algorithm&quot;: &quot;c&quot;,
        &quot;clock.h&quot;: &quot;c&quot;
    &#125;,
    &quot;C_Cpp.intelliSenseEngineFallback&quot;: &quot;Disabled&quot;, &#x2F;&#x2F;需要添加的
    &quot;C_Cpp.intelliSenseEngine&quot;: &quot;Tag Parser&quot;,  &#x2F;&#x2F;  需要添加的
&#125;</code></pre>
              </div>
            </details>
<details ><summary> launch.json </summary>
              <div class='content'>
              <pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &quot;name&quot;: &quot;Your Debug Configuration&quot;,
    &quot;type&quot;: &quot;cortex-debug&quot;,
    &quot;request&quot;: &quot;launch&quot;,
    &quot;servertype&quot;: &quot;keil&quot;,
    &quot;preLaunchTask&quot;: &quot;build&quot;,
    &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,
    &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;MDK-ARM&#x2F;Fingerprint_Access_Control&#x2F;Fingerprint_Access_Control.axf&quot;,
    &quot;ignore&quot;: [&quot;WarningNumber1&quot;, &quot;WarningNumber2&quot;,&quot;-Winvalid-source-encoding&quot;]
&#125;
</code></pre>
              </div>
            </details>
</div>
<div class="note simple"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230428141556.webp" alt=""></p>
<p>喂狗需要注意不要太接近重装载值，因为RC温漂大可能会导致复位</p>
</div>
<div class="note simple"><p>如果WIFI设置模式或者发送AT都返回错误，可以试试把WiFi模块的3.3v重新拔了再插回去(不要只按单片机复位，一定要断电WiFI模块)</p>
</div>
<div class="note simple"><p>供电最好使用USB口供电，如果只使用下载程序那供电会出现电压不足，导致OLED有乱码，舵机不会动等问题</p>
</div>
<h2 id="待解决">待解决</h2>
<p>指纹的背光问题还是找不到解决方法，一直亮着太闪眼了，理想是按下才亮，不按下指纹处于灭状态</p>
<p>参考过的文章：<a href="https://www.arduino.cn/forum.php?mod=viewthread&amp;tid=105344&amp;page=1#pid622605">https://www.arduino.cn/forum.php?mod=viewthread&amp;tid=105344&amp;page=1#pid622605</a></p>
<h2 id="结语">结语</h2>
<p>这次搞这个也学到了很多，知道了怎么去烧写wifi固件，只不过遗憾的是搞MQTT连接阿里云那里一直不太行，不知道哪里有问题，这个问题暂时先这样了只能，等后面准备再搞一个物联网的小项目做做</p>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=953231678&bvid=BV1gs4y1374c&cid=1117503640&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/num126.webp" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-number">3.</span> <span class="toc-text">程序框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MX%E9%85%8D%E7%BD%AE"><span class="toc-number">4.</span> <span class="toc-text">MX配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="toc-number">5.</span> <span class="toc-text">程序编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LED"><span class="toc-number">5.1.</span> <span class="toc-text">LED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE"><span class="toc-number">5.2.</span> <span class="toc-text">按键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">蜂鸣器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OLED"><span class="toc-number">5.4.</span> <span class="toc-text">OLED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AS608%E6%8C%87%E7%BA%B9"><span class="toc-number">5.5.</span> <span class="toc-text">AS608指纹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SG90"><span class="toc-number">5.6.</span> <span class="toc-text">SG90</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8"><span class="toc-number">5.7.</span> <span class="toc-text">通用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3"><span class="toc-number">5.8.</span> <span class="toc-text">串口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">5.9.</span> <span class="toc-text">看门狗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WiFi"><span class="toc-number">5.10.</span> <span class="toc-text">WiFi</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99-2"><span class="toc-number">5.10.1.</span> <span class="toc-text">程序编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E4%BB%B6%E7%83%A7%E5%BD%95"><span class="toc-number">5.10.2.</span> <span class="toc-text">固件烧录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%8A%A9%E6%89%8B%E8%BF%9E%E6%8E%A5MQTT"><span class="toc-number">5.10.3.</span> <span class="toc-text">串口助手连接MQTT</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">注意&#x2F;遇到的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%85%E8%A7%A3%E5%86%B3"><span class="toc-number">7.</span> <span class="toc-text">待解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">8.</span> <span class="toc-text">结语</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Luckys-Yang</div><div class="footer_custom_text"><div class="github-badge"><a href="http://beian.miit.gov.cn/" target="_blank" title="粤ICP备 2022026282号-1" ), pointer;"><span class="badge-subject">粤ICP备</span><span class="badge-value bg-green">2022026282号-1</span></a></div><div class="github-badge"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44070502000559" title="44070502000559号"><span class="badge-subject"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bed.attainment.cn/img/40.png" style="float:left;" />粤公网安备</span><span class="badge-value bg-green">44070502000559号</span></a></div><div><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Frame-Hexo-blue.svg" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Theme-Butterfly-6513df.svg" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/Hosted-Vercel-brightgreen.svg" title="本站采用多线部署，次线路托管于Vercel" alt="HEXO"></a></div></div><div id="running-time" style="color: #5c5c5c;"><script>setInterval(()=>{let create_time=Math.round(new Date('3/10/2022 08:00:00').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已苟活了 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><meting-js id="8183137343" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-paw"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="https://yang5201314.cn/"><i class="fa fa-home"></i><span>主页</span></a><a class="rightMenu-item" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a><a class="rightMenu-item" href="/archives/"><i class="fa-solid fa-folder-open"></i><span>文章归档</span></a><a class="rightMenu-item" href="https://www.foreverblog.cn/go.html" target="_blank"><i class="fa fa-certificate"></i><span>虫洞</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script defer src="/js/tw_cn.js"></script><script defer src="https://cdn.staticfile.org/fancyapps-ui/4.0.27/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script defer src="https://jsd.onmicrosoft.cn/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script defer src="https://jsd.onmicrosoft.cn/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia.js"></script><div class="js-pjax"></div><script src="https://jsd.onmicrosoft.cn/npm/prismjs/prism.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async type="text/javascript" src="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/js/iziToast.min.js"></script><script>
    document.body.oncopy = function () {
        iziToast.info({
            timeout: 4000, // 关闭弹窗的时间
          // icon: 'Fontawesome', // 图标类别
            closeOnEscape: 'true', // 允许使用Esc键关闭弹窗
            transitionIn: 'bounceInLeft', // 弹窗打开动画
            transitionOut: 'fadeOutRight', // 弹窗关闭动画
            displayMode: 'replace', // 替换已经打开的弹窗
            layout: '2', // Medium模式
            position: 'topRight', // 弹窗位置
            //icon: 'fad fa-copy', // 图标类名
            iconUrl:'https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/1122star.svg',
            backgroundColor: 'rgb(179, 182, 180)', // 弹窗背景色
            title: '复制成功', // 通知标题
            message: '键盘敲烂 月薪过万' // 通知消息内容
        });
    }
</script>
<script defer type="text/javascript" src="/js/rightmenu.js"></script><script  type="text/javascript" src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script defer type="text/javascript" src="/js/IPdw.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer data-pjax src="/js/newYear.js"></script><script defer src="/js/my_aplayer.js"></script><script defer src="/js/meting.js"></script><script id="click-heart" src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '250ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>