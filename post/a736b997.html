<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>KST-51之课程实训 | Luckys-Yangの小栈</title><meta name="author" content="Luckys-Yang"><meta name="copyright" content="Luckys-Yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="51单片机实训周要求是搞个密码锁，还好不算复杂，但是太久没碰51了有点生疏(一开始模块化得好好地写到一半内存炸了，搞得浪费一天时间)，最后只能赶时间半天时间在例程上修改，整理，虽然没有完全模块化但是也部分模块化，最后测试了功能都是正常的   要求            [{&quot;url&quot;:&quot;https:&#x2F;&#x2F;image-1309791158.cos.ap-guangzhou.myqcloud.com&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="KST-51之课程实训">
<meta property="og:url" content="https://mdcm.yang5201314.cn/post/a736b997.html">
<meta property="og:site_name" content="Luckys-Yangの小栈">
<meta property="og:description" content="51单片机实训周要求是搞个密码锁，还好不算复杂，但是太久没碰51了有点生疏(一开始模块化得好好地写到一半内存炸了，搞得浪费一天时间)，最后只能赶时间半天时间在例程上修改，整理，虽然没有完全模块化但是也部分模块化，最后测试了功能都是正常的   要求            [{&quot;url&quot;:&quot;https:&#x2F;&#x2F;image-1309791158.cos.ap-guangzhou.myqcloud.com&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mdcm.yang5201314.cn/img/num141.webp">
<meta property="article:published_time" content="2023-06-20T15:36:06.000Z">
<meta property="article:modified_time" content="2023-06-20T15:54:48.466Z">
<meta property="article:author" content="Luckys-Yang">
<meta property="article:tag" content="牛逼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mdcm.yang5201314.cn/img/num141.webp"><link rel="shortcut icon" href="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp"><link rel="canonical" href="https://mdcm.yang5201314.cn/post/a736b997.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"MSZRRKNRKT","apiKey":"71e2a5ac35435ee76602cd55d727e5ff","indexName":"aaa","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'KST-51之课程实训',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-06-20 23:54:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/rightmenu.css" media="all" onload="this.media='all'"><link rel="preconnect" href="https://s1.hdslb.com/" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/regular.css" media="all" onload="this.media='all'" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css" media="all" onload="this.media='all'" /><link rel="shortcut icon" href="#"><link href="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/css/all.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/my.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css" ><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/css/iziToast.min.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/aplayer.css" media="all" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><style>css-doodle {--color: @p(#51eaea, #fffde1, #ff9d76, #FB3569);--rule: (:doodle {@grid: 30x1 / 18vmin;--deg: @p(-180deg, 180deg);}:container {perspective: 30vmin;}:after, :before {content: '';background: var(--color); @place-cell: @r(100%) @r(100%); @size: @r(6px); @shape: heart;} @place-cell: center; @size: 100%;box-shadow: @m2(0 0 50px var(--color));background: @m100(radial-gradient(var(--color) 50%, transparent 0)@r(-20%, 120%) @r(-20%, 100%) / 1px 1px no-repeat); will-change: transform, opacity; animation: scale-up 12s linear infinite; animation-delay: calc(-12s / @I * @i); @keyframes scale-up { 0%, 95.01%, 100% {transform: translateZ(0) rotate(0);opacity: 0;}10% {opacity: 1;}95% {transform: translateZ(35vmin) rotateZ(@var(--deg));}})}</style><css-doodle use="var(--rule)"></css-doodle><script async="async" src="https://cdn.bootcdn.net/ajax/libs/css-doodle/0.32.2/css-doodle.min.js"></script></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-list-alt"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/bookmarking/"><i class="fa-fw fas fa-star"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-pen"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info-circle"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav class="fixed" id="nav"><span id="blog-info"><a href="/" title="Luckys-Yangの小栈"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/light.png"/></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-list-alt"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/bookmarking/"><i class="fa-fw fas fa-star"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-pen"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info-circle"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">KST-51之课程实训</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-20T15:36:06.000Z" title="发表于 2023-06-20 23:36:06">2023-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-20T15:54:48.466Z" title="更新于 2023-06-20 23:54:48">2023-06-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/51%E7%B3%BB%E5%88%97/">51系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>51单片机实训周要求是搞个密码锁，还好不算复杂，但是太久没碰51了有点生疏(一开始模块化得好好地写到一半内存炸了，搞得浪费一天时间)，最后只能赶时间半天时间在例程上修改，整理，虽然没有完全模块化但是也部分模块化，最后测试了功能都是正常的</p>
</blockquote>
<ul>
<li>要求</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230620234947.webp","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20230620234837.webp","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<ul>
<li>程序编写</li>
</ul>
<details ><summary> eeprom.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;***************************************************************************
 * File: eeprom.c
 * Author: Luckys.
 * Date: 2023&#x2F;06&#x2F;19
 * description: EEPROM
 ****************************************************************************&#x2F;
#include &lt;reg52.h&gt;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

extern void I2CStart();
extern void I2CStop();
extern unsigned char I2CReadACK();
extern unsigned char I2CReadNAK();
extern bit I2CWrite(unsigned char dat);

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*
* @function: EEPROM_Read
* @param: buf -- 数据接收指针，addr -- E2中的起始地址，len -- 读取长度
* @retval: None
* @brief: 读取函数
*&#x2F;
void EEPROM_Read(unsigned char *buf, unsigned char addr, unsigned char len)
&#123;
    do
    &#123; &#x2F;&#x2F; 用寻址操作查询当前是否可进行读写操作
        I2CStart();
        if (I2CWrite(0x50 &lt;&lt; 1)) &#x2F;&#x2F; 应答则跳出循环，非应答则进行下一次查询
        &#123;
            break;
        &#125;
        I2CStop();
    &#125; while (1);
    I2CWrite(addr);               &#x2F;&#x2F; 写入起始地址
    I2CStart();                   &#x2F;&#x2F; 发送重复启动信号
    I2CWrite((0x50 &lt;&lt; 1) | 0x01); &#x2F;&#x2F; 寻址器件，后续为读操作
    while (len &gt; 1)               &#x2F;&#x2F; 连续读取len-1个字节
    &#123;
        *buf++ &#x3D; I2CReadACK(); &#x2F;&#x2F; 最后字节之前为读取操作+应答
        len--;
    &#125;
    *buf &#x3D; I2CReadNAK(); &#x2F;&#x2F; 最后一个字节为读取操作+非应答
    I2CStop();
&#125;

&#x2F;*
* @function: EEPROM_Write
* @param: buf -- 数据写入指针，addr -- E2中的起始地址，len -- 读取长度
* @retval: None
* @brief: 写入函数
*&#x2F;
void EEPROM_Write(unsigned char *buf, unsigned char addr, unsigned char len)
&#123;
    while (len &gt; 0)
    &#123;
        &#x2F;&#x2F; 等待上次写入操作完成
        do
        &#123; &#x2F;&#x2F; 用寻址操作查询当前是否可进行读写操作
            I2CStart();
            if (I2CWrite(0x50 &lt;&lt; 1)) &#x2F;&#x2F; 应答则跳出循环，非应答则进行下一次查询
            &#123;
                break;
            &#125;
            I2CStop();
        &#125; while (1);
        &#x2F;&#x2F; 按页写模式连续写入字节
        I2CWrite(addr); &#x2F;&#x2F; 写入起始地址
        while (len &gt; 0)
        &#123;
            I2CWrite(*buf++);       &#x2F;&#x2F; 写入一个字节数据
            len--;                  &#x2F;&#x2F; 待写入长度计数递减
            addr++;                 &#x2F;&#x2F; E2地址递增
            if ((addr &amp; 0x07) &#x3D;&#x3D; 0) &#x2F;&#x2F; 检查地址是否到达页边界，24C02每页8字节，
            &#123;                       &#x2F;&#x2F; 所以检测低3位是否为零即可
                break;              &#x2F;&#x2F; 到达页边界时，跳出循环，结束本次写操作
            &#125;
        &#125;
        I2CStop();
    &#125;
&#125;</code></pre>
              </div>
            </details>
<details ><summary> i2c.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;***************************************************************************
 * File: i2c.c
 * Author: Luckys.
 * Date: 2023&#x2F;06&#x2F;19
 * description: 描述
****************************************************************************&#x2F;
#include &lt;reg52.h&gt;
#include &lt;intrins.h&gt;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

#define I2CDelay() \
    &#123;              \
        _nop_();   \
        _nop_();   \
        _nop_();   \
        _nop_();   \
    &#125;
    
sbit I2C_SCL &#x3D; P3 ^ 7;
sbit I2C_SDA &#x3D; P3 ^ 6;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;



&#x2F;* 产生总线起始信号 *&#x2F;
void I2CStart()
&#123;
    I2C_SDA &#x3D; 1; &#x2F;&#x2F; 首先确保SDA、SCL都是高电平
    I2C_SCL &#x3D; 1;
    I2CDelay();
    I2C_SDA &#x3D; 0; &#x2F;&#x2F; 先拉低SDA
    I2CDelay();
    I2C_SCL &#x3D; 0; &#x2F;&#x2F; 再拉低SCL
&#125;
&#x2F;* 产生总线停止信号 *&#x2F;
void I2CStop()
&#123;
    I2C_SCL &#x3D; 0; &#x2F;&#x2F; 首先确保SDA、SCL都是低电平
    I2C_SDA &#x3D; 0;
    I2CDelay();
    I2C_SCL &#x3D; 1; &#x2F;&#x2F; 先拉高SCL
    I2CDelay();
    I2C_SDA &#x3D; 1; &#x2F;&#x2F; 再拉高SDA
    I2CDelay();
&#125;
&#x2F;* I2C总线写操作，dat-待写入字节，返回值-从机应答位的值 *&#x2F;
bit I2CWrite(unsigned char dat)
&#123;
    bit ack;            &#x2F;&#x2F; 用于暂存应答位的值
    unsigned char mask; &#x2F;&#x2F; 用于探测字节内某一位值的掩码变量

    for (mask &#x3D; 0x80; mask !&#x3D; 0; mask &gt;&gt;&#x3D; 1) &#x2F;&#x2F; 从高位到低位依次进行
    &#123;
        if ((mask &amp; dat) &#x3D;&#x3D; 0) &#x2F;&#x2F; 该位的值输出到SDA上
            I2C_SDA &#x3D; 0;
        else
            I2C_SDA &#x3D; 1;
        I2CDelay();
        I2C_SCL &#x3D; 1; &#x2F;&#x2F; 拉高SCL
        I2CDelay();
        I2C_SCL &#x3D; 0; &#x2F;&#x2F; 再拉低SCL，完成一个位周期
    &#125;
    I2C_SDA &#x3D; 1; &#x2F;&#x2F; 8位数据发送完后，主机释放SDA，以检测从机应答
    I2CDelay();
    I2C_SCL &#x3D; 1;   &#x2F;&#x2F; 拉高SCL
    ack &#x3D; I2C_SDA; &#x2F;&#x2F; 读取此时的SDA值，即为从机的应答值
    I2CDelay();
    I2C_SCL &#x3D; 0; &#x2F;&#x2F; 再拉低SCL完成应答位，并保持住总线

    return (~ack); &#x2F;&#x2F; 应答值取反以符合通常的逻辑：
                   &#x2F;&#x2F; 0&#x3D;不存在或忙或写入失败，1&#x3D;存在且空闲或写入成功
&#125;
&#x2F;* I2C总线读操作，并发送非应答信号，返回值-读到的字节 *&#x2F;
unsigned char I2CReadNAK()
&#123;
    unsigned char mask;
    unsigned char dat;

    I2C_SDA &#x3D; 1;                             &#x2F;&#x2F; 首先确保主机释放SDA
    for (mask &#x3D; 0x80; mask !&#x3D; 0; mask &gt;&gt;&#x3D; 1) &#x2F;&#x2F; 从高位到低位依次进行
    &#123;
        I2CDelay();
        I2C_SCL &#x3D; 1;      &#x2F;&#x2F; 拉高SCL
        if (I2C_SDA &#x3D;&#x3D; 0) &#x2F;&#x2F; 读取SDA的值
            dat &amp;&#x3D; ~mask; &#x2F;&#x2F; 为0时，dat中对应位清零
        else
            dat |&#x3D; mask; &#x2F;&#x2F; 为1时，dat中对应位置1
        I2CDelay();
        I2C_SCL &#x3D; 0; &#x2F;&#x2F; 再拉低SCL，以使从机发送出下一位
    &#125;
    I2C_SDA &#x3D; 1; &#x2F;&#x2F; 8位数据发送完后，拉高SDA，发送非应答信号
    I2CDelay();
    I2C_SCL &#x3D; 1; &#x2F;&#x2F; 拉高SCL
    I2CDelay();
    I2C_SCL &#x3D; 0; &#x2F;&#x2F; 再拉低SCL完成非应答位，并保持住总线

    return dat;
&#125;
&#x2F;* I2C总线读操作，并发送应答信号，返回值-读到的字节 *&#x2F;
unsigned char I2CReadACK()
&#123;
    unsigned char mask;
    unsigned char dat;

    I2C_SDA &#x3D; 1;                             &#x2F;&#x2F; 首先确保主机释放SDA
    for (mask &#x3D; 0x80; mask !&#x3D; 0; mask &gt;&gt;&#x3D; 1) &#x2F;&#x2F; 从高位到低位依次进行
    &#123;
        I2CDelay();
        I2C_SCL &#x3D; 1;      &#x2F;&#x2F; 拉高SCL
        if (I2C_SDA &#x3D;&#x3D; 0) &#x2F;&#x2F; 读取SDA的值
            dat &amp;&#x3D; ~mask; &#x2F;&#x2F; 为0时，dat中对应位清零
        else
            dat |&#x3D; mask; &#x2F;&#x2F; 为1时，dat中对应位置1
        I2CDelay();
        I2C_SCL &#x3D; 0; &#x2F;&#x2F; 再拉低SCL，以使从机发送出下一位
    &#125;
    I2C_SDA &#x3D; 0; &#x2F;&#x2F; 8位数据发送完后，拉低SDA，发送应答信号
    I2CDelay();
    I2C_SCL &#x3D; 1; &#x2F;&#x2F; 拉高SCL
    I2CDelay();
    I2C_SCL &#x3D; 0; &#x2F;&#x2F; 再拉低SCL完成应答位，并保持住总线

    return dat;
&#125;</code></pre>
              </div>
            </details>
<details ><summary> infrared.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;main.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
&#x2F;&#x2F; 红外接收缓存数组
uint8_t Infrared_RX_Buff[4] &#x3D; &#123;0&#125;;  
&#x2F;&#x2F; 红外键码到标准PC键码的映射表
const uint8_t code Infrered_CodeMap[][2] &#x3D; &#123;  
    &#123;0x45,0x00&#125;, &#123;0x46,0x00&#125;, &#123;0x47,0x1B&#125;, &#x2F;&#x2F;开关-&gt;无  Mode-&gt;无   静音-&gt;ESC
    &#123;0x44,0x00&#125;, &#123;0x40,0x25&#125;, &#123;0x43,0x27&#125;, &#x2F;&#x2F;播放-&gt;无  后退-&gt;向左 前进-&gt;向右
    &#123;0x07,0x00&#125;, &#123;0x15,0x28&#125;, &#123;0x09,0x26&#125;, &#x2F;&#x2F; EQ-&gt;无   减号-&gt;向下 加号-&gt;向上
    &#123;0x16, &#39;0&#39;&#125;, &#123;0x19,0x1B&#125;, &#123;0x0D,0x0D&#125;, &#x2F;&#x2F;&#39;0&#39;-&gt;&#39;0&#39;  箭头-&gt;ESC  U&#x2F;SD-&gt;回车
    &#123;0x0C, &#39;1&#39;&#125;, &#123;0x18, &#39;2&#39;&#125;, &#123;0x5E, &#39;3&#39;&#125;, &#x2F;&#x2F;&#39;1&#39;-&gt;&#39;1&#39;  &#39;2&#39;-&gt;&#39;2&#39;   &#39;3&#39;-&gt;&#39;3&#39;
    &#123;0x08, &#39;4&#39;&#125;, &#123;0x1C, &#39;5&#39;&#125;, &#123;0x5A, &#39;6&#39;&#125;, &#x2F;&#x2F;&#39;4&#39;-&gt;&#39;4&#39;  &#39;5&#39;-&gt;&#39;5&#39;   &#39;6&#39;-&gt;&#39;6&#39;
    &#123;0x42, &#39;7&#39;&#125;, &#123;0x52, &#39;8&#39;&#125;, &#123;0x4A, &#39;9&#39;&#125;, &#x2F;&#x2F;&#39;7&#39;-&gt;&#39;7&#39;  &#39;6&#39;-&gt;&#39;8&#39;   &#39;9&#39;-&gt;&#39;9&#39;
&#125;;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;static function declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

void Infrared_Init(void);    &#x2F;&#x2F; 红外接收初始化
uint16_t Infrared_Get_High_Time(void);      &#x2F;&#x2F; 获取当前高电平的持续时间
uint16_t Infrared_Get_Low_Time(void);    &#x2F;&#x2F; 获取当前低电平的持续时间
void Infrared_Handler(void); &#x2F;&#x2F; 红外接收函数处理

extern void KeyAction(uint8_t keycode);
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;static function declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

&#x2F;*
* @function: Infrared_Init
* @param: None
* @retval: None
* @brief: 红外接收初始化
*&#x2F;
void Infrared_Init(void)
&#123;
    INFRARED_INPUT &#x3D; 1;  &#x2F;&#x2F; 确保红外接收引脚被释放

    TMOD &amp;&#x3D; 0x0F;  &#x2F;&#x2F; 清零T1的控制位
    TMOD |&#x3D; 0x10;  &#x2F;&#x2F; 配置T1为模式1
    TR1 &#x3D; 0;       &#x2F;&#x2F; 停止T1计数
    ET1 &#x3D; 0;       &#x2F;&#x2F; 禁止T1中断 

    IT1 &#x3D; 1;       &#x2F;&#x2F; 设置INT1为负边沿触发
    EX1 &#x3D; 1;       &#x2F;&#x2F; 使能INT1中断 
&#125;

&#x2F;*
* @function: Infrared_Get_High_Time
* @param: None
* @retval: None
* @brief: 获取当前高电平的持续时间
*&#x2F;
uint16_t Infrared_Get_High_Time(void)
&#123;
    TH1 &#x3D; 0; &#x2F;&#x2F; 清零T1计数初值
    TL1 &#x3D; 0;
    TR1 &#x3D; 1;         &#x2F;&#x2F; 启动T1计数
    while (INFRARED_INPUT) &#x2F;&#x2F; 红外输入引脚为1时循环检测等待，变为0时则结束本循环
    &#123;
        &#x2F;&#x2F; 当T1计数值大于0x4000，即高电平持续时间超过约18ms时，
        if (TH1 &gt;&#x3D; 0x40)
        &#123;          
            break; &#x2F;&#x2F; 强制退出循环，是为了避免信号异常时，程序假死在这里。
        &#125;
    &#125;
    TR1 &#x3D; 0; &#x2F;&#x2F; 停止T1计数

    return (TH1 * 256 + TL1); &#x2F;&#x2F; T1计数值合成为16bit整型数，并返回该数
&#125;

&#x2F;*
* @function: Infrared_Get_Low_Time
* @param: None
* @retval: None
* @brief: 获取当前低电平的持续时间
*&#x2F;
uint16_t Infrared_Get_Low_Time(void)
&#123;
    TH1 &#x3D; 0; &#x2F;&#x2F; 清零T1计数初值
    TL1 &#x3D; 0;
    TR1 &#x3D; 1;          &#x2F;&#x2F; 启动T1计数
    while (!INFRARED_INPUT) &#x2F;&#x2F; 红外输入引脚为0时循环检测等待，变为1时则结束本循环
    &#123;
        &#x2F;&#x2F; 当T1计数值大于0x4000，即低电平持续时间超过约18ms时，
        if (TH1 &gt;&#x3D; 0x40)
        &#123;          
            break; &#x2F;&#x2F; 强制退出循环，是为了避免信号异常时，程序假死在这里。
        &#125;
    &#125;
    TR1 &#x3D; 0; &#x2F;&#x2F; 停止T1计数

    return (TH1 * 256 + TL1); &#x2F;&#x2F; T1计数值合成为16bit整型数，并返回该数
&#125;

&#x2F;*
* @function: Infrared_Handler
* @param: None
* @retval: None
* @brief: 红外接收函数处理
*&#x2F;
void Infrared_Handler(void)
&#123;
    uint8_t i;

    if (Parameter.Infrared_RX_Flag)
    &#123;
        for (i &#x3D; 0; i &lt; sizeof(Infrered_CodeMap)&#x2F;sizeof(Infrered_CodeMap[0]); i++) &#x2F;&#x2F;遍历映射表
        &#123;
            if ((Infrared_RX_Buff[2]) &#x3D;&#x3D; Infrered_CodeMap[i][0])  &#x2F;&#x2F;在表中找到当前接收的键码后，
            &#123;                                  &#x2F;&#x2F;用对应的映射码执行函数调度，
                (KeyAction(Infrered_CodeMap[i][1]));    &#x2F;&#x2F;直接调用按键动作函数即可。
                break;
            &#125;
        &#125;        
        Parameter.Infrared_RX_Flag &#x3D; FALSE;
    &#125;
&#125;</code></pre>
              </div>
            </details>
<details ><summary> key.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;***************************************************************************
 * File: key.c
 * Author: Luckys.
 * Date: 2023&#x2F;06&#x2F;19
 * description: 
****************************************************************************&#x2F;
#include &lt;reg52.h&gt;

sbit KEY_IN_1  &#x3D; P2^4;
sbit KEY_IN_2  &#x3D; P2^5;
sbit KEY_IN_3  &#x3D; P2^6;
sbit KEY_IN_4  &#x3D; P2^7;
sbit KEY_OUT_1 &#x3D; P2^3;
sbit KEY_OUT_2 &#x3D; P2^2;
sbit KEY_OUT_3 &#x3D; P2^1;
sbit KEY_OUT_4 &#x3D; P2^0;

unsigned char code KeyCodeMap[4][4] &#x3D; &#123; &#x2F;&#x2F;矩阵按键编号到标准键盘键码的映射表
    &#123; &#39;1&#39;,  &#39;2&#39;,  &#39;3&#39;, 0x26 &#125;, &#x2F;&#x2F;数字键1、数字键2、数字键3、向上键
    &#123; &#39;4&#39;,  &#39;5&#39;,  &#39;6&#39;, 0x25 &#125;, &#x2F;&#x2F;数字键4、数字键5、数字键6、向左键
    &#123; &#39;7&#39;,  &#39;8&#39;,  &#39;9&#39;, 0x28 &#125;, &#x2F;&#x2F;数字键7、数字键8、数字键9、向下键
    &#123; &#39;0&#39;, 0x1B, 0x0D, 0x27 &#125;  &#x2F;&#x2F;数字键0、ESC键、  回车键、 向右键
&#125;;
unsigned char pdata KeySta[4][4] &#x3D; &#123;  &#x2F;&#x2F;全部矩阵按键的当前状态
    &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;
&#125;;

extern void KeyAction(unsigned char keycode);

&#x2F;* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 *&#x2F;
void Key_Handler()
&#123;
    unsigned char i, j;
    static unsigned char pdata backup[4][4] &#x3D; &#123;  &#x2F;&#x2F;按键值备份，保存前一次的值
        &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;
    &#125;;
    
    for (i&#x3D;0; i&lt;4; i++)  &#x2F;&#x2F;循环检测4*4的矩阵按键
    &#123;
        for (j&#x3D;0; j&lt;4; j++)
        &#123;
            if (backup[i][j] !&#x3D; KeySta[i][j])    &#x2F;&#x2F;检测按键动作
            &#123;
                if (backup[i][j] !&#x3D; 0)           &#x2F;&#x2F;按键按下时执行动作
                &#123;
                    KeyAction(KeyCodeMap[i][j]); &#x2F;&#x2F;调用按键动作函数
                &#125;
                backup[i][j] &#x3D; KeySta[i][j];     &#x2F;&#x2F;刷新前一次的备份值
            &#125;
        &#125;
    &#125;
&#125;
&#x2F;* 按键扫描函数，需在定时中断中调用，推荐调用间隔1ms *&#x2F;
void KeyScan()
&#123;
    unsigned char i;
    static unsigned char keyout &#x3D; 0;   &#x2F;&#x2F;矩阵按键扫描输出索引
    static unsigned char keybuf[4][4] &#x3D; &#123;  &#x2F;&#x2F;矩阵按键扫描缓冲区
        &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;,  &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;,
        &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;,  &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;
    &#125;;

    &#x2F;&#x2F;将一行的4个按键值移入缓冲区
    keybuf[keyout][0] &#x3D; (keybuf[keyout][0] &lt;&lt; 1) | KEY_IN_1;
    keybuf[keyout][1] &#x3D; (keybuf[keyout][1] &lt;&lt; 1) | KEY_IN_2;
    keybuf[keyout][2] &#x3D; (keybuf[keyout][2] &lt;&lt; 1) | KEY_IN_3;
    keybuf[keyout][3] &#x3D; (keybuf[keyout][3] &lt;&lt; 1) | KEY_IN_4;
    &#x2F;&#x2F;消抖后更新按键状态
    for (i&#x3D;0; i&lt;4; i++)  &#x2F;&#x2F;每行4个按键，所以循环4次
    &#123;
        if ((keybuf[keyout][i] &amp; 0x0F) &#x3D;&#x3D; 0x00)
        &#123;   &#x2F;&#x2F;连续4次扫描值为0，即4*4ms内都是按下状态时，可认为按键已稳定的按下
            KeySta[keyout][i] &#x3D; 0;
        &#125;
        else if ((keybuf[keyout][i] &amp; 0x0F) &#x3D;&#x3D; 0x0F)
        &#123;   &#x2F;&#x2F;连续4次扫描值为1，即4*4ms内都是弹起状态时，可认为按键已稳定的弹起
            KeySta[keyout][i] &#x3D; 1;
        &#125;
    &#125;
    &#x2F;&#x2F;执行下一次的扫描输出
    keyout++;         &#x2F;&#x2F;输出索引递增
    keyout &amp;&#x3D; 0x03;   &#x2F;&#x2F;索引值加到4即归零
    switch (keyout)   &#x2F;&#x2F;根据索引，释放当前输出引脚，拉低下次的输出引脚
    &#123;
        case 0: KEY_OUT_4 &#x3D; 1; KEY_OUT_1 &#x3D; 0; break;
        case 1: KEY_OUT_1 &#x3D; 1; KEY_OUT_2 &#x3D; 0; break;
        case 2: KEY_OUT_2 &#x3D; 1; KEY_OUT_3 &#x3D; 0; break;
        case 3: KEY_OUT_3 &#x3D; 1; KEY_OUT_4 &#x3D; 0; break;
        default: break;
    &#125;
&#125;
</code></pre>
              </div>
            </details>
<details ><summary> lcd1602.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;***************************************************************************
 * File: lcd1602.c
 * Author: Luckys.
 * Date: 2023&#x2F;06&#x2F;19
 * description: 
****************************************************************************&#x2F;
#include &quot;main.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

uint8_t Pin_Status_Temp_Arr[3]; &#x2F;&#x2F; 存储状态

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;extern area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

extern void FillMemory(uint8_t *dest, uint8_t byt, uint8_t len);

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;extern area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;static function declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

static void Led_Pin_Pause(void);    &#x2F;&#x2F; 暂停LED相关引脚的值
static void Led_Pin_Recover(void);  &#x2F;&#x2F; 恢复LED相关引脚的值

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;static function declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

&#x2F;* 等待液晶准备好 *&#x2F;
void LcdWaitReady()
&#123;
    unsigned char sta;

    LCD1602_DB &#x3D; 0xFF;
    LCD1602_RS &#x3D; 0;
    LCD1602_RW &#x3D; 1;
    do
    &#123;
        LCD1602_E &#x3D; 1;
        sta &#x3D; LCD1602_DB; &#x2F;&#x2F; 读取状态字
        LCD1602_E &#x3D; 0;
    &#125; while (sta &amp; 0x80); &#x2F;&#x2F; bit7等于1表示液晶正忙，重复检测直到其等于0为止
&#125;

&#x2F;* 向LCD1602液晶写入一字节命令，cmd-待写入命令值 *&#x2F;
void LcdWriteCmd(unsigned char cmd)
&#123;
    Led_Pin_Pause();    &#x2F;&#x2F; 暂停状态
    LcdWaitReady();
    LCD1602_RS &#x3D; 0;
    LCD1602_RW &#x3D; 0;
    LCD1602_DB &#x3D; cmd;
    LCD1602_E &#x3D; 1;
    LCD1602_E &#x3D; 0;
    Led_Pin_Recover();  &#x2F;&#x2F; 打开状态
&#125;

&#x2F;* 向LCD1602液晶写入一字节数据，dat-待写入数据值 *&#x2F;
void LcdWriteDat(unsigned char dat)
&#123;
    Led_Pin_Pause();    &#x2F;&#x2F; 暂停状态
    LcdWaitReady();
    LCD1602_RS &#x3D; 1;
    LCD1602_RW &#x3D; 0;
    LCD1602_DB &#x3D; dat;
    LCD1602_E &#x3D; 1;
    LCD1602_E &#x3D; 0;
    Led_Pin_Recover();  &#x2F;&#x2F; 打开状态
&#125;

&#x2F;* 设置显示RAM起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 *&#x2F;
void LcdSetCursor(unsigned char x, unsigned char y)
&#123;
    unsigned char addr;

    if (y &#x3D;&#x3D; 0)          &#x2F;&#x2F; 由输入的屏幕坐标计算显示RAM的地址
        addr &#x3D; 0x00 + x; &#x2F;&#x2F; 第一行字符地址从0x00起始
    else
        addr &#x3D; 0x40 + x;      &#x2F;&#x2F; 第二行字符地址从0x40起始
    LcdWriteCmd(addr | 0x80); &#x2F;&#x2F; 设置RAM地址
&#125;

&#x2F;* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 *&#x2F;
void LcdShowStr(unsigned char x, unsigned char y, unsigned char *str)
&#123;
    LcdSetCursor(x, y);  &#x2F;&#x2F; 设置起始地址
    while (*str !&#x3D; &#39;\0&#39;) &#x2F;&#x2F; 连续写入字符串数据，直到检测到结束符
    &#123;
        LcdWriteDat(*str++);
    &#125;
&#125;

&#x2F;* 清屏 *&#x2F;
void LcdClearScreen()
&#123;
    LcdWriteCmd(0x01);
&#125;

&#x2F;* 初始化1602液晶 *&#x2F;
void InitLcd1602()
&#123;
    LcdWriteCmd(0x38); &#x2F;&#x2F; 16*2显示，5*7点阵，8位数据接口
    LcdWriteCmd(0x0C); &#x2F;&#x2F; 显示器开，光标关闭
    LcdWriteCmd(0x06); &#x2F;&#x2F; 文字不动，地址自动+1
    LcdWriteCmd(0x01); &#x2F;&#x2F; 清屏
&#125;

&#x2F;* 在液晶上显示与当前输入密码位数相同的*，以指示当前输入的密码位数（不会超过屏幕宽度） *&#x2F;
void ShowPswCnt()
&#123;
    unsigned char buf[LCD_LONG];
    if (Parameter.ucPassword_Cnt &gt; 16)
    &#123;
        return;
    &#125;
    FillMemory(buf, &#39;*&#39;, Parameter.ucPassword_Cnt);
    FillMemory(buf + Parameter.ucPassword_Cnt, &#39;\0&#39;, sizeof(buf) - Parameter.ucPassword_Cnt);
    LcdShowStr(0, 1, buf);
&#125;

&#x2F;********************************************LED部分***************************************&#x2F;

&#x2F;*
* @function: Led_Pin_Pause
* @param: None
* @retval: None
* @brief: 暂停LED相关引脚的值
*&#x2F;
static void Led_Pin_Pause(void)
&#123;
    ENLED &#x3D; 1;  &#x2F;&#x2F; 停止
    Pin_Status_Temp_Arr[0] &#x3D; LED_PORT;
    Pin_Status_Temp_Arr[1] &#x3D; ADDR0;
    Pin_Status_Temp_Arr[2] &#x3D; ADDR1;    
&#125;

&#x2F;*
* @function: Led_Pin_Pause
* @param: None
* @retval: None
* @brief: 恢复LED相关引脚的值
*&#x2F;
static void Led_Pin_Recover(void)
&#123;
    ADDR0 &#x3D; Pin_Status_Temp_Arr[1];
    ADDR1 &#x3D; Pin_Status_Temp_Arr[2];  
    LED_PORT &#x3D; Pin_Status_Temp_Arr[0];  
    ENLED &#x3D; 0;  &#x2F;&#x2F; 开启
&#125;

&#x2F;*
* @function: Led_Init
* @param: None
* @retval: None
* @brief: LED初始化
*&#x2F;
void Led_Init(void)
&#123;
    &#x2F;*Enable 74HC138 IC ---- Y6&#39; *&#x2F;
	ENLED &#x3D; 0;
	ADDR0 &#x3D; 0;
	ADDR1 &#x3D; 1;
	ADDR2 &#x3D; 1;
	ADDR3 &#x3D; 1;

    LED_PORT &#x3D; 0xFF;    &#x2F;&#x2F; 初始化全灭
&#125;

&#x2F;*
* @function: Led_Flip
* @param: LEDx -&gt; x:1~8
* @retval: None
* @brief: LED翻转
*&#x2F;
void Led_Flip(Led_Num_t LEDx)
&#123;
    switch(LEDx)
    &#123;
        case LED1: LED1_PIN &#x3D; ~LED1_PIN;break;
        case LED2: LED2_PIN &#x3D; ~LED2_PIN;break;
        case LED3: LED3_PIN &#x3D; ~LED3_PIN;break;
        case LED4: LED4_PIN &#x3D; ~LED4_PIN;break;
        case LED5: LED5_PIN &#x3D; ~LED5_PIN;break;
        case LED6: LED6_PIN &#x3D; ~LED6_PIN;break;
        case LED7: LED7_PIN &#x3D; ~LED7_PIN;break;
        case LED8: LED8_PIN &#x3D; ~LED8_PIN;break;
        default:LED_PORT &#x3D; 0xFF;
    &#125; 
&#125;

&#x2F;********************************************蜂鸣器部分***************************************&#x2F;
&#x2F;*
* @function: Buzzer_ON
* @param: None
* @retval: None
* @brief: 蜂鸣器打开
*&#x2F;
void Buzzer_ON(void)
&#123;
    Parameter.Buzzer_Start_Flag &#x3D; TRUE;
&#125;</code></pre>
              </div>
            </details>
<details ><summary> other.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;***************************************************************************
 * File: other.c
 * Author: Luckys.
 * Date: 2023&#x2F;06&#x2F;19
 * description: 
****************************************************************************&#x2F;
#include &quot;main.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;function declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

void FillMemory(uint8_t *dest, uint8_t byt, uint8_t len);   &#x2F;&#x2F; 用一个指定字节填充一段内存
void CopyMemory(uint8_t *dest, uint8_t *src, uint8_t len);  &#x2F;&#x2F; 将一段内存数据拷贝到另一处
bit CmpMemory(uint8_t *ptr1, uint8_t *ptr2, uint8_t len);   &#x2F;&#x2F; 内存比较函数，比较两个指针所指向的内存数据是否相同
uint8_t GetChkSum(uint8_t *dat, uint8_t len);
void SavePassword(void);    &#x2F;&#x2F; 将当前的密码数据保存到EEPROM中，同时添加校验字节
bit ReadPassword(); &#x2F;&#x2F; 从EEPROM中读取保存的密码数据，并对密码进行“累加和”校验
uint8_t find_substring(char *arr1, char *arr2, uint8_t len2);   &#x2F;&#x2F; 模糊查找
uint8_t Add_Symbol(uint8_t *arr,uint8_t Now_Len);   &#x2F;&#x2F; 末尾添加 &#39;@&#39; 凑够实际密码长度的最大值
void KeyAction(uint8_t keycode);    &#x2F;&#x2F; 按键动作函数，根据键码执行相应的操作，keycode
void Clear_Cache(void); &#x2F;&#x2F; 清除缓存
uint8_t Compare_And_Save(void); &#x2F;&#x2F; 比较+保存
void System_MS_Delay(uint16_t ms);  &#x2F;&#x2F; 延时

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;function declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;extern declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

extern void EEPROM_Write(unsigned char *buf, unsigned char addr, unsigned char len);
extern void EEPROM_Read(unsigned char *buf, unsigned char addr, unsigned char len);
extern void KeyNumAction(uint8_t keycode);
extern void LcdClearScreen();
extern void KeyEnterAction();
extern void KeyEscAction();
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;extern  declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;* 用一个指定字节填充一段内存，dest-目的地址，byt-填充用字节，len-数据长度 *&#x2F;
void FillMemory(uint8_t *dest, uint8_t byt, uint8_t len)
&#123;
    while (len--)
    &#123;
        *dest++ &#x3D; byt;
    &#125;
&#125;

&#x2F;* 将一段内存数据拷贝到另一处，dest-目的地址，src-源地址，len-数据长度 *&#x2F;
void CopyMemory(uint8_t *dest, uint8_t *src, uint8_t len)
&#123;
    while (len--)
    &#123;
        *dest++ &#x3D; *src++;
    &#125;
&#125;

&#x2F;* 内存比较函数，比较两个指针所指向的内存数据是否相同，
   ptr1-待比较指针1，ptr2-待比较指针2，len-待比较长度
   返回值-两段内存数据完全相同时返回1，不同返回0 *&#x2F;
bit CmpMemory(uint8_t *ptr1, uint8_t *ptr2, uint8_t len)
&#123;
    while (len--)
    &#123;
        if (*ptr1++ !&#x3D; *ptr2++)  &#x2F;&#x2F;遇到不相等数据时即刻返回0
        &#123;
            return 0;
        &#125;
    &#125;
    return 1;  &#x2F;&#x2F;比较完全部长度数据都相等则返回1
&#125;

&#x2F;* 将一段数据按字节累加，返回获得的累加和，dat-数据指针，len-数据长度 *&#x2F;
uint8_t GetChkSum(uint8_t *dat, uint8_t len)
&#123;
    uint8_t sum &#x3D; 0;

    while (len--)
    &#123;
        sum +&#x3D; *dat++;
    &#125;
    return sum;
&#125;

&#x2F;* 将当前的密码数据保存到EEPROM中，同时添加校验字节 *&#x2F;
void SavePassword(void)
&#123;
    uint8_t buf[PWD_IN_MAX_LEN + 1];

    CopyMemory(buf, ucUser_Pwd_Buff, PWD_IN_MAX_LEN);  &#x2F;&#x2F;复制密码数据到缓冲区中
    buf[PWD_IN_MAX_LEN] &#x3D; ~GetChkSum(buf, PWD_IN_MAX_LEN);  &#x2F;&#x2F;填充最后的累加和校验字节
    EEPROM_Write(buf, PWD_SAVE_ADDR, PWD_IN_MAX_LEN + 1); &#x2F;&#x2F;将密码数据保存到EEPROM中
&#125;

&#x2F;* 从EEPROM中读取保存的密码数据，并对密码进行“累加和”校验，
   返回值-校验通过返回1，否则返回0 *&#x2F;
bit ReadPassword()
&#123;
    uint8_t sum;
    uint8_t buf[PWD_IN_MAX_LEN + 1];

    EEPROM_Read(buf, PWD_SAVE_ADDR, PWD_IN_MAX_LEN + 1); &#x2F;&#x2F;读取密码数据和校验字节
    sum &#x3D; GetChkSum(buf, PWD_IN_MAX_LEN); &#x2F;&#x2F;计算密码数据的累加和
    if (buf[PWD_IN_MAX_LEN] &#x3D;&#x3D; ~sum)      &#x2F;&#x2F;校验通过，即密码有效时，拷贝密码
    &#123;
        CopyMemory(ucUser_Pwd_Buff, buf, PWD_IN_MAX_LEN);
        return 1;
    &#125;
    else  &#x2F;&#x2F;密码数据无效时，缓冲区默认成全0
    &#123;
        FillMemory(ucUser_Pwd_Buff, &#39;\0&#39;, PWD_IN_MAX_LEN);
        return 0;
    &#125;
&#125;

&#x2F;&#x2F; 模糊查找
uint8_t find_substring(char *arr1, char *arr2, uint8_t len2)
&#123;
    uint8_t pos1 &#x3D; 0; &#x2F;&#x2F; 当前匹配到的位置
    uint8_t pos2 &#x3D; 0; &#x2F;&#x2F; 下一个需要匹配的位置
    uint8_t i, len1 &#x3D; 0;

    &#x2F;&#x2F; 计算长度,去除&#39;@&#39;
    for (i &#x3D; 0; i &lt; 10; i++)
    &#123;
        if (arr1[i] !&#x3D; &#39;@&#39;)
        &#123;
            ++len1;
        &#125;
    &#125;
    for (i &#x3D; 0; i &lt; len2; i++)
    &#123;
		&#x2F;&#x2F; &#x2F;&#x2F; 如果当前的字符匹配上了，就继续匹配后面的字符是否相等
        if (arr1[pos1] &#x3D;&#x3D; arr2[i])
        &#123;
            pos2 &#x3D; pos1 + 1;
            while ((pos2 &lt; len1) &amp;&amp; (i &lt; len2) &amp;&amp; (arr1[pos2] &#x3D;&#x3D; arr2[i + 1]))
            &#123;
                i++;	&#x2F;&#x2F; 匹配成功，arr2的下标往后移动一位
                pos2++;	&#x2F;&#x2F; 匹配成功，pos2的下标往后移动一位
            &#125;
            if (pos2 &#x3D;&#x3D; len1)
            &#123;
                return 1; &#x2F;&#x2F; 找到了
            &#125;
        &#125;
        else
        &#123;
            pos1 &#x3D; 0;	&#x2F;&#x2F; 从头开始匹配
        &#125;
    &#125;

    return 0; &#x2F;&#x2F; 没有找到
&#125;

&#x2F;&#x2F; 末尾添加@凑够10个
uint8_t Add_Symbol(uint8_t *arr,uint8_t Now_Len)
&#123;
    uint8_t i;
    if (Now_Len &gt; PWD_REAL_MAX || Now_Len &lt; PWD_REAL_MIN)   &#x2F;&#x2F; 判断条件是否满足
    &#123;
        return 0;
    &#125;
    for (i &#x3D; Now_Len; i &lt; PWD_REAL_MAX; i++)
    &#123;
        arr[i] &#x3D; &#39;@&#39;;
    &#125;
    return 1;
&#125;

&#x2F;* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 *&#x2F;
void KeyAction(uint8_t keycode)
&#123;
    if  ((keycode &gt;&#x3D; &#39;0&#39;) &amp;&amp; (keycode &lt;&#x3D; &#39;9&#39;)) &#x2F;&#x2F;输入字符
    &#123;
        KeyNumAction(keycode);
    &#125;
    else if (keycode &#x3D;&#x3D; 0x0D)  &#x2F;&#x2F;回车键
    &#123;
        KeyEnterAction();
    &#125;
    else if (keycode &#x3D;&#x3D; 0x1B)  &#x2F;&#x2F;Esc键
    &#123;
        KeyEscAction();
    &#125;
    else if (keycode &#x3D;&#x3D; 0x26)	&#x2F;&#x2F; 向上
    &#123;
        Menu_Mode &#x3D; Menu_Mode % 2 + 1;
        LcdClearScreen();
    &#125;
    else if (keycode &#x3D;&#x3D; 0x28)	&#x2F;&#x2F; 向下
    &#123;
        Menu_Mode &#x3D; (Menu_Mode &gt; 1) ? Menu_Mode - 1 : 2;
        LcdClearScreen();
    &#125;    
&#125;

&#x2F;*清除缓存*&#x2F;
void Clear_Cache(void)
&#123;
    FillMemory(ucPwd_In_Buff1, &#39;\0&#39;, PWD_IN_MAX_LEN);
    FillMemory(ucPwd_In_Buff2, &#39;\0&#39;, PWD_IN_MAX_LEN);
    Parameter.ucPassword_Cnt &#x3D; 0;      
&#125;

&#x2F;*比较+保存*&#x2F;
uint8_t Compare_And_Save(void)
&#123;
    if (CmpMemory(ucPwd_In_Buff1, ucPwd_In_Buff2, PWD_REAL_MAX))
    &#123;
        if (Add_Symbol(ucUser_Pwd_Buff, Parameter.ucPassword_Cnt))
        &#123;
            EEPROM_Write(&amp;Power_Value, PWD_SAVE_ADDR, 1);   &#x2F;&#x2F; 写入标志位
            System_MS_Delay(5);
            EEPROM_Write(ucUser_Pwd_Buff, PWD_SAVE_ADDR, PWD_REAL_MAX); &#x2F;&#x2F; 密码存储
            return 1;
        &#125;
        else
        &#123;
            return 0;
        &#125;
    &#125;
    return 0;
&#125;

&#x2F;&#x2F; ms延时
void System_MS_Delay(uint16_t ms)
&#123;
    uint16_t i,j;
    for(j&#x3D;ms;j&gt;0;j--)
    for(i&#x3D;112;i&gt;0;i--);
&#125;</code></pre>
              </div>
            </details>
<details ><summary> main.h </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifndef __MAIN_H
#define __MAIN_H
#include &lt;reg52.h&gt;

#define LCD_LONG 16 &#x2F;&#x2F; 屏幕宽度显示最大字符长度
#define PWD_IN_MAX_LEN    20    &#x2F;&#x2F;输入密码最大长度
#define PWD_SAVE_ADDR  0x30  &#x2F;&#x2F;密码在EEPROM中的保存地址
#define PSW_FLAG_ADDR  0x08 &#x2F;&#x2F; 上电标志位存储地址
#define PWD_REAL_MAX 10  &#x2F;&#x2F; 用户密码实际最大长度
#define PWD_REAL_MIN 6   &#x2F;&#x2F; 用户密码实际最小长度
#define Power_FLAG (uint8_t)&#39;7&#39;  &#x2F;&#x2F; 上电存储值
#define PWD_ERROR_MAX 3 &#x2F;&#x2F; 错误多少次后锁定
&#x2F;&#x2F; 重置密码时打开宏
&#x2F;&#x2F; #define USE_RESET_PWD
&#x2F;&#x2F; 需要调成上电时状态打开宏(打开后烧写然后注释再烧一次即可)
&#x2F;&#x2F; #define USE_POWER_ON

&#x2F;*LED IO*&#x2F;
sbit LED1_PIN &#x3D; P0^0;
sbit LED2_PIN &#x3D; P0^1;
sbit LED3_PIN &#x3D; P0^2;
sbit LED4_PIN &#x3D; P0^3;
sbit LED5_PIN &#x3D; P0^4;
sbit LED6_PIN &#x3D; P0^5;
sbit LED7_PIN &#x3D; P0^6;
sbit LED8_PIN &#x3D; P0^7;
#define LED_PORT P0

&#x2F;*74HC138 IC IO*&#x2F;
sbit ADDR0 &#x3D; P1^0;  &#x2F;&#x2F; A
sbit ADDR1 &#x3D; P1^1;  &#x2F;&#x2F; B
sbit ADDR2 &#x3D; P1^2;  &#x2F;&#x2F; C
sbit ADDR3 &#x3D; P1^3;  &#x2F;&#x2F; G1
sbit ENLED &#x3D; P1^4;  &#x2F;&#x2F; G2

&#x2F;*Buzzer IO*&#x2F;
sbit BUZZER_PIN &#x3D; P1^6;

&#x2F;* I2C IO *&#x2F;
sbit I2C_SCL &#x3D; P3^7;
sbit I2C_SDA &#x3D; P3^6;

&#x2F;* LCD1602 IO*&#x2F;
sbit LCD1602_RS &#x3D; P1^0;
sbit LCD1602_RW &#x3D; P1^1;
sbit LCD1602_E  &#x3D; P1^5;
#define LCD1602_DB  P0

&#x2F;* infrared IO*&#x2F;
sbit INFRARED_INPUT &#x3D; P3^3;

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;

&#x2F;&#x2F; TRUE&#x2F;FALSE
typedef enum
&#123;
    FALSE &#x3D; 0U,
    TRUE &#x3D; !FALSE 
&#125;FLagStatus_t;

&#x2F;&#x2F; 模式枚举
typedef enum
&#123;
    Change_PAWWD &#x3D; (uint8_t)0x01,   &#x2F;&#x2F; 修改密码模式
    VERIFY_PAWWD &#x3D; (uint8_t)0x02,   &#x2F;&#x2F; 密码验证模式
&#125; Menu_Mode_t;

&#x2F;&#x2F; 密码状态枚举
typedef enum
&#123;
    NONE_PWD &#x3D; (uint8_t)0x00,   &#x2F;&#x2F; 无状态
    ENTER_PWD &#x3D; (uint8_t)0x01,  &#x2F;&#x2F; 输入密码状态
    SET_PWD &#x3D; (uint8_t)0x02,    &#x2F;&#x2F; 设置密码状态
    AGAIN_PWD &#x3D; (uint8_t)0x03,  &#x2F;&#x2F; 再次确认密码状态
&#125;Input_Status_t;

&#x2F;&#x2F; 页面切换枚举
typedef enum
&#123;
    Interface_NULL &#x3D; (uint8_t)0x00, &#x2F;&#x2F; 无
    Interface_PowerOn &#x3D; (uint8_t)0x01,  &#x2F;&#x2F; 第一次上电
    Interface_ModeChoose &#x3D; (uint8_t)0x02,   &#x2F;&#x2F; 模式选择
    Interface_ChangePwd &#x3D; (uint8_t)0x03,    &#x2F;&#x2F; 密码修改
    Interface_VerifyPwd &#x3D; (uint8_t)0x04,    &#x2F;&#x2F; 密码验证
    Interface_Open &#x3D; (uint8_t)0x05, &#x2F;&#x2F; 解锁成功
    Interface_Lock &#x3D; (uint8_t)0x06,  &#x2F;&#x2F; 锁定系统
&#125; Menu_Interface_Status_t;

&#x2F;&#x2F; LED枚举
typedef enum
&#123;
    LED1 &#x3D; (uint8_t)0x01,
    LED2 &#x3D; (uint8_t)0x02,
    LED3 &#x3D; (uint8_t)0x03,
    LED4 &#x3D; (uint8_t)0x04,
    LED5 &#x3D; (uint8_t)0x05,
    LED6 &#x3D; (uint8_t)0x06,
    LED7 &#x3D; (uint8_t)0x07,
    LED8 &#x3D; (uint8_t)0x08,        
&#125; Led_Num_t;

typedef struct
&#123;
    uint8_t Infrared_RX_Flag;   &#x2F;&#x2F; 红外标志位
    uint8_t Buzzer_Start_Flag;  &#x2F;&#x2F; 蜂鸣器启动标志位
    uint8_t ucUNLock_Led_Flag;    &#x2F;&#x2F; 开锁后LED标志位
    uint8_t ucError_Cnt;    &#x2F;&#x2F; 错误密码计数  (默认0)
    uint8_t ucPassword_Cnt;   &#x2F;&#x2F; 当前输入密码位数的计数器  (默认0)
    uint8_t Verify_Index;    &#x2F;&#x2F; 验证密码步骤索引 1 -- 输入密码   (默认0)
    uint8_t Change_Index;    &#x2F;&#x2F; 修改密码步骤索引 1 -- 旧密码输入 2 -- 新密码输入 3 -- 再次输入新密码  (默认0)
    uint8_t PowerOn_Index;  &#x2F;&#x2F; 第一次上电步骤索引 1 -- 输入密码 2 -- 再次输入 (默认0)
&#125; Parameter_t;

extern uint8_t Power_Value;
extern uint8_t pdata ucUser_Pwd_Buff[PWD_REAL_MAX];
extern Menu_Mode_t Menu_Mode;
extern Parameter_t Parameter;
extern uint8_t pdata ucPwd_In_Buff1[PWD_IN_MAX_LEN];  &#x2F;&#x2F;密码输入缓冲区1
extern uint8_t pdata ucPwd_In_Buff2[PWD_IN_MAX_LEN];  &#x2F;&#x2F;密码输入缓冲区2
#endif
</code></pre>
              </div>
            </details>
<details ><summary> main.c </summary>
              <div class='content'>
              <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;main.h&quot;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;
&#x2F;&#x2F; 枚举初始化
Input_Status_t Input_Status &#x3D; NONE_PWD;
Menu_Mode_t Menu_Mode &#x3D; Change_PAWWD;
Menu_Interface_Status_t Menu_Interface_Status &#x3D; Interface_NULL;
&#x2F;&#x2F; 结构体初始化
Parameter_t Parameter &#x3D; 
&#123;
    FALSE,
    FALSE,
    FALSE,
    0,
    0,
    0,
    0,
    0,
&#125;;

&#x2F;&#x2F; 上电标志位
uint8_t Power_Value &#x3D; &#39;7&#39;;
uint8_t pdata ucUser_Pwd_Buff[PWD_REAL_MAX] &#x3D; &#123;&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;@&#39;,&#39;@&#39;,&#39;@&#39;&#125;;   &#x2F;&#x2F;用户密码数据(默认)
uint8_t pdata ucPwd_In_Buff1[PWD_IN_MAX_LEN];  &#x2F;&#x2F;密码输入缓冲区1
uint8_t pdata ucPwd_In_Buff2[PWD_IN_MAX_LEN];  &#x2F;&#x2F;密码输入缓冲区2

uint8_t T0RH &#x3D; 0;  &#x2F;&#x2F;T0重载值的高字节
uint8_t T0RL &#x3D; 0;  &#x2F;&#x2F;T0重载值的低字节

extern uint8_t Infrared_RX_Buff[4];
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;variable definition declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;extern declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

extern uint8_t GetChkSum(uint8_t *dat, uint8_t len);
extern void KeyScan();
extern void LcdClearScreen();
extern void LcdShowStr(uint8_t x, uint8_t y, uint8_t *str);
extern uint8_t find_substring(char *arr1, char *arr2, uint8_t len2);
extern void FillMemory(uint8_t *dest, uint8_t byt, uint8_t len);
extern void EEPROM_Write(uint8_t *buf, uint8_t addr, uint8_t len);
extern uint8_t Add_Symbol(uint8_t *arr,uint8_t Now_Len);
extern void CopyMemory(uint8_t *dest, uint8_t *src, uint8_t len);
extern bit CmpMemory(uint8_t *ptr1, uint8_t *ptr2, uint8_t len);
extern void EEPROM_Read(uint8_t *buf, uint8_t addr, uint8_t len);
extern void InitLcd1602();
extern void Key_Handler();
extern void ShowPswCnt();
extern void SavePassword(void);
extern void Clear_Cache(void);
extern uint8_t Compare_And_Save(void);
extern void System_MS_Delay(uint16_t ms);
extern void Led_Flip(Led_Num_t LEDx);
extern void Led_Init(void);
extern void Buzzer_ON(void);
extern void Infrared_Handler(void);
extern void Infrared_Init(void);
extern uint16_t Infrared_Get_High_Time(void);
extern uint16_t Infrared_Get_Low_Time(void);
&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;extern  declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;function declaration area BEGIN&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;

void ConfigTimer0(uint16_t);  &#x2F;&#x2F; 配置并启动T0
void Menu_Handler(void);    &#x2F;&#x2F; 页面变化
void KeyNumAction(uint8_t); &#x2F;&#x2F; 数字检测
void KeyEnterAction(void);  &#x2F;&#x2F; 回车检测
void Hardware_Init(void);    &#x2F;&#x2F; 硬件初始化

&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;function declaration area   END&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;


void main()
&#123;
    Hardware_Init();

    while (1)
    &#123;
        Menu_Handler(); &#x2F;&#x2F; 页面处理
        Infrared_Handler(); &#x2F;&#x2F; 红外处理
        Key_Handler();    &#x2F;&#x2F; 按键处理
    &#125;
&#125;

void Menu_Handler(void)
&#123;
    switch (Menu_Interface_Status)
    &#123;
    case Interface_PowerOn: &#x2F;&#x2F; 首次上电设置密码
    &#123;
        switch(Parameter.PowerOn_Index)
        &#123;
            case 1:
            &#123;
                Input_Status &#x3D; SET_PWD;
                LcdShowStr(0, 0, &quot;  Set Password&quot;);
                break;
            &#125;
            case 2:
            &#123;
                Input_Status &#x3D; AGAIN_PWD;
                LcdShowStr(0, 0, &quot;  Set Again&quot;);
                break;
            &#125;
            default: break;
        &#125;
        break;
    &#125;
    case Interface_ModeChoose: &#x2F;&#x2F; 主页面
    &#123;
        LcdShowStr(0, 0, &quot;      Mode&quot;);

        if (Change_PAWWD &#x3D;&#x3D; Menu_Mode)
        &#123;
            LcdShowStr(0, 1, &quot;1.Revise PWD&quot;);
        &#125;
        else if (VERIFY_PAWWD &#x3D;&#x3D; Menu_Mode)
        &#123;
            LcdShowStr(0, 1, &quot;2.verify PWD&quot;);
        &#125;
        break;
    &#125;
    case Interface_ChangePwd: &#x2F;&#x2F; 修改密码
    &#123;
        switch(Parameter.Change_Index)
        &#123;
            case 1: &#x2F;&#x2F; 旧密码输入
            &#123;
                LcdShowStr(0, 0, &quot;Old Password&quot;);
                Input_Status &#x3D; SET_PWD; &#x2F;&#x2F; 这个有限制长度
                break;
            &#125;
            case 2: &#x2F;&#x2F; 新密码输入
            &#123;
                LcdShowStr(0, 0, &quot;new Password&quot;);
                Input_Status &#x3D; SET_PWD; &#x2F;&#x2F; 这个有限制长度
                break;
            &#125;
            case 3:	&#x2F;&#x2F; 再次新密码输入
            &#123;
                LcdShowStr(0, 0, &quot;  Set Again&quot;);
                Input_Status &#x3D; AGAIN_PWD; &#x2F;&#x2F; 再次输入
                break;
            &#125;
            default:break;
        &#125;
        break;
    &#125;
    case Interface_VerifyPwd: &#x2F;&#x2F; 验证密码
    &#123;
        switch (Parameter.Verify_Index)
        &#123;
            case 1: &#x2F;&#x2F; 输入密码
            &#123;
                LcdShowStr(0, 0, &quot;Input Password&quot;);
                Input_Status &#x3D; ENTER_PWD;
                break;
            &#125;
            default: break;
        &#125;
        break;
    &#125;
    case Interface_Open:    &#x2F;&#x2F; 开锁
    &#123;
        LcdShowStr(0, 0, &quot;   Hello Baby&quot;);
        LcdShowStr(0, 1, &quot;  Door is Open&quot;);
        break;
    &#125;
    case Interface_Lock:    &#x2F;&#x2F; 锁死
    &#123;
        LcdShowStr(0, 0, &quot;  System Lock&quot;);
        LcdShowStr(0, 1, &quot;  Please Reset&quot;);
        while(1)
        &#123;
            ;
        &#125;
        break;
    &#125;
    default:
        break;
    &#125;
&#125;

&#x2F;* 数字键动作函数，keycode-数字按键的ASCII值 *&#x2F;
void KeyNumAction(uint8_t keycode)
&#123;
    switch (Input_Status)
    &#123;
        &#x2F;&#x2F; 输入密码状态时，将输入字符填充到 ucPwd_In_Buff1 (长度可设置最大限制)
    case ENTER_PWD: 
    &#123;
        if (Parameter.ucPassword_Cnt &lt; PWD_IN_MAX_LEN)
        &#123;
            ucPwd_In_Buff1[Parameter.ucPassword_Cnt] &#x3D; keycode; &#x2F;&#x2F; 赋值
            Parameter.ucPassword_Cnt++;
            ShowPswCnt();
        &#125;
        break;        
    &#125;
        &#x2F;&#x2F; 设置密码状态时，将输入字符填充到 ucPwd_In_Buff1(长度有一定范围)
    case SET_PWD:                        
    &#123;
        if (Parameter.ucPassword_Cnt &lt; PWD_REAL_MAX) &#x2F;&#x2F; 密码长度看宏
        &#123;
            ucPwd_In_Buff1[Parameter.ucPassword_Cnt] &#x3D; keycode;
            Parameter.ucPassword_Cnt++;
            ShowPswCnt();
        &#125;
        break;        
    &#125;
        &#x2F;&#x2F; 设置密码确认状态时，将输入字符填充到 ucPwd_In_Buff2(长度有一定范围)
    case AGAIN_PWD: 
    &#123;
        if (Parameter.ucPassword_Cnt &lt; PWD_REAL_MAX)
        &#123;
            ucPwd_In_Buff2[Parameter.ucPassword_Cnt] &#x3D; keycode;
            Parameter.ucPassword_Cnt++;
            ShowPswCnt();
        &#125;
        break;        
    &#125;
    default: break;
    &#125;
&#125;

&#x2F;* 回车键动作函数 *&#x2F;
void KeyEnterAction(void)
&#123;

    switch(Menu_Interface_Status)
    &#123;
        case Interface_NULL:break;	&#x2F;&#x2F; 暂时没得用！
        case Interface_PowerOn:	&#x2F;&#x2F; 如果当前处于上电状态下
        &#123;
            if (1 &#x3D;&#x3D; Parameter.PowerOn_Index)	&#x2F;&#x2F; 如果当前是处于 1 状态
            &#123;
                Parameter.PowerOn_Index &#x3D; 2;	&#x2F;&#x2F; 转下一个状态 2
                Parameter.ucPassword_Cnt &#x3D; 0;
                LcdClearScreen();
            &#125;
            else if (2 &#x3D;&#x3D; Parameter.PowerOn_Index)  &#x2F;&#x2F; 完成此步再清空 Buff1 和 Buff2的缓存！！！
            &#123;
                if (Compare_And_Save())	&#x2F;&#x2F; 比较两个数组+保存到EEPROM
                &#123;
                    Menu_Interface_Status &#x3D; Interface_ModeChoose;
                    LcdShowStr(0, 0, &quot;   Set Success&quot;);
                    System_MS_Delay(1200);
                &#125;
                else
                &#123;
                    &#x2F;&#x2F; 错误则继续在设置密码页面
                    Menu_Interface_Status &#x3D; Interface_PowerOn;
                    Parameter.PowerOn_Index &#x3D; 1;
                    LcdShowStr(0, 0, &quot;    Set Fail&quot;);
                    System_MS_Delay(1200);
                &#125;      
                Clear_Cache();
                LcdClearScreen();
            &#125;
            break;
        &#125;   
        case Interface_ModeChoose:
        &#123;
            if (Change_PAWWD &#x3D;&#x3D; Menu_Mode)
            &#123;
                Menu_Interface_Status &#x3D; Interface_ChangePwd;
                Parameter.Change_Index &#x3D; 1;
            &#125;
            else if (VERIFY_PAWWD &#x3D;&#x3D; Menu_Mode)
            &#123;
                Menu_Interface_Status &#x3D; Interface_VerifyPwd;
                Parameter.Verify_Index &#x3D; 1;
            &#125;
            Clear_Cache();
            LcdClearScreen();
            break;
        &#125;
        case Interface_ChangePwd:
        &#123;
            switch(Parameter.Change_Index)
            &#123;
                case 1:
                &#123;
                    if (find_substring(ucUser_Pwd_Buff, ucPwd_In_Buff1, PWD_REAL_MAX))  &#x2F;&#x2F; 判断旧密码是否吻合
                    &#123;
                        Parameter.Change_Index &#x3D; 2;
                    &#125;  
                    else
                    &#123;
                        LcdShowStr(0, 0, &quot;  Old Password&quot;);
                        LcdShowStr(0, 1, &quot;     Error&quot;); 
                        Parameter.Change_Index &#x3D; 0;
                        Menu_Interface_Status &#x3D; Interface_ModeChoose;                       
                    &#125;                 
                    break;
                &#125;
                case 2:
                &#123;
                    Parameter.Change_Index &#x3D; 3;
                    break;
                &#125;
                case 3:
                &#123;
                    if (Compare_And_Save())
                    &#123;
                        Menu_Interface_Status &#x3D; Interface_ModeChoose;
                        LcdShowStr(0, 0, &quot;   Set Success&quot;);
                        System_MS_Delay(1200);
                    &#125;
                    else
                    &#123;
                        &#x2F;&#x2F; 错误则继续在设置密码页面
                        Menu_Interface_Status &#x3D; Interface_ChangePwd;
                        Parameter.Change_Index &#x3D; 2; &#x2F;&#x2F; 错误继续回去重新
                        Clear_Cache();
                        LcdShowStr(0, 0, &quot;    Set Fail&quot;);
                        System_MS_Delay(1200);
                    &#125;                     
                    break;
                &#125;
                default: break;
            &#125;
            Parameter.ucPassword_Cnt &#x3D; 0;
            LcdClearScreen();
            break;
        &#125;
        case Interface_VerifyPwd:
        &#123;
            switch(Parameter.Verify_Index)
            &#123;
                case 1: &#x2F;&#x2F; 无需清除数据缓存！！！
                &#123;
                    if (find_substring(ucUser_Pwd_Buff, ucPwd_In_Buff1, PWD_IN_MAX_LEN))    &#x2F;&#x2F; 判断
                    &#123;                       
                        Menu_Interface_Status &#x3D; Interface_Open; &#x2F;&#x2F; 开锁
                        Parameter.ucUNLock_Led_Flag &#x3D; TRUE; &#x2F;&#x2F; LED开始运行
                        LcdShowStr(0, 0, &quot; Password True&quot;);
                        LcdShowStr(0, 1, &quot;   Door Open&quot;); 
                        System_MS_Delay(1200);                        
                    &#125;
                    else    &#x2F;&#x2F; 密码错误，回到模式选择界面，且错误计数++
                    &#123;
                        Menu_Interface_Status &#x3D; Interface_ModeChoose;
                        Buzzer_ON();    &#x2F;&#x2F; 启动蜂鸣器
                        LcdShowStr(0, 0, &quot; Password Error&quot;);
                        System_MS_Delay(1200); 
                        Parameter.ucError_Cnt++;
                        if (Parameter.ucError_Cnt &gt;&#x3D; PWD_ERROR_MAX) &#x2F;&#x2F; 锁定系统！！！只能复位
                        &#123;
                            Buzzer_ON();    &#x2F;&#x2F; 启动蜂鸣器
                            Menu_Interface_Status &#x3D; Interface_Lock;
                        &#125;
                    &#125;
                    Clear_Cache();
                    break;
                &#125;
                default: break;
            &#125;
            LcdClearScreen();
            LcdClearScreen();
            break;
        &#125;
        default: break;
    &#125;
&#125;

&#x2F;* Esc键动作函数 *&#x2F;
void KeyEscAction()
&#123;
    switch (Input_Status)
    &#123;
    case ENTER_PWD: &#x2F;&#x2F;输入密码状态时，清空当前输入以重新开始
    &#123;
        if (1 &#x3D;&#x3D; Parameter.Verify_Index)
        &#123;
            LcdClearScreen();
            LcdShowStr(0, 0, &quot;Input Password&quot;);
            Clear_Cache();
        &#125;
        break;
    &#125;
    case SET_PWD: &#x2F;&#x2F;设置密码状态时，清空当前输入以重新开始
    &#123;
        LcdClearScreen();
        if (1 &#x3D;&#x3D; Parameter.Change_Index)
        &#123;
            LcdShowStr(0, 0, &quot;Old Password&quot;);
            
        &#125;
        else if (2 &#x3D;&#x3D; Parameter.Change_Index)
        &#123;
            LcdShowStr(0, 0, &quot;new Password&quot;);
        &#125;
        FillMemory(ucPwd_In_Buff1, &#39;\0&#39;, PWD_IN_MAX_LEN);
        Parameter.ucPassword_Cnt &#x3D; 0;
        break;        
    &#125;
    case AGAIN_PWD: &#x2F;&#x2F;设置密码确认状态时，清空输入并返回密码设置状态
    &#123;
        LcdClearScreen();
        if ((3 &#x3D;&#x3D; Parameter.Change_Index) || (2 &#x3D;&#x3D; Parameter.PowerOn_Index))
        &#123;
            LcdShowStr(0, 0, &quot;  Set Again&quot;);
        &#125;
        FillMemory(ucPwd_In_Buff2, &#39;\0&#39;, PWD_IN_MAX_LEN);
        Parameter.ucPassword_Cnt &#x3D; 0;        
        break;        
    &#125;
    default: break;
    &#125;
&#125;

&#x2F;*
* @function: Hardware_Init
* @param: None
* @retval: None
* @brief: 硬件初始化
*&#x2F;
void Hardware_Init(void)
&#123;
    uint8_t Flag &#x3D; &#39;1&#39;;
    EA &#x3D; 1;           &#x2F;&#x2F;开总中断
    ConfigTimer0(1);  &#x2F;&#x2F;配置T0定时1ms
    InitLcd1602();    &#x2F;&#x2F;初始化液晶
    Led_Init(); &#x2F;&#x2F; LED初始化
    Infrared_Init();    &#x2F;&#x2F; 红外初始化

#ifdef USE_POWER_ON
    EEPROM_Write(&amp;Flag,PSW_FLAG_ADDR,1);
#endif 

#ifdef USE_RESET_PWD 
    EEPROM_Write(ucUser_Pwd_Buff, PWD_SAVE_ADDR, PWD_REAL_MAX); &#x2F;&#x2F; 密码存储
#endif

    EEPROM_Read(&amp;Flag,PSW_FLAG_ADDR,1); &#x2F;&#x2F; 读取标志位

    if (Power_FLAG &#x3D;&#x3D; Flag)    &#x2F;&#x2F; 不是首次上电
    &#123;
        Menu_Interface_Status &#x3D; Interface_ModeChoose;
        EEPROM_Read(ucUser_Pwd_Buff,PWD_SAVE_ADDR,PWD_REAL_MAX);    &#x2F;&#x2F; 读取密码
    &#125;
    else
    &#123;
        &#x2F;&#x2F; 设置密码
        Menu_Interface_Status &#x3D; Interface_PowerOn;
        Parameter.PowerOn_Index &#x3D; 1;
    &#125;
    Clear_Cache();
&#125;


&#x2F;* 配置并启动T0，ms-T0定时时间 *&#x2F;
void ConfigTimer0(uint16_t ms)
&#123;
    unsigned long tmp;  &#x2F;&#x2F;临时变量

    tmp &#x3D; 11059200 &#x2F; 12;      &#x2F;&#x2F;定时器计数频率
    tmp &#x3D; (tmp * ms) &#x2F; 1000;  &#x2F;&#x2F;计算所需的计数值
    tmp &#x3D; 65536 - tmp;        &#x2F;&#x2F;计算定时器重载值
    tmp &#x3D; tmp + 13;           &#x2F;&#x2F;补偿中断响应延时造成的误差
    T0RH &#x3D; (uint8_t)(tmp &gt;&gt; 8); &#x2F;&#x2F;定时器重载值拆分为高低字节
    T0RL &#x3D; (uint8_t)tmp;
    TMOD &amp;&#x3D; 0xF0;   &#x2F;&#x2F;清零T0的控制位
    TMOD |&#x3D; 0x01;   &#x2F;&#x2F;配置T0为模式1
    TH0 &#x3D; T0RH;     &#x2F;&#x2F;加载T0重载值
    TL0 &#x3D; T0RL;
    ET0 &#x3D; 1;        &#x2F;&#x2F;使能T0中断
    TR0 &#x3D; 1;        &#x2F;&#x2F;启动T0
&#125;


&#x2F;* T0中断服务函数，执行按键扫描 *&#x2F;
void InterruptTimer0() interrupt 1
&#123;
    static uint8_t Led_Cnt;
    static uint16_t Buzzer_Cnt;

    TH0 &#x3D; T0RH;  &#x2F;&#x2F;重新加载重载值
    TL0 &#x3D; T0RL;

    if (Parameter.ucUNLock_Led_Flag)
    &#123;
        Led_Cnt++;

        if (200 &#x3D;&#x3D; Led_Cnt)
        &#123;
            Led_Cnt &#x3D; 0;
            Led_Flip(LED1);
            Led_Flip(LED3);
            Led_Flip(LED5);
            Led_Flip(LED7);
        &#125;
    &#125;
    if (Parameter.Buzzer_Start_Flag)
    &#123;
        Buzzer_Cnt++;

        if (3000 &#x3D;&#x3D; Buzzer_Cnt)
        &#123;
            Buzzer_Cnt &#x3D; 0;
            Parameter.Buzzer_Start_Flag &#x3D; FALSE;
        &#125;
        BUZZER_PIN &#x3D; ~BUZZER_PIN;
    &#125;
    KeyScan();   &#x2F;&#x2F;按键扫描
&#125;

&#x2F;*
* @function: EXINT1_ISR
* @param: None
* @retval: None
* @brief: INT1中断服务函数，执行红外接收及解码
*&#x2F;
void EXINT1_ISR() interrupt 2
&#123;
    uint8_t i, j;
    uint8_t byt;
    uint16_t time;

    &#x2F;&#x2F; 接收并判定引导码的9ms低电平
    time &#x3D; Infrared_Get_Low_Time();
    if ((time &lt; 7833) || (time &gt; 8755)) &#x2F;&#x2F; 时间判定范围为8.5～9.5ms，
    &#123;                                   &#x2F;&#x2F; 超过此范围则说明为误码，直接退出
        IE1 &#x3D; 0;                        &#x2F;&#x2F; 退出前清零INT1中断标志
        return;
    &#125;
    &#x2F;&#x2F; 接收并判定引导码的4.5ms高电平
    time &#x3D; Infrared_Get_High_Time();
    if ((time &lt; 3686) || (time &gt; 4608)) &#x2F;&#x2F; 时间判定范围为4.0～5.0ms，
    &#123;                                   &#x2F;&#x2F; 超过此范围则说明为误码，直接退出
        IE1 &#x3D; 0;
        return;
    &#125;
    &#x2F;&#x2F; 接收并判定后续的4字节数据
    for (i &#x3D; 0; i &lt; 4; i++) &#x2F;&#x2F; 循环接收4个字节
    &#123;
        for (j &#x3D; 0; j &lt; 8; j++) &#x2F;&#x2F; 循环接收判定每字节的8个bit
        &#123;
            &#x2F;&#x2F; 接收判定每bit的560us低电平
            time &#x3D; Infrared_Get_Low_Time();
            if ((time &lt; 313) || (time &gt; 718)) &#x2F;&#x2F; 时间判定范围为340～780us，
            &#123;                                 &#x2F;&#x2F; 超过此范围则说明为误码，直接退出
                IE1 &#x3D; 0;
                return;
            &#125;
            &#x2F;&#x2F; 接收每bit高电平时间，判定该bit的值
            time &#x3D; Infrared_Get_High_Time();
            if ((time &gt; 313) &amp;&amp; (time &lt; 718)) &#x2F;&#x2F; 时间判定范围为340～780us，
            &#123;                                 &#x2F;&#x2F; 在此范围内说明该bit值为0
                byt &gt;&gt;&#x3D; 1;                    &#x2F;&#x2F; 因低位在先，所以数据右移，高位为0
            &#125;
            else if ((time &gt; 1345) &amp;&amp; (time &lt; 1751)) &#x2F;&#x2F; 时间判定范围为1460～1900us，
            &#123;                                        &#x2F;&#x2F; 在此范围内说明该bit值为1
                byt &gt;&gt;&#x3D; 1;                           &#x2F;&#x2F; 因低位在先，所以数据右移，
                byt |&#x3D; 0x80;                         &#x2F;&#x2F; 高位置1
            &#125;
            else &#x2F;&#x2F; 不在上述范围内则说明为误码，直接退出
            &#123;
                IE1 &#x3D; 0;
                return;
            &#125;
        &#125;
        Infrared_RX_Buff[i] &#x3D; byt; &#x2F;&#x2F; 接收完一个字节后保存到缓冲区
    &#125;
    Parameter.Infrared_RX_Flag &#x3D; TRUE; &#x2F;&#x2F; 接收完毕后设置标志
    IE1 &#x3D; 0;    &#x2F;&#x2F; 退出前清零INT1中断标志
&#125;

</code></pre>
              </div>
            </details>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20230620234723.webp" alt=""></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/num141.webp" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/ssaa1324234.png">🐟</g-emoji><span>摸鱼中</span></div></div></div><div class="author-info__name">Luckys-Yang</div><div class="author-info__description">你不懂单片机,更不懂我...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/luckys-yang?tab=repositories" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=444783764&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/weixin/" target="_blank" title="微信"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div id="welcome-info"></div><div class="item-headline"></div></div><div class="sticky_layout"></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Luckys-Yang</div><div class="footer_custom_text"><div class="github-badge"><a href="http://beian.miit.gov.cn/" target="_blank" title="粤ICP备 2022026282号-1" ), pointer;"><span class="badge-subject">粤ICP备</span><span class="badge-value bg-green">2022026282号-1</span></a></div><div class="github-badge"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44070502000559" title="44070502000559号"><span class="badge-subject"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bed.attainment.cn/img/40.png" style="float:left;" />粤公网安备</span><span class="badge-value bg-green">44070502000559号</span></a></div><div><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Frame-Hexo-blue.svg" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Theme-Butterfly-6513df.svg" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/Hosted-Vercel-brightgreen.svg" title="本站采用多线部署，次线路托管于Vercel" alt="HEXO"></a></div></div><div id="running-time" style="color: #5c5c5c;"><script>setInterval(()=>{let create_time=Math.round(new Date('3/10/2022 08:00:00').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已苟活了 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><meting-js id="8183137343" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-paw"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="https://yang5201314.cn/"><i class="fa fa-home"></i><span>主页</span></a><a class="rightMenu-item" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a><a class="rightMenu-item" href="/archives/"><i class="fa-solid fa-folder-open"></i><span>文章归档</span></a><a class="rightMenu-item" href="https://www.foreverblog.cn/go.html" target="_blank"><i class="fa fa-certificate"></i><span>虫洞</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script defer src="/js/tw_cn.js"></script><script defer src="https://cdn.staticfile.org/fancyapps-ui/4.0.27/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script defer src="https://jsd.onmicrosoft.cn/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script defer src="https://jsd.onmicrosoft.cn/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia.js"></script><div class="js-pjax"></div><script src="https://jsd.onmicrosoft.cn/npm/prismjs/prism.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async type="text/javascript" src="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/js/iziToast.min.js"></script><script>
    document.body.oncopy = function () {
        iziToast.info({
            timeout: 4000, // 关闭弹窗的时间
          // icon: 'Fontawesome', // 图标类别
            closeOnEscape: 'true', // 允许使用Esc键关闭弹窗
            transitionIn: 'bounceInLeft', // 弹窗打开动画
            transitionOut: 'fadeOutRight', // 弹窗关闭动画
            displayMode: 'replace', // 替换已经打开的弹窗
            layout: '2', // Medium模式
            position: 'topRight', // 弹窗位置
            //icon: 'fad fa-copy', // 图标类名
            iconUrl:'https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/1122star.svg',
            backgroundColor: 'rgb(179, 182, 180)', // 弹窗背景色
            title: '复制成功', // 通知标题
            message: '键盘敲烂 月薪过万' // 通知消息内容
        });
    }
</script>
<script defer type="text/javascript" src="/js/rightmenu.js"></script><script  type="text/javascript" src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script defer type="text/javascript" src="/js/IPdw.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer data-pjax src="/js/newYear.js"></script><script defer src="/js/my_aplayer.js"></script><script defer src="/js/meting.js"></script><script id="click-heart" src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '250ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>