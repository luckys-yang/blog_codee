<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>智能硬件赛项 | Luckys-Yangの小栈</title><meta name="author" content="Luckys-Yang"><meta name="copyright" content="Luckys-Yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="前言 网站  广东省职业院校学生专业技能大赛官网 [平台(]https:&#x2F;&#x2F;dev.bj-jc.com:20002&#x2F;RemoteExp&#x2F;#&#x2F;stu-exp-panel) 参考文章&#x2F;代码   https:&#x2F;&#x2F;github.com&#x2F;XiaomanChu&#x2F;AGV-Driver 语音识别模块官网 STM32定时与计数器总结 第一部分 stm32之MG995舵机+原理+程序+详解 基于STM32实现MQTT">
<meta property="og:type" content="article">
<meta property="og:title" content="智能硬件赛项">
<meta property="og:url" content="https://mdcm.yang5201314.cn/post/927d9277.html">
<meta property="og:site_name" content="Luckys-Yangの小栈">
<meta property="og:description" content="前言 网站  广东省职业院校学生专业技能大赛官网 [平台(]https:&#x2F;&#x2F;dev.bj-jc.com:20002&#x2F;RemoteExp&#x2F;#&#x2F;stu-exp-panel) 参考文章&#x2F;代码   https:&#x2F;&#x2F;github.com&#x2F;XiaomanChu&#x2F;AGV-Driver 语音识别模块官网 STM32定时与计数器总结 第一部分 stm32之MG995舵机+原理+程序+详解 基于STM32实现MQTT">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mdcm.yang5201314.cn/img/num103.webp">
<meta property="article:published_time" content="2022-11-17T10:43:00.000Z">
<meta property="article:modified_time" content="2022-12-04T04:04:14.000Z">
<meta property="article:author" content="Luckys-Yang">
<meta property="article:tag" content="牛逼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mdcm.yang5201314.cn/img/num103.webp"><link rel="shortcut icon" href="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp"><link rel="canonical" href="https://mdcm.yang5201314.cn/post/927d9277.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"MSZRRKNRKT","apiKey":"71e2a5ac35435ee76602cd55d727e5ff","indexName":"aaa","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '智能硬件赛项',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-04 12:04:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/rightmenu.css" media="all" onload="this.media='all'"><link rel="preconnect" href="https://s1.hdslb.com/" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/regular.css" media="all" onload="this.media='all'" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css" media="all" onload="this.media='all'" /><link rel="shortcut icon" href="#"><link href="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/css/all.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/my.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css" ><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/css/iziToast.min.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/aplayer.css" media="all" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><style>css-doodle {--color: @p(#51eaea, #fffde1, #ff9d76, #FB3569);--rule: (:doodle {@grid: 30x1 / 18vmin;--deg: @p(-180deg, 180deg);}:container {perspective: 30vmin;}:after, :before {content: '';background: var(--color); @place-cell: @r(100%) @r(100%); @size: @r(6px); @shape: heart;} @place-cell: center; @size: 100%;box-shadow: @m2(0 0 50px var(--color));background: @m100(radial-gradient(var(--color) 50%, transparent 0)@r(-20%, 120%) @r(-20%, 100%) / 1px 1px no-repeat); will-change: transform, opacity; animation: scale-up 12s linear infinite; animation-delay: calc(-12s / @I * @i); @keyframes scale-up { 0%, 95.01%, 100% {transform: translateZ(0) rotate(0);opacity: 0;}10% {opacity: 1;}95% {transform: translateZ(35vmin) rotateZ(@var(--deg));}})}</style><css-doodle use="var(--rule)"></css-doodle><script async="async" src="https://cdn.bootcdn.net/ajax/libs/css-doodle/0.32.2/css-doodle.min.js"></script></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">136</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-list-alt"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/bookmarking/"><i class="fa-fw fas fa-star"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-pen"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info-circle"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav class="fixed" id="nav"><span id="blog-info"><a href="/" title="Luckys-Yangの小栈"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/light.png"/></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-list-alt"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/bookmarking/"><i class="fa-fw fas fa-star"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-pen"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info-circle"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">智能硬件赛项</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-17T10:43:00.000Z" title="发表于 2022-11-17 18:43:00">2022-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-04T04:04:14.000Z" title="更新于 2022-12-04 12:04:14">2022-12-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%AF%94%E8%B5%9B/">比赛</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>142分钟</span></span></div></div></div><article class="post-content" id="article-container"><h2 id="前言">前言</h2>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>网站</p>
</div>
<p><a href="https://jnds.gdedu.gov.cn/web/index.shtml">广东省职业院校学生专业技能大赛官网</a></p>
<p>[平台(]<a href="https://dev.bj-jc.com:20002/RemoteExp/#/stu-exp-panel">https://dev.bj-jc.com:20002/RemoteExp/#/stu-exp-panel</a>)</p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>参考文章/代码</p>
</div>
<ul>
<li><a href="https://github.com/XiaomanChu/AGV-Driver">https://github.com/XiaomanChu/AGV-Driver</a></li>
<li><a href="http://www.icroute.com/web_cn/DownLoad.html#">语音识别模块官网</a></li>
<li><a href="https://blog.csdn.net/weixin_46430043/article/details/125815328">STM32定时与计数器总结 第一部分</a></li>
<li><a href="https://blog.csdn.net/qq_45941706/article/details/108951250?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mg995%E8%88%B5%E6%9C%BAstm32&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-108951250.nonecase&amp;spm=1018.2226.3001.4187">stm32之MG995舵机+原理+程序+详解</a></li>
<li><a href="https://blog.csdn.net/qq_39785798/article/details/80765716">基于STM32实现MQTT</a></li>
<li><a href="https://blog.csdn.net/Born_toward/article/details/123496478">ST-Link usb communication error 解决方法</a></li>
<li><a href="https://blog.csdn.net/m0_57585228/article/details/124520911">【STM32标准库】【基础知识】外部中断</a></li>
</ul>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>在线工具</p>
</div>
<ul>
<li><a href="https://www.23bei.com/tool/749.html">赫兹Hz,秒s等常见频率,周期单位转换在线计算器</a></li>
</ul>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>官方资料</p>
</div>
<ul>
<li>2021-2022 智能硬件应用开发赛项竞赛规程</li>
<li>智能硬件应用开发平台（使用说明书）型号：JC-IHAP-V1.0</li>
<li>智能硬件应用开发平台（安装说明书）型号：JC-IHAP-V1.0</li>
<li>智能硬件应用开发平台（AGV小车安装说明书）型号：JC-IHAP-V1.0</li>
<li>2020-2021年度广东省职业院校技能大赛高职组智能硬件应用开发赛项样题</li>
<li>智能硬件应用平台高职-系统方案介绍</li>
<li>沙盘启动说明文档</li>
<li>垃圾分类沙盘总体说明</li>
<li>垃圾桶控制说明</li>
</ul>
<p>所用手册资料+思维导图XMind 阿里云网盘：<a href="https://www.aliyundrive.com/s/Xj1tqTZn9je">https://www.aliyundrive.com/s/Xj1tqTZn9je</a></p>
<h2 id="图片">图片</h2>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221108003215.png","alt":" "},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221108003234.png","alt":" "},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221108003244.png","alt":" "},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221108003253.png","alt":" "},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/QQ截图20221108003302.png","alt":" "}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<h2 id="智能硬件小车总体流程图">智能硬件小车总体流程图</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221107233606.jpg" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221107233632.png" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221108002630.png" alt=" "></p>
<h2 id="需要安装的软件">需要安装的软件</h2>
<ul>
<li>Keil uVision5 MDK + stm32F4芯片包</li>
<li>Altium Designer 20(看原理图用)</li>
<li>待补充</li>
</ul>
<h2 id="小车信息-JC-SC">小车信息(JC-SC)</h2>
<table>
<thead>
<tr>
<th style="text-align:center">组成</th>
<th style="text-align:left">具体参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">底盘</td>
<td style="text-align:left">① 尺寸 400×307×123mm； <br>② 颜色：蓝； <br>③ 负载能力：10kg；<br>④ 底盘高度：21.5mm</td>
</tr>
<tr>
<td style="text-align:center">麦克纳姆轮</td>
<td style="text-align:left">① 直径：100mm； ② 轴向宽度：50mm； <br>③ 板数：2； ④ 滚轮数：9； <br>⑤ 材质：铝合金；⑥ 净重：0.4kg；⑦ 负载能力：15kg。</td>
</tr>
<tr>
<td style="text-align:center">联轴器</td>
<td style="text-align:left">① 规格：6mm 内径；<br> ② 材质：铝合金。</td>
</tr>
<tr>
<td style="text-align:center">电机</td>
<td style="text-align:left">① 工作电压：12v；② 额定功率：17w；<br>③ 空载转速：8100rpm；④ 减速比：64:1； <br>⑤ 输出轴：6mm D 型</td>
</tr>
<tr>
<td style="text-align:center">编码器</td>
<td style="text-align:left">① 类型：A/B 相增量式磁编码器；<br>② 线数：12；<br>③ 供电电压：5V。</td>
</tr>
<tr>
<td style="text-align:center">机械臂/机械手</td>
<td style="text-align:left">① 机械臂：三自由度高精度步进驱动机械臂，前伸距离：442mm，缩回距离：254mm，最高 点： 322mm，最低点：-159mm；<br>② 配备高精密 42 行星减速步进电机，减速比：1:10；<br>③  电机驱动电压：12V；④ 工作最大电流：4.5A；<br>⑤ 机械手最大尺寸：53mm，5V 舵机驱动</td>
</tr>
<tr>
<td style="text-align:center">电机驱动</td>
<td style="text-align:left">① 控制板：额定输入电压：DC 12V/24V；② 输出通道数：4 路；③ 每路额定输出电流：7A；④ 额定输出功率：84W(12V 供电)；⑤ 控制信号电压：3～6.5V；⑥ PWM 频率范围：0～10kHz</td>
</tr>
<tr>
<td style="text-align:center">超声波模块</td>
<td style="text-align:left">① 工作电压：DC5V；② 工作电流：15mA；<br>③ 工作频率：40kHz；④ 最远射程：4m；最近射程：2cm；<br>⑤ 测量角度：15 度。</td>
</tr>
<tr>
<td style="text-align:center">磁导航传感模块</td>
<td style="text-align:left">① 检测极性：SorN；<br>② 输入电压：9~28V；<br>③ 输出方式：NPN-OC&amp;RS232。</td>
</tr>
<tr>
<td style="text-align:center">串口无线通信模块</td>
<td style="text-align:left">芯片 SI4438，工作频率：425~525MHZ；</td>
</tr>
<tr>
<td style="text-align:center">锂 离 子聚 合物 电 池 组</td>
<td style="text-align:left">电 池 组 :12.8V 8000mAh；</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221111004157.png" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221111004220.png" alt=" "></p>
<table>
<thead>
<tr>
<th style="text-align:center">机械臂组成</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">采用芯片</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">底盘</td>
<td style="text-align:center">用于机械臂的左右转动，在底盘的前方有一个位置传感器，用于底盘初始位置的校准定位</td>
<td style="text-align:center">采用42步进电机加减速装置运动的，控制方式是给一个脉冲转动一定的角度，所以只要不丢步，运行的位置是确定的(前提是上电后执行位置初始化)</td>
</tr>
<tr>
<td style="text-align:center">大臂</td>
<td style="text-align:center">用于前后转动，在大臂上有一个位置传感器，用于大臂的初始位置的定位</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">小臂</td>
<td style="text-align:center">用于上下转动，在小臂上有一个位置传感器，用于小臂的初始位置的定位</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">舵机夹子</td>
<td style="text-align:center">夹取物品</td>
<td style="text-align:center">使用舵机控制的，舵机采用PWM占空比驱动，PWM占空比决定了夹子的位置，所以不需要上电校准，只要上电后保持最大张开角就可以</td>
</tr>
<tr>
<td style="text-align:center">激光测距板</td>
<td style="text-align:center">能够探测前面物体的距离，用于检测夹子前面是否有物块，左右移动机械臂来找准物块</td>
<td style="text-align:center">/</td>
</tr>
</tbody>
</table>
<h2 id="STM32口袋机信息-JC-SPZII">STM32口袋机信息(JC-SPZII)</h2>
<table>
<thead>
<tr>
<th>组成</th>
<th>具体参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>MCU</td>
<td><span style="color:red;">STM32F407ZG</span></td>
</tr>
<tr>
<td>LED</td>
<td>8 个单色 LED 灯，5 个LED 电源指示灯</td>
</tr>
<tr>
<td>按键</td>
<td>8 个方向圆盘电容式按键，具有震动 体感反馈；1 个电子物理按键，具有复位和开 机功能</td>
</tr>
<tr>
<td>拨码开关</td>
<td>5 位拨码开关，控制 BOOT、体感 震动等</td>
</tr>
<tr>
<td>LCD 液晶屏</td>
<td>65535 真彩，2.4 寸，分辨率： 240*320，4 线 SPI 接口</td>
</tr>
<tr>
<td>高速模拟输入</td>
<td>/</td>
</tr>
<tr>
<td>SRAM 静态内存</td>
<td>512K*16bit/1MB</td>
</tr>
<tr>
<td>以太网口</td>
<td>/</td>
</tr>
<tr>
<td>DAC 模拟输出</td>
<td>/</td>
</tr>
<tr>
<td>ADC 模拟输入</td>
<td>1 路 12bit-ADC 模拟信号采 集</td>
</tr>
<tr>
<td>TF 卡</td>
<td>标准的 SD 卡协议</td>
</tr>
<tr>
<td>TYPE-C</td>
<td>板载 TYPE-C 接口，具有烧写、调 试、仿真等功能</td>
</tr>
<tr>
<td>USB</td>
<td>USB 主从接口</td>
</tr>
<tr>
<td>供电电压</td>
<td>7～24V、1A 电源适配器；5V、 3A 的 TYPE-C</td>
</tr>
<tr>
<td>GPIO 接口</td>
<td>可用 GPIO 共60pin</td>
</tr>
<tr>
<td>音频</td>
<td>集有高质量的立体双声道</td>
</tr>
</tbody>
</table>
<h2 id="智能分拣线信息-JC-IGSP">智能分拣线信息(JC-IGSP)</h2>
<table>
<thead>
<tr>
<th style="text-align:center">组成</th>
<th>具体参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">环形输送线</td>
<td>① 柔性链板输送线参数；长 1500 宽 450 高<br>② 250 12V 直流电机驱动。<br>③ 柔性链板输送线组成；由主动轮、被动轮、铝合金支架、铝合金导轨、衬条及护栏组成。</td>
</tr>
<tr>
<td style="text-align:center">图像采集</td>
<td>① 工业相机：CMOS 光学传感器尺寸 1/2.5、分辨率 2592X1944、帧率 8FPS; 柔性链板输送线参数；长 1500 宽 450 高<br>②  工业镜头焦距 8mm；<br>③ LED 环形白光光源；<br>④ 专业可调光源控制器；<br>⑤  可调式相机和光源金属支架</td>
</tr>
<tr>
<td style="text-align:center">推杆装置</td>
<td>最大尺寸：53mm，5V 舵机驱动(MG995型号)</td>
</tr>
<tr>
<td style="text-align:center">处理器</td>
<td>① GPU:128 核心 Maxwell<br>② CPU:四核 ARM A57@1.43GHZ</td>
</tr>
</tbody>
</table>
<h2 id="集中站信息-JC-ICS">集中站信息(JC-ICS)</h2>
<table>
<thead>
<tr>
<th style="text-align:center">组成</th>
<th>具体参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整体结构</td>
<td>整体架构采用铝合金框架式模块化结构,面板采用理化板。</td>
</tr>
<tr>
<td style="text-align:center">集中回收区</td>
<td>① LED 显示屏参数：供电电压 5V、LED 点阵屏,可以显示 16 个汉字（16 x 16 分辨率）<br>②  仓库尺寸：1550 x 300 x 450（mm）<br>③  含四个门、能够自动开启<br>④ 每个仓库门采用模拟舵机控制<br>⑤ 地图尺寸： 2000mm x 3000mm，采用 PVC 地板加工业打印技术，构造回收系统展示情景。<br>⑥ 台面贴有 10mm 宽黑色磁引导带，采用 N 极向上方式，以便小车巡线行驶<br>⑦ 4 路舵机控制接口<br>⑧  一个 LED 点阵屏（分辨率 256 x 16）驱动接口（8080 接口）<br>⑨ 4 路 SW2812 彩灯控制接口，可以控制每个集中站垃圾箱灯的颜色和亮度<br>⑩ 板载 433MHz 的无线通讯模块，可以与其沙盘上的其他设备无线通讯</td>
</tr>
</tbody>
</table>
<h2 id="智能回收垃圾桶信息-JC-SRD">智能回收垃圾桶信息(JC-SRD)</h2>
<table>
<thead>
<tr>
<th style="text-align:center">组成</th>
<th>具体参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整体</td>
<td>① 尺寸：240 x 310 x 402mm；<br>②  重量：3.5Kg；<br>③  材料：高强度冲击 ABS；<br>④  红 外 感 应 器 ： 高 灵 敏 度 , 延 时 时 间0.5-200S，可调<br>⑤ 涡轮式真空压缩机：高速涡轮式真空压缩机，转数:12v5000<br>⑥  高温自动封袋器：（横向纵向双向熔接，功率 10W）<br>⑦  称重传感器：精度 1 克<br>⑧ 内置铅酸电池：12V 2.2AH<br>⑨  适配器规格：13.8V 0.65A<br>⑩  4 路直流电机 H 桥控制输出：12V 输出，最大电流 1A，分别控制小盖的开合，大盖的开合，自动封口机械 X 轴和 Y 轴的行程，限位开关接口<br>⑪ 1 路使用 PWM 控制的电热丝加热输出接口，用于垃圾袋的封口和熔断<br>⑫ 1 路红外反射传感器接口，用于手势识别<br>⑬ 1 路红外对射传感器接口，用于检测垃圾桶中是否有垃圾袋<br>⑭ 1 路称重传感器接口，最大量程 5kg<br>⑮  板载 433MHz 的无线通讯模块，可以与其沙盘上的其他设备无线通讯</td>
</tr>
</tbody>
</table>
<h2 id="比赛须知-来自官方手册">比赛须知(来自官方手册)</h2>
<ul>
<li>比赛提供 STM32 <code>初始化及各类传感、控制、驱动和通信组件</code> 的基本驱动程序，提供标准函数调用接口和详细说明。提供各网络终端数据交互所需 MQTT 协议代码及接口调用说明</li>
<li>根据参赛队竞赛成绩排名分别设立一、二、三等奖。以各赛项实际参赛队数量为基数，一、 二、三等奖获奖比例分别为 <code>15%、25%、40%</code>（小数点后四舍五入）</li>
</ul>
<h2 id="比赛步骤">比赛步骤</h2>
<p><code>比赛步骤</code>：</p>
<p>裁判将写有数据的射频卡给选手，选手刷卡，口袋机经过读卡器读取射频卡中的任务参数。</p>
<p>比如：识别几个垃圾，全部垃圾全部扔到垃圾桶后，将全部垃圾打包然后扔到回收站中。</p>
<p><code>运行步骤</code>：</p>
<p>1．将垃圾放在传送带上，然后刷卡，传送带开始转动，同时摄像头开始识别；识别后的垃圾按照分类分别推送到托盘上</p>
<p>2．小车开始抓取托盘上的垃圾，然后扔到指定的垃圾桶中</p>
<p>3．将全部垃圾扔到垃圾桶后，全部垃圾桶开始打包垃圾</p>
<p>4．小车将打包好的垃圾扔到指定的集中站中</p>
<p>5．全部任务完成</p>
<h2 id="STM32F407ZG介绍">STM32F407ZG介绍</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221108125418.png" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221108125517.jpg" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/5e643d4f193441f4a061f10826ed203f.png" alt=" "></p>
<h2 id="口袋机部分">口袋机部分</h2>
<h3 id="口袋机调试">口袋机调试</h3>
<p>用仿真器下载程序调试，USB线插 TYPE-C 口（需要下载驱动 <code>dpinst_amd64</code>），串口调试助手需要先安装驱动（<code>CP210xVCPInstaller_x64</code>），如果串口接收没反应可把USB重新插一下</p>
<h3 id="口袋机基础模块学习">口袋机基础模块学习</h3>
<h4 id="延时函数">延时函数</h4>
<ul>
<li><code>SysTick_Config</code>函数的参数是systick重装定时器的值， <code>RCC_Clocks.HCLK_Frequency</code> 可以通过调试知道是 <code>168000000</code>，168000000/1000 = 168000;168000/168000000 = 0.001s=1ms</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************delay.h*************************&#x2F;
# include &quot;stm32f4xx.h&quot;


extern __IO uint32_t LocalTime;

void TimingDelay_Decrement(void);

void delay_Init(void);
void delay_ms(__IO uint32_t nTime);
&#x2F;*************************delay.c*************************&#x2F;
static __IO uint32_t TimingDelay;
__IO uint32_t LocalTime &#x3D; 0;

void delay_Init(void)
&#123;
	 RCC_ClocksTypeDef RCC_Clocks;
	
	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);  &#x2F;&#x2F;配置SysTick定时器时钟源为HCLK
  RCC_GetClocksFreq(&amp;RCC_Clocks);
	
	
	if (SysTick_Config(RCC_Clocks.HCLK_Frequency &#x2F; 1000))&#x2F;&#x2F;SysTick定时器每1ms中断一次
  &#123;
    &#x2F;* Capture error *&#x2F;
    while (1);
  &#125;
  NVIC_SetPriority (SysTick_IRQn, 0);             &#x2F;&#x2F;配置SysTick定时器的优先级
&#125;

void delay_ms(__IO uint32_t nTime)
&#123;
  TimingDelay &#x3D; nTime;

  while(TimingDelay !&#x3D; 0);
&#125;

void TimingDelay_Decrement(void)
&#123;
  if (TimingDelay !&#x3D; 0x00)
  &#123;
    TimingDelay--;
  &#125;
	
	LocalTime++;
&#125;</code></pre>
<h4 id="查看时钟源">查看时钟源</h4>
<p>在main函数添加下面两行代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">RCC_ClocksTypeDef     RCC_Clocks;
RCC_GetClocksFreq(&amp;RCC_Clocks);</code></pre>
<p>用ST-Link连接，打开keil调试即可看到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221109141236.jpg" alt=" "></p>
<h4 id="点阵">点阵</h4>
<table>
<thead>
<tr>
<th style="text-align:center">所用模块</th>
<th style="text-align:center">连接注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STM32模块扩展板</td>
<td style="text-align:center">插口袋机右边</td>
</tr>
<tr>
<td style="text-align:center">点阵屏模块</td>
<td style="text-align:center">背面印有P1的那边插GND，不能插反否则会烧坏模块</td>
</tr>
</tbody>
</table>
<p>硬件连接：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221110021355.jpg" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221108234740.png" alt=" "></p>
<ul>
<li>
<p>点阵模块 <code>行驱动是两片74HC138</code>, <code>列驱动是两片74Hc595芯片</code></p>
</li>
<li>
<p>74HC595芯片需要懂：</p>
</li>
</ul>
<p>是一个 <code>移位寄存器</code>，它是 <code>8位串行输入，并排输出</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221108200342.png" alt=" "></p>
<p><code>8位串行输入</code>：所谓8位串行输入，就是由8个数字组成，每一个数字占据一个位，共有8个位，像串在一起一样以一行的方式输入到蓝色方框内(蓝色框就是我们的芯片)</p>
<p><code>移位寄存</code>：它不是直接进去的，而是以 “移位” 的方式进去的，每次只移动一个数字进去，蓝色方框内最多可以移进去8个数字，也就说 74HC595移位寄存器 最多可存储8个数字，称为 “寄存”</p>
<p>绿色方框 = <code>SH_CP</code>(CLK)，移位寄存器的输入条件就是SH_CP这个引脚，当它处于 <code>高电平</code> 时，数字才能被送进74HC595；</p>
<p>蓝色圆球 = <code>ST_CP</code>(SCK)，当 “并排输出开关” 被触发时，74HC595移位寄存器里面存储的数字就会被输出出来，它不是一个一个的出来的，而是并排同时出来，称为 “并排输出”</p>
<ul>
<li>74HC138芯片要懂</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221108201821.png" alt=" "></p>
<h5 id="程序">程序</h5>
<p>由图可知P1是输入，P2是输出，故只需编程P1管脚即可，点阵是高电平亮</p>
<table>
<thead>
<tr>
<th style="text-align:center">P1管脚号</th>
<th style="text-align:center">对应扩展板管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GND</td>
<td style="text-align:center">GND</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">PA4</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">PD7</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">PA5</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">PF1</td>
</tr>
<tr>
<td style="text-align:center">悬空(可不管)</td>
<td style="text-align:center">PD12</td>
</tr>
<tr>
<td style="text-align:center">DINT</td>
<td style="text-align:center">PD14</td>
</tr>
<tr>
<td style="text-align:center">SCK</td>
<td style="text-align:center">PD15</td>
</tr>
<tr>
<td style="text-align:center">CLK</td>
<td style="text-align:center">PF14</td>
</tr>
<tr>
<td style="text-align:center">3.3V</td>
<td style="text-align:center">3.3V</td>
</tr>
</tbody>
</table>
<ul>
<li>由原理图可知 <code>D</code> 是用来区分哪一块138芯片的，当 <code>D</code> 低电平时连接 <code>u1</code>；当<code>D</code> 高电平时连接 <code>u4</code></li>
<li>一个8*8点阵从左到右是 <code>低位--&gt;高位</code>(对应1248码就是 1–2–4–8–16–32–64–128)</li>
<li>取模软件生成四个角点亮步骤：选择<code>16*16</code> — 描点(黑色表示 <code>1</code>,高电平) —<code>图像左右调换</code> — 参数设置( <code>横向取模,任何时候都加0</code>) — <code>C51格式</code> — 复制粘贴即可</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_ GPIO Init.h*************************&#x2F;

# define CLK_L		(GPIOF-&gt;BSRRH &#x3D; GPIO_Pin_14)	&#x2F;&#x2F;控制PF14输出低电平
# define CLK_H		(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_14)	&#x2F;&#x2F;控制PF14输出高电平

# define LAT_L		(GPIOD-&gt;BSRRH &#x3D; GPIO_Pin_15)	&#x2F;&#x2F;SCLK
# define LAT_H		(GPIOD-&gt;BSRRL &#x3D; GPIO_Pin_15)	&#x2F;&#x2F;SCLK

# define DIN_L		(GPIOD-&gt;BSRRH &#x3D; GPIO_Pin_14)
# define DIN_H		(GPIOD-&gt;BSRRL &#x3D; GPIO_Pin_14)


# define A_L		(GPIOF-&gt;BSRRH &#x3D; GPIO_Pin_1)
# define A_H		(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_1)

# define B_L		(GPIOA-&gt;BSRRH &#x3D; GPIO_Pin_5)
# define B_H		(GPIOA-&gt;BSRRL &#x3D; GPIO_Pin_5)

# define C_L		(GPIOD-&gt;BSRRH &#x3D; GPIO_Pin_7)
# define C_H		(GPIOD-&gt;BSRRL &#x3D; GPIO_Pin_7)

# define D_L		(GPIOA-&gt;BSRRH &#x3D; GPIO_Pin_4)
# define D_H		(GPIOA-&gt;BSRRL &#x3D; GPIO_Pin_4)

&#x2F;*************************STM32F40x_ GPIO Init.c*************************&#x2F;
&#x2F;&#x2F;端口初始化
void GPIO_init_all(void)
&#123;
	GPIO_init(GPIO_F,GPIO_Pin_14,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;CLK
	GPIO_init(GPIO_D,GPIO_Pin_15,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;SCK
	GPIO_init(GPIO_D,GPIO_Pin_14,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;DIN
	GPIO_init(GPIO_D,GPIO_Pin_12,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;悬空
	GPIO_init(GPIO_F,GPIO_Pin_1,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;A
	GPIO_init(GPIO_A,GPIO_Pin_5,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;B
	GPIO_init(GPIO_D,GPIO_Pin_7,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;C
	GPIO_init(GPIO_A,GPIO_Pin_4,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;D
&#125;

&#x2F;*************************main.c*************************&#x2F;

u8 dis_buf_test[32] &#x3D; 
&#123;0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff&#125;;	&#x2F;&#x2F;测试数据，全亮
u32 dis_count &#x3D; 0;

void dis_flash_fun(u8 *p);
void decode_138_fun(u8 row);
void hc595_out(unsigned char data);

int main(void)
&#123;
    &#x2F;&#x2F;...
    GPIO_init_all();&#x2F;&#x2F;初始化所有要使用的端口
    for(dis_count&#x3D;0;dis_count&lt;1;dis_count++)&#x2F;&#x2F;循环显示1次测试数据，测试数据是把全部LED点亮，用于测试模块，看有无坏点
	&#123;
		dis_flash_fun(dis_buf_test);
	&#125;
    while(1)
    &#123;
        
    &#125;
&#125;

&#x2F;&#x2F;扫描16*16 点阵  输入参数是 一个32字节的数组  数据依次是第一行的右边  第一行的左边 
void dis_flash_fun(u8 *p)
&#123;
	u8 i;
	u8 count;
	
	count &#x3D; 0;
	
	for(i&#x3D;0;i&lt;16;i++)
	&#123;
		decode_138_fun(i);&#x2F;&#x2F;行扫描
		
		hc595_out(*(p+count));&#x2F;&#x2F;串行输出第一个字节，给右边的8*8 LED
		count++;
		hc595_out(*(p+count));&#x2F;&#x2F;串行输出第二个字节，给左边的8*8 LED
		count++;
		
		delay_ms(1);&#x2F;&#x2F;延时1ms  使得图像停留1ms的时间  不然会扫描的太快
	&#125;
&#125;
&#x2F;&#x2F;控制两片138译码器  输入0-15  控制端口ABCD 依次高电平，实现行扫描
void decode_138_fun(u8 row)
&#123;
	switch(row)
	&#123;
		case 0:A_L;B_L;C_L;D_L;break;	&#x2F;&#x2F;000 0
		case 1:A_H;B_L;C_L;D_L;break;	&#x2F;&#x2F;100 0
		case 2:A_L;B_H;C_L;D_L;break;	&#x2F;&#x2F;010 0
		case 3:A_H;B_H;C_L;D_L;break;	&#x2F;&#x2F;110 0
		case 4:A_L;B_L;C_H;D_L;break;	&#x2F;&#x2F;001 0
		case 5:A_H;B_L;C_H;D_L;break;	&#x2F;&#x2F;101 0
		case 6:A_L;B_H;C_H;D_L;break;	&#x2F;&#x2F;011 0
		case 7:A_H;B_H;C_H;D_L;break;	&#x2F;&#x2F;111 0
		case 8:A_L;B_L;C_L;D_H;break;	&#x2F;&#x2F;000 1
		case 9:A_H;B_L;C_L;D_H;break;	&#x2F;&#x2F;100 1
		case 10:A_L;B_H;C_L;D_H;break;	&#x2F;&#x2F;010 1
		case 11:A_H;B_H;C_L;D_H;break;	&#x2F;&#x2F;110 1
		case 12:A_L;B_L;C_H;D_H;break;	&#x2F;&#x2F;001 1
		case 13:A_H;B_L;C_H;D_H;break;	&#x2F;&#x2F;101 1
		case 14:A_L;B_H;C_H;D_H;break;	&#x2F;&#x2F;011 1
		case 15:A_H;B_H;C_H;D_H;break;	&#x2F;&#x2F;111 1
		
	&#125;
&#125;
&#x2F;&#x2F;74hc595时序函数    data是要并行输出的8位数据
void hc595_out(unsigned char data)
&#123;
	unsigned char i,temp;

	for(i&#x3D;0;i&lt;8;i++)
	&#123;
		if((temp&amp;0x80)&#x3D;&#x3D;0x80)
		&#123;
			DIN_H;
		&#125;
		else
		&#123;
			DIN_L;
		&#125;
		temp &#x3D; temp&lt;&lt;1;
		CLK_H;
		CLK_L;
		LAT_H;
		LAT_L;
	&#125;
&#125;</code></pre>
<h4 id="WIFI">WIFI</h4>
<table>
<thead>
<tr>
<th style="text-align:center">所用模块</th>
<th style="text-align:center">连接注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STM32模块扩展板</td>
<td style="text-align:center">插口袋机左边</td>
</tr>
<tr>
<td style="text-align:center">WIFI模块</td>
<td style="text-align:center">模块有按键的朝右边</td>
</tr>
</tbody>
</table>
<p>硬件连接：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221110021647.jpg" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221109162323.png" alt=" "></p>
<table>
<thead>
<tr>
<th style="text-align:center">管脚号</th>
<th style="text-align:center">对应扩展板管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RST</td>
<td style="text-align:center">PG13</td>
</tr>
<tr>
<td style="text-align:center">RX</td>
<td style="text-align:center">PD2(USART5)</td>
</tr>
<tr>
<td style="text-align:center">TX</td>
<td style="text-align:center">PC12(USART5)</td>
</tr>
</tbody>
</table>
<p>wifi模块的使用步骤是：（都是使用AT命令实现的）<br>
① 关闭回显<br>
② 设置模式<br>
③ 连接路由器<br>
④ 连接服务器<br>
⑤ 发送数据</p>
<ul>
<li>首先在手机开热点，热点名和密码记住，在代码里填写(注意数组大小也要改)</li>
<li>打开网络适配器查看IP，代码里电脑端那填 <code>IPv4地址</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221109210611.jpg" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221109232110.jpg" alt=" "></p>
<ul>
<li>注意命令里&quot;&quot;内容是用反斜杠 <code>\</code> 隔着的(数组大小不包括它)</li>
<li>单片机给wifi模组发送AT指令后， <code>需要稍微延时</code> 等待wifi模组应答，读的太快会读不到wifi应答的AT指令，会达不到研发要求</li>
<li>回显的含义是：发送什么指令，返回给你结果的时候，会把发送的指令再显示一遍</li>
<li>LCD显示的自己定义的数组时需要 <code>len-2</code>(把/r/n去掉)，显示Wifi返回的数据时不需要</li>
</ul>
<h5 id="程序-2">程序</h5>
<p>ESP8266.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************ESP8266.c*************************&#x2F;
# define	CW_LEN	35		&#x2F;&#x2F; CWJAP 数组的字符串长度(不包括\)

char CWJAP[CW_LEN] &#x3D; &#123;&quot;AT+CWJAP&#x3D;\&quot;yang5201314\&quot;,\&quot;00000000\&quot;\r\n&quot;&#125;;&#x2F;&#x2F;yang5201314是WIFI的ssid  00000000是密码(手机热点)

# define	CIPSTART_LEN	39   &#x2F;&#x2F; CIPSTART数组的字符串长度(不包括\)
char CIPSTART[CIPSTART_LEN] &#x3D; &#123;&quot;AT+CIPSTART&#x3D;\&quot;TCP\&quot;,\&quot;172.20.10.7\&quot;,12345\r\n&quot;&#125;;&#x2F;&#x2F;172.20.10.7是电脑端的IP地址  12345是端口号

char CWMODE[13] &#x3D; &#123;&quot;AT+CWMODE&#x3D;1\r\n&quot;&#125;;&#x2F;&#x2F;设置模式  不用改变

char CIPMUX[13] &#x3D; &#123;&quot;AT+CIPMUX&#x3D;0\r\n&quot;&#125;;&#x2F;&#x2F; 设置模式  不用改变

char CIPSEND_5[14] &#x3D; &#123;&quot;AT+CIPSEND&#x3D;5\r\n&quot;&#125;;&#x2F;&#x2F;连接上服务器后  需要发送数据的命令  5是要发送数据的长度

char CIPSEND_9[14] &#x3D; &#123;&quot;AT+CIPSEND&#x3D;9\r\n&quot;&#125;;&#x2F;&#x2F; 连接上服务器后  需要发送数据的命令  5是要发送数据的长度

char send_buf[5] &#x3D; &#123;&quot;12345&quot;&#125;;&#x2F;&#x2F;要发送的数据

char GOT_IP[6] &#x3D; &#123;&quot;GOT IP&quot;&#125;;&#x2F;&#x2F;定义一个数组

char OK_buf[2] &#x3D; &#123;&quot;OK&quot;&#125;;&#x2F;&#x2F;定义一个数组

char http_race_buf[20];&#x2F;&#x2F;收到服务器返回的数据

char get_time_cmd_buf[9] &#x3D; &#123;&quot;get time;&quot;&#125;;&#x2F;&#x2F;向服务器发送 获取时间命令


extern char usart5_race_buf[100];&#x2F;&#x2F;串口5 接收数组
extern u16 usart5_race_count;		&#x2F;&#x2F;串口5接收数据计数


&#x2F;&#x2F;关闭回显
u8 ATE_fun(void)
&#123;
	u8 temp;
	
    &#x2F;&#x2F;串口5 向WIFI模块 发送ATE0 命令
	Uart5_send_data(&quot;ATE0\r\n&quot;,6);													&#x2F;&#x2F;串口1 给电脑也发送
	Usart1_send_data(&quot;ATE0\r\n&quot;,6);													&#x2F;&#x2F;口袋机屏幕显示
	LCD_ShowString_stm32_send(&quot;ATE0\r\n&quot;,4);	
    &#x2F;&#x2F;延时
	delay_ms(500);
    &#x2F;&#x2F;串口1 发送 串口5收到的数据（wifi模块返回的数据）
	Usart1_send_data(usart5_race_buf,usart5_race_count);	
    &#x2F;&#x2F;屏幕显示 wifi模块返回的数据
	LCD_ShowString_stm32_race(usart5_race_buf);							
	&#x2F;&#x2F;串口5再发送一次ATE0  有时候第一次发送回有问题
	Uart5_send_data(&quot;ATE0\r\n&quot;,6);													&#x2F;&#x2F;串口1给电脑发送ATE0
	Usart1_send_data(&quot;ATE0\r\n&quot;,6);													&#x2F;&#x2F;延时
	delay_ms(500);	
    &#x2F;&#x2F;串口1发送  wifi模块返回的数据
	Usart1_send_data(usart5_race_buf,usart5_race_count);
    &#x2F;&#x2F;屏幕显示
	LCD_ShowString_stm32_race(usart5_race_buf);							
	&#x2F;&#x2F;检查usart5_race_buf数组中  是否有OK 字符
	temp &#x3D; chack_have_fun(OK_buf,2,usart5_race_buf,30);			
	if(temp&#x3D;&#x3D;1)&#x2F;&#x2F;有 说明ATE0 设置成功
	&#123;
		printf(&quot;ATE-ok\r\n&quot;);
		return 1;
	&#125;
	else
	&#123;
		printf(&quot;ATE-error\r\n&quot;);
		return 0;
	&#125;
	
&#125;
&#x2F;&#x2F;连接WIFI
u8 CWJAP_fun(void)
&#123;
	u8 temp;
    
	&#x2F;&#x2F;发送连接路由器命令   CWJAP 是要发送的数组
	Uart5_send_data(CWJAP,CW_LEN);
    &#x2F;&#x2F;同时也给电脑串口发送
	Usart1_send_data(CWJAP,CW_LEN);	
    &#x2F;&#x2F;屏幕显示
	LCD_ShowString_stm32_send(CWJAP,CW_LEN-2);	
    &#x2F;&#x2F;延时10秒   有时候时间比较长
	delay_ms(20000);														
	&#x2F;&#x2F;串口1 向电脑发送  wifi模块返回的数据
	Usart1_send_data(usart5_race_buf,usart5_race_count);
    &#x2F;&#x2F;屏幕显示wifi模块返回的数据
	LCD_ShowString_stm32_race(usart5_race_buf);						
	&#x2F;&#x2F;判断 usart5_race_buf 收到的数据中 是否有GOT_IP 字符串
	temp &#x3D; chack_have_fun(GOT_IP,6,usart5_race_buf,30);		
	
	if(temp&#x3D;&#x3D;1)&#x2F;&#x2F;连接路由器成功
	&#123;
		printf(&quot;WIFI_link_ok\r\n&quot;);
		return 1;
	&#125;
	else
	&#123;
		printf(&quot;WIFI_link_error\r\n&quot;);
		return 0;
	&#125;
&#125;
&#x2F;&#x2F;设置模式  wifi 模块初始化
u8 CWMODE_fun(void)
&#123;
	u8 temp;
	
	Uart5_send_data(CWMODE,13);
	Usart1_send_data(CWMODE,13);
	LCD_ShowString_stm32_send(CWMODE,11);
	delay_ms(1000);
	
	Usart1_send_data(usart5_race_buf,usart5_race_count);
	LCD_ShowString_stm32_race(usart5_race_buf);
	
	temp &#x3D; chack_have_fun(OK_buf,2,usart5_race_buf,30);
	if(temp&#x3D;&#x3D;1)
	&#123;
		return 1;
	&#125;
	else
	&#123;
		return 0;
	&#125;
	
&#125;


&#x2F;&#x2F;设置模式  wifi模块初始化  一般不用修改
u8 CIPMUX_fun(void)
&#123;
	u8 temp;
	
	Uart5_send_data(CIPMUX,13);
	Usart1_send_data(CIPMUX,13);
	LCD_ShowString_stm32_send(CIPMUX,11);
	delay_ms(1000);
	
	Usart1_send_data(usart5_race_buf,usart5_race_count);
	LCD_ShowString_stm32_race(usart5_race_buf);
	
	temp &#x3D; chack_have_fun(OK_buf,2,usart5_race_buf,30);
	if(temp&#x3D;&#x3D;1)
	&#123;
		return 1;
	&#125;
	else
	&#123;
		return 0;
	&#125;
&#125;
&#x2F;&#x2F;发送域名和端口  连接服务器
u8 CIPSTART_fun(void)
&#123;
	u8 temp;
	
    &#x2F;&#x2F; 连接的域名和端口在CIPSTART数组中  上面有定义
	Uart5_send_data(CIPSTART,CIPSTART_LEN);
	Usart1_send_data(CIPSTART,CIPSTART_LEN);
    &#x2F;&#x2F;屏幕显示
	LCD_ShowString_stm32_send(CIPSTART,CIPSTART_LEN-2);	
	delay_ms(5000);
	&#x2F;&#x2F;串口1 发送 wifi模块返回的数据
	Usart1_send_data(usart5_race_buf,usart5_race_count);
    &#x2F;&#x2F;屏幕显示
	LCD_ShowString_stm32_race(usart5_race_buf);					
	&#x2F;&#x2F;检查usart5_race_buf wifi模块返回的数据中  是否有 OK 字符串
	temp &#x3D; chack_have_fun(OK_buf,2,usart5_race_buf,30);	
	if(temp&#x3D;&#x3D;1)&#x2F;&#x2F;连接成功
	&#123;
		return 1;
	&#125;
	else
	&#123;
		return 0;
	&#125;
&#125;
&#x2F;&#x2F;向服务器发送数据
u8 CIPSEND_fun(void)
&#123;
	u8 temp;
    
	&#x2F;&#x2F;发送CIPSEND_5 命令  定义在最上面
	Uart5_send_data(CIPSEND_5,14);		
    &#x2F;&#x2F;串口1也发送  用于串口监测
	Usart1_send_data(CIPSEND_5,14);		
    &#x2F;&#x2F;屏幕显示
	LCD_ShowString_stm32_send(CIPSEND_5,12);
    &#x2F;&#x2F;延时5秒
	delay_ms(5000);																	&#x2F;&#x2F;串口1 显示 wifi模块返回的数据
	Usart1_send_data(usart5_race_buf,usart5_race_count);
    &#x2F;&#x2F;屏幕显示wifi 返回的数据
	LCD_ShowString_stm32_race(usart5_race_buf);						
	&#x2F;&#x2F;监测usart5_race_buf 数组（wifi模块返回的数据）中 是否有OK 字符串
	temp &#x3D; chack_have_fun(OK_buf,2,usart5_race_buf,30);		
	&#x2F;&#x2F;向服务器发送数据  send_buf就是要发送的数组  发送5个字节  send_buf在上面有定义
	Uart5_send_data(send_buf,5);													&#x2F;&#x2F;延时1秒
	delay_ms(1000);																	&#x2F;&#x2F;串口打印 返回的数据
	Usart1_send_data(usart5_race_buf,usart5_race_count);
    &#x2F;&#x2F;屏幕显示返回的数据
	LCD_ShowString_stm32_race(usart5_race_buf);						
	&#x2F;&#x2F;监测usart5_race_buf数组 wifi模块返回的数据中有无 OK 字符串
	temp &#x3D; chack_have_fun(OK_buf,2,usart5_race_buf,30);		
	if(temp&#x3D;&#x3D;1)
	&#123;
		return 1;
	&#125;
	else
	&#123;
		return 0;
	&#125;
&#125;
&#x2F;&#x2F;检查数组中有无字符串  没有返回0  有就返回位置数据
u8 chack_have_fun(char *flr, u8 len, char *buf, u16 mun)
&#123;
	u8 i;
	u16 j;
	
	u8 temp;

	for(j&#x3D;0;j&lt;mun-len+1;j++)
	&#123;
		temp &#x3D; 0;
		for(i&#x3D;0;i&lt;len;i++)
		&#123;
			if(*flr&#x3D;&#x3D;*buf)
			&#123;
				temp++;
			&#125;
			flr++;
			buf++;
		&#125;
		flr &#x3D; flr - len;
		buf &#x3D; buf - len;
		buf++;
		if(temp&#x3D;&#x3D;len)
		&#123;
			return 1;
		&#125;
	&#125;
	return 0;
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
int main(void)
&#123;
    &#x2F;&#x2F;...
	RST_L;	&#x2F;&#x2F;Wifi复位键拉低
	delay_ms(10);
	RST_H;	&#x2F;&#x2F;Wifi复位键拉高
    delay_ms(3000);	&#x2F;&#x2F;延时3s
    
    Uart5_Init();&#x2F;&#x2F;串口5  与wifi模块连接
    ATE_fun();&#x2F;&#x2F;关闭串口回显
    CWJAP_fun();&#x2F;&#x2F;连接WIFI
	CWMODE_fun();&#x2F;&#x2F;设置模式
	CIPMUX_fun();&#x2F;&#x2F;设置模式
	CIPSTART_fun();&#x2F;&#x2F;连接服务器
    
    while(1)
    &#123;
        CIPSEND_fun();&#x2F;&#x2F;发送数据给服务器
		delay_ms(5000);
    &#125;
    
&#125;</code></pre>
<h4 id="语音识别">语音识别</h4>
<table>
<thead>
<tr>
<th style="text-align:center">所用模块</th>
<th style="text-align:center">连接注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STM32模块扩展板</td>
<td style="text-align:center">插口袋机右边</td>
</tr>
<tr>
<td style="text-align:center">语音识别模块</td>
<td style="text-align:center">模块话筒在左上角边</td>
</tr>
</tbody>
</table>
<p>硬件连接：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221110122352.jpg" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221110122736.jpg" alt=" "></p>
<table>
<thead>
<tr>
<th style="text-align:center">管脚号</th>
<th style="text-align:center">对应扩展板管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CLK(SPI时钟)</td>
<td style="text-align:center">PA4</td>
</tr>
<tr>
<td style="text-align:center">MOSI(SPI数据输入)</td>
<td style="text-align:center">PD7</td>
</tr>
<tr>
<td style="text-align:center">MISO(SPI数据输出)</td>
<td style="text-align:center">PA5</td>
</tr>
<tr>
<td style="text-align:center">CS(SPI片选)</td>
<td style="text-align:center">PF1</td>
</tr>
<tr>
<td style="text-align:center">RST(复位)</td>
<td style="text-align:center">PD12</td>
</tr>
<tr>
<td style="text-align:center">INT(中断输出)</td>
<td style="text-align:center">PD14</td>
</tr>
</tbody>
</table>
<ul>
<li>语音识别芯片采用LD3320，与口袋机SPI接口通讯，外接麦克风，外接晶振；通过SPI接口设置LD3320进行初始化和语音识别库的设置，完成特定语音识别</li>
<li>每次识别最多可以设置 <code>50项候选识别句</code>，每个识别句可以是 <code>单字，词组或短句</code>，长度为 <code>不超过10个汉字或者79个字节的拼音串</code></li>
</ul>
<p>语音播放MP3文件，需要把MP3文件16进制做成数组(MP3分有ID3头跟无ID3头，这两者不会有影响)</p>
<p>可以用16进制阅读器（比如 <code>UltraEdit</code>(软件+破解在阿里云盘) ）打开mp3文件和数组相对照</p>
<h5 id="程序-3">程序</h5>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
u8 INT_flag &#x3D; 1;	&#x2F;&#x2F;上电触发中断

extern u8 nAsrStatus;
extern u8 nLD_Mode;



&#x2F;&#x2F;所有中断线都在这，这里只用到14
void EXTI15_10_IRQHandler(void)
&#123;
	if(EXTI_GetITStatus(EXTI_Line10) !&#x3D; RESET)
	&#123;
		EXTI_ClearITPendingBit(EXTI_Line10);
	&#125;
	
	if(EXTI_GetITStatus(EXTI_Line11) !&#x3D; RESET)
	&#123;
		EXTI_ClearITPendingBit(EXTI_Line11);
	&#125;
	if(EXTI_GetITStatus(EXTI_Line12) !&#x3D; RESET)
	&#123;
		EXTI_ClearITPendingBit(EXTI_Line12);
	&#125;
	
	if(EXTI_GetITStatus(EXTI_Line13) !&#x3D; RESET)
	&#123;
		EXTI_ClearITPendingBit(EXTI_Line13);
	&#125;
	
	if(EXTI_GetITStatus(EXTI_Line14) !&#x3D; RESET)
	&#123;
		&#x2F;&#x2F;printf(&quot;INT\r\n&quot;);
		EXTI_ClearITPendingBit(EXTI_Line14);
		INT_flag &#x3D; 1;
	&#125;
	
	if(EXTI_GetITStatus(EXTI_Line15) !&#x3D; RESET)
	&#123;
		EXTI_ClearITPendingBit(EXTI_Line15);
	&#125;
&#125;




u8 test_u8;
int main(void)
&#123;
    LCD_ShowString(0, 0, &quot;speech recognition:&quot;, 32, TYPEFACE);
	
	GPIO_init_all();&#x2F;&#x2F;初始化用到的IO端口
	EXTIX_Init();&#x2F;&#x2F;外部中断初始化
    ld3320_reset();&#x2F;&#x2F;模块复位
	delay_ms(100);&#x2F;&#x2F;延时
	
	while(ld3320_check())&#x2F;&#x2F;检查模块通讯是否正常
	&#123;
		printf(&quot;LD3320 Error!!\r\n&quot;);&#x2F;&#x2F;串口打印错误
		delay_ms(500);
	&#125;
	printf(&quot;LD3320 OK!!\r\n&quot;);&#x2F;&#x2F;串口打印正常
    
    ld3320_init_asr();&#x2F;&#x2F;模块设置ASR寄存器
	ld3320_asr_addFixed();&#x2F;&#x2F;添加识别关键词语
	test_u8 &#x3D; ld3320_read_reg(0xBF);&#x2F;&#x2F;看是否是31
	test_u8 &#x3D; ld3320_asrun();&#x2F;&#x2F;
	nAsrStatus &#x3D; LD_ASR_NONE;		&#x2F;&#x2F;	初始状态：没有在作ASR
	nLD_Mode &#x3D; LD_MODE_ASR_RUN;&#x2F;&#x2F;
    
    while(1)
    &#123;
        if(INT_flag)&#x2F;&#x2F;判断是否有中断
		&#123;
			INT_flag &#x3D; 0;&#x2F;&#x2F;中断标志清零
			
			ld3320_process_init();&#x2F;&#x2F;初始化
			
			test_u8 &#x3D; LD_GetResult();&#x2F;&#x2F;查看识别结果
			printf(&quot;test_u8 &#x3D; %02x\r\n&quot;,test_u8);&#x2F;&#x2F;串口打印
			
			LCD_Draw_Rect_Win(0,32,32,32,BACKGROND);&#x2F;&#x2F;在对应的位置清屏变成蓝色
			LCD_ShowNum(0,32,test_u8,1,32,TYPEFACE);&#x2F;&#x2F;显示识别的结果   显示0-5之间的数字
			
			
			ld3320_init_asr();&#x2F;&#x2F;初始化
			ld3320_asr_addFixed();&#x2F;&#x2F;添加识别关键词语
			test_u8 &#x3D; ld3320_read_reg(0xBF);&#x2F;&#x2F;看是否是31
			test_u8 &#x3D; ld3320_asrun();&#x2F;&#x2F;
			nAsrStatus &#x3D; LD_ASR_NONE;		&#x2F;&#x2F;	初始状态：没有在作ASR
			nLD_Mode &#x3D; LD_MODE_ASR_RUN;&#x2F;&#x2F;
	
		&#125;
    &#125;
    
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_GPIO_Init.c*************************&#x2F;
void GPIO_init_all(void)
&#123;
   GPIO_init(GPIO_D,GPIO_Pin_14,GPIO_Mode_IN,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;D14
   GPIO_init(GPIO_D,GPIO_Pin_12,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;D12
GPIO_init(GPIO_F,GPIO_Pin_1,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;F1
	GPIO_init(GPIO_A,GPIO_Pin_5,GPIO_Mode_IN,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;A5
	GPIO_init(GPIO_D,GPIO_Pin_7,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;D7
	GPIO_init(GPIO_A,GPIO_Pin_4,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;A4
&#125;</code></pre>
<p>LD3320.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;	以下三个状态定义用来记录程序是在运行ASR识别还是在运行MP3播放
# define LD_MODE_IDLE		0x00
# define LD_MODE_ASR_RUN		0x08
# define LD_MODE_MP3		 	0x40


&#x2F;&#x2F;	以下五个状态定义用来记录程序是在运行ASR识别过程中的哪个状态
# define LD_ASR_NONE				0x00	&#x2F;&#x2F;	表示没有在作ASR识别
# define LD_ASR_RUNING			0x01	&#x2F;&#x2F;	表示LD3320正在作ASR识别中
# define LD_ASR_FOUNDOK			0x10	&#x2F;&#x2F;	表示一次识别流程结束后，有一个识别结果
# define LD_ASR_FOUNDZERO 		0x11	&#x2F;&#x2F;	表示一次识别流程结束后，没有识别结果
# define LD_ASR_ERROR	 		0x31	&#x2F;&#x2F;	表示一次识别流程中LD3320芯片内部出现不正确的状态


# define CLK_IN   		   24	&#x2F;&#x2F;用户需要根据时钟修改这个值
# define LD_PLL_11			(u8)((CLK_IN&#x2F;2.0)-1)
# define LD_PLL_MP3_19		0x0f
# define LD_PLL_MP3_1B		0x18
# define LD_PLL_MP3_1D   	(u8)(((90.0*((LD_PLL_11)+1))&#x2F;(CLK_IN))-1)

# define LD_PLL_ASR_19 		(u8)(CLK_IN*32.0&#x2F;(LD_PLL_11+1) - 0.51)
# define LD_PLL_ASR_1B 		0x48
# define LD_PLL_ASR_1D 		0x1f

&#x2F;&#x2F; LD芯片固定值
# define        RESUM_OF_MUSIC               0x01
# define        CAUSE_MP3_SONG_END           0x20

# define        MASK_INT_SYNC				0x10
# define        MASK_INT_FIFO				0x04
# define    	   MASK_AFIFO_INT				0x01
# define        MASK_FIFO_STATUS_AFULL		0x08

# define MIC_VOL   0x55  &#x2F;&#x2F;值越小代表MIC音量越小
# define YUYIN_MAX	5	&#x2F;&#x2F;语音语句(条)



void EXTIX_Init(void);
void ld3320_reset(void);
u8 ld3320_check(void);
u8 SPI_RW(u8 data);
u8 ld3320_read_reg(u8 add);
void ld3320_write_reg(u8 add, u8 dat);
u8 ld3320_check_asrbusyflag_b2(void);
u8 ld3320_asrun(void);
u8 ld3320_get_result(void);
u8 LD_Check_ASRBusyFlag_b2(void);
void ld3320_init_common(void);
u8 LD_GetResult(void);
void LD_Init_Common(void);
void ld3320_init_asr(void);
u8 ld3320_asr_addFixed(void);
void ld3320_process_init(void);
void LD_AsrStart(void);
u8 ld3320_run_asr(void);</code></pre>
<p>LD3320.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************LD3320.c*************************&#x2F;
&#x2F;&#x2F;枚举
typedef enum
&#123;
    nihao &#x3D; 1,
    tongxue &#x3D; 2,
    beijing &#x3D; 3,
    shanghai &#x3D; 4,
    bisai &#x3D; 5
&#125; Order;


u8 nLD_Mode;	&#x2F;&#x2F;当前模式
u32 nMp3StartPos &#x3D; 0;
u32 nMp3Pos &#x3D; 0;
u8 ucStatus;
u32 nMp3Size &#x3D; 0;

u8 ucRegVal;
u8 nAsrStatus;
u8 ucHighInt;
u8 ucLowInt;

u8 ucSPVol &#x3D; 15;

u8 bMp3Play;




&#x2F;&#x2F;D14外部中断初始化
void EXTIX_Init(void)
&#123;
    NVIC_InitTypeDef   NVIC_InitStructure;
    EXTI_InitTypeDef   EXTI_InitStructure;


    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);&#x2F;&#x2F;设置系统中断优先级分组2
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);&#x2F;&#x2F;使能SYSCFG时钟
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOD, EXTI_PinSource14);&#x2F;&#x2F;D14

    EXTI_InitStructure.EXTI_Line &#x3D; EXTI_Line14;
    EXTI_InitStructure.EXTI_Mode &#x3D; EXTI_Mode_Interrupt;&#x2F;&#x2F;中断请求
    EXTI_InitStructure.EXTI_Trigger &#x3D; EXTI_Trigger_Falling; &#x2F;&#x2F;下降沿触发
    EXTI_InitStructure.EXTI_LineCmd &#x3D; ENABLE;&#x2F;&#x2F;中断线使能
    EXTI_Init(&amp;EXTI_InitStructure);&#x2F;&#x2F;配置

    NVIC_InitStructure.NVIC_IRQChannel &#x3D; EXTI15_10_IRQn;&#x2F;&#x2F;外部中断10-15
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 0x01;&#x2F;&#x2F;抢占优先级1
    NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0x02;&#x2F;&#x2F;子优先级2
    NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;&#x2F;&#x2F;使能外部中断通道
    NVIC_Init(&amp;NVIC_InitStructure);&#x2F;&#x2F;配置
&#125;

&#x2F;&#x2F;LD3320芯片复位
void ld3320_reset(void)
&#123;
    RST_H;	&#x2F;&#x2F;复位引脚拉高
    delay_us(10);	&#x2F;&#x2F;延时
    RST_L;	&#x2F;&#x2F;复位引脚拉低
    delay_us(10);	
    RST_H;	&#x2F;&#x2F;复位引脚拉高
    delay_us(10);

    CS_L;	&#x2F;&#x2F;片选拉低
    delay_us(10);	&#x2F;&#x2F;延时
    CS_H;	&#x2F;&#x2F;片选拉高
    delay_us(10);
&#125;
&#x2F;&#x2F;模拟SPI时序    发送一个字节并  同时读取一个字节
u8 SPI_RW(u8 data)
&#123;
    u8 i;
    u8 temp;

    temp &#x3D; 0;

    for(i &#x3D; 0; i &lt; 8; i++)
    &#123;
        if((data &amp; 0x80) &#x3D;&#x3D; 0x80)		&#x2F;&#x2F;要发送的最高位是否是1
        &#123;
            MO_H;			&#x2F;&#x2F;mosi输出高
        &#125;
        else
        &#123;
            MO_L;			&#x2F;&#x2F;mosi输出底
        &#125;
        data &lt;&lt;&#x3D; 1;		&#x2F;&#x2F;数据左移一位

        delay_us(10);

        SCK_L;

        temp &#x3D; temp &lt;&lt; 1;

        if(READ_MI)	&#x2F;&#x2F;读取MISO 如果是高
        &#123;
            temp |&#x3D; 0x01;     	&#x2F;&#x2F;记录数据
        &#125;

        delay_us(10);

        SCK_H;			&#x2F;&#x2F;时钟变高
    &#125;
    return temp;					&#x2F;&#x2F;返回收到的一个字节
&#125;
&#x2F;&#x2F;读取寄存器的值，0x00是数据可随意，固定是：操作命令---寄存器地址---数据
u8 ld3320_read_reg(u8 add)
&#123;
    u8 temp;

    CS_L;	&#x2F;&#x2F;必须要在CS低电平时才有效
    SPI_RW(0x05);	&#x2F;&#x2F;发送读操作命令
    SPI_RW(add);	&#x2F;&#x2F;发送寄存器地址
    temp &#x3D; SPI_RW(0x00);
    CS_H;

    return temp;
&#125;
&#x2F;&#x2F;写入寄存器的值
void ld3320_write_reg(u8 add, u8 dat)
&#123;
    CS_L;
    SPI_RW(0x04);
    SPI_RW(add);
    SPI_RW(dat);
    CS_H;

&#125;
&#x2F;&#x2F;检查芯片
u8 ld3320_check(void)
&#123;
    u8 a[3];
    memset(a, 0x00, sizeof(a));


    ld3320_reset();
    delay_ms(10);
    ld3320_read_reg(0x06);	&#x2F;&#x2F;0x06:(只读)FIFO状态
    delay_ms(10);
    a[0] &#x3D; ld3320_read_reg(0x06);
    delay_ms(10);
    a[1] &#x3D; ld3320_read_reg(0x35);	&#x2F;&#x2F;0x35:ADC增益，或可以理解为麦克风（MIC）音量
    delay_ms(10);
    a[2] &#x3D; ld3320_read_reg(0xb3);	&#x2F;&#x2F;0xb3:打开或关闭 “语音端点检测”功能

    printf(&quot;%02x	&quot;, a[0]);	&#x2F;&#x2F;读取值存储显示
    printf(&quot;%02x	&quot;, a[1]);
    printf(&quot;%02x	&quot;, a[2]);
    printf(&quot;\r\n&quot;);


    ld3320_reset();
    delay_ms(10);
    ld3320_read_reg(0x06);
    delay_ms(10);
    a[0] &#x3D; ld3320_read_reg(0x06);
    delay_ms(10);
    a[1] &#x3D; ld3320_read_reg(0x35);
    delay_ms(10);
    a[2] &#x3D; ld3320_read_reg(0xb3);

    printf(&quot;%02x	&quot;, a[0]);
    printf(&quot;%02x	&quot;, a[1]);
    printf(&quot;%02x	&quot;, a[2]);
    printf(&quot;\r\n&quot;);



    ld3320_write_reg(0x35, 0x33);	&#x2F;&#x2F;写入0x33到寄存器地址0x35里
    delay_ms(10);
    ld3320_write_reg(0x1b, 0x55);	&#x2F;&#x2F;写入0x55到寄存器地址0x1b里	0x1b:时钟频率设置3	
    delay_ms(10);
    ld3320_write_reg(0xb3, 0x40);	&#x2F;&#x2F;写入0xaa到寄存器地址0xb3里，推荐10~40，越小灵敏度越高容易误判

    a[0] &#x3D; ld3320_read_reg(0x35);	&#x2F;&#x2F;读取刚刚写入的值
    delay_ms(10);
    a[1] &#x3D; ld3320_read_reg(0x1b);	&#x2F;&#x2F;读取刚刚写入的值
    delay_ms(10);
    a[2] &#x3D; ld3320_read_reg(0xb3);	&#x2F;&#x2F;读取刚刚写入的值

    printf(&quot;%02x	&quot;, a[0]);
    printf(&quot;%02x	&quot;, a[1]);
    printf(&quot;%02x	&quot;, a[2]);
    printf(&quot;\r\n&quot;);

    if(a[0] !&#x3D; 0x33 || a[1] !&#x3D; 0x55 || a[2] !&#x3D; 0x20)	&#x2F;&#x2F;检查写入的值是否一样
        return 1;
    return 0;
&#125;
&#x2F;&#x2F;通用初始化
void LD_Init_Common(void)
&#123;
    bMp3Play &#x3D; 0;

    ld3320_read_reg(0x06);
    ld3320_write_reg(0x17, 0x35);
    delay_ms(10);
    ld3320_read_reg(0x06);

    ld3320_write_reg(0x89, 0x03);	&#x2F;&#x2F;模拟电路控制 初始化时写 03H MP3播放时写 FFH
    delay_ms(5);
    ld3320_write_reg(0xCF, 0x43);	&#x2F;&#x2F;内部省电模式设置 初始化时写入 43H MP3初始化和ASR初始化时写入 4FH
    delay_ms(5);
    ld3320_write_reg(0xCB, 0x02);	&#x2F;&#x2F;ASR：读取ASR结果


    ld3320_write_reg(0x11, LD_PLL_11);	&#x2F;&#x2F;时钟频率设置1
    if (nLD_Mode &#x3D;&#x3D; LD_MODE_MP3)
    &#123;
        ld3320_write_reg(0x1E, 0x00);	&#x2F;&#x2F;ADC专用控制，应初始化为00H
        ld3320_write_reg(0x19, LD_PLL_MP3_19);	&#x2F;&#x2F;时钟频率设置2
        ld3320_write_reg(0x1B, LD_PLL_MP3_1B);	&#x2F;&#x2F;时钟频率设置3
        ld3320_write_reg(0x1D, LD_PLL_MP3_1D);	&#x2F;&#x2F;时钟频率设置4
    &#125;
    else
    &#123;
        ld3320_write_reg(0x1E, 0x00);	
        ld3320_write_reg(0x19, LD_PLL_ASR_19);
        ld3320_write_reg(0x1B, LD_PLL_ASR_1B);
        ld3320_write_reg(0x1D, LD_PLL_ASR_1D);
    &#125;
    delay_ms(10);

    ld3320_write_reg(0xCD, 0x04);	&#x2F;&#x2F;初始化时写入04H 允许DSP休眠
    ld3320_write_reg(0x17, 0x4c);
    delay_ms(5);
    ld3320_write_reg(0xB9, 0x00);	&#x2F;&#x2F;当前添加识别句的字符串长度(拼音字符串)初始化时写入00H 每添加一条识别句后要设定一次。
    ld3320_write_reg(0xCF, 0x4F);
    ld3320_write_reg(0x6F, 0xFF);	&#x2F;&#x2F;对芯片进行初始化时设置为0xFF
&#125;


void ld3320_init_asr(void)
&#123;
    nLD_Mode &#x3D; LD_MODE_ASR_RUN;	&#x2F;&#x2F;运行ASR识别
    &#x2F;&#x2F;ld3320_init_common();
    LD_Init_Common();

    ld3320_write_reg(0xBD, 0x00);	&#x2F;&#x2F;初始化控制寄存器 02H:启动MP3模块 00H:语音识别模块
    ld3320_write_reg(0x17, 0x48);	&#x2F;&#x2F;48H:激活DSP 4CH:使DSP休眠，比较省电 35H:对LD3320进行软复位
    delay_ms(10);

    ld3320_write_reg(0x3C, 0x80);	&#x2F;&#x2F;FIFO_EXT下限低8位
    ld3320_write_reg(0x3E, 0x07);	&#x2F;&#x2F;FIFO_EXT下限高8位
    ld3320_write_reg(0x38, 0xff);	&#x2F;&#x2F;FIFO_EXT上限低8位
    ld3320_write_reg(0x3A, 0x07);	&#x2F;&#x2F;FIFO_EXT上限高8位


    ld3320_write_reg(0x40, 0);	&#x2F;&#x2F;FIFO_EXT MCU水线低8位
    ld3320_write_reg(0x42, 8);	&#x2F;&#x2F;FIFO_EXT MCU水线高8位
    ld3320_write_reg(0x44, 0);	&#x2F;&#x2F;FIFO_EXT DSP水线低8位
    ld3320_write_reg(0x46, 8);	&#x2F;&#x2F;FIFO_EXT DSP水线高8位
    delay_ms(10);
&#125;
&#x2F;&#x2F;检查是否处于闲状态
u8 ld3320_check_asrbusyflag_b2(void)
&#123;
    u8 j;
    u8 flag &#x3D; 0;
    for (j &#x3D; 0; j &lt; 10; j++)
    &#123;
        if (ld3320_read_reg(0xb2) &#x3D;&#x3D; 0x21)	&#x2F;&#x2F;ASR：DSP忙闲状态,0x21 表示闲，查询到为闲状态可以进行下一步ASR动作
        &#123;
            flag &#x3D; 1;
            break;
        &#125;
        delay_ms(10);
    &#125;
    return flag;
&#125;
&#x2F;&#x2F; Return 1: success.
&#x2F;&#x2F;	添加识别关键词语，开发者可以学习&quot;语音识别芯片LD3320高阶秘籍.pdf&quot;中关于垃圾词语吸收错误的用法
u8 ld3320_asr_addFixed(void)
&#123;
    u8 k, flag;
    u8 nAsrAddLength;
    const char sRecog[YUYIN_MAX][30] &#x3D;
    &#123;
        &quot;ni hao&quot;,
        &quot;tong xue&quot;,
        &quot;bei jing&quot;,
        &quot;shang hai&quot;,
        &quot;bi sai&quot;
    &#125;;	&#x2F;&#x2F;需要识别的拼音
	&#x2F;&#x2F;编号可以相同，可以不连续 例子中的“北京”和“首都”对应同一编号，说这两个词会有相同的结果返回
    const Order pCode[YUYIN_MAX] &#x3D;
    &#123;
        nihao,
        tongxue,
        beijing,
        shanghai,
        bisai
    &#125;;	&#x2F;&#x2F;编号

    flag &#x3D; 1;

    for (k &#x3D; 0; k &lt; YUYIN_MAX; k++)
    &#123;
        if(ld3320_check_asrbusyflag_b2() &#x3D;&#x3D; 0)
        &#123;
            &#x2F;&#x2F;printf(&quot;busy------------\r\n&quot;);
            flag &#x3D; 0;
            break;
        &#125;
        else
        &#123;
            &#x2F;&#x2F;printf(&quot;not busy------------\r\n&quot;);
        &#125;

        ld3320_write_reg(0xc1, pCode[k] );	&#x2F;&#x2F;ASR：识别字Index（00H—FFH）
        ld3320_write_reg(0xc3, 0 );	&#x2F;&#x2F;ASR：识别字添加时写入00
        ld3320_write_reg(0x08, 0x04);	&#x2F;&#x2F;清除FIFO内容（清除指定FIFO后再写入一次00H） 第0位：写入1→清除FIFO_DATA 第2位：写入1→清除FIFO_EXT
        delay_ms(10);
        ld3320_write_reg(0x08, 0x00);	&#x2F;&#x2F;清除指定FIFO后再写入一次00H
        delay_ms(10);

        for (nAsrAddLength &#x3D; 0; nAsrAddLength &lt; 20; nAsrAddLength++)
        &#123;
            if (sRecog[k][nAsrAddLength] &#x3D;&#x3D; 0)
            &#123;
                break;
            &#125;
            ld3320_write_reg(0x5, sRecog[k][nAsrAddLength]);	&#x2F;&#x2F;FIFO_EXT数据口
        &#125;
        ld3320_write_reg(0xb9, nAsrAddLength);	&#x2F;&#x2F;当前添加识别句的字符串长度
        ld3320_write_reg(0xb2, 0xff);	&#x2F;&#x2F;写入忙状态
        ld3320_write_reg(0x37, 0x04);	&#x2F;&#x2F;语音识别控制命令下发寄存器 写04H：通知DSP要添加一项识别句。 写06H：通知DSP开始识别语音。 在下发命令前，需要检查B2寄存器的状态
    &#125;
    return flag;
&#125;

u8 ld3320_asrun(void)
&#123;
    u8 temp;

    temp &#x3D; temp;

    ld3320_write_reg(0x35, MIC_VOL);	&#x2F;&#x2F;ADC增益，或可以理解为麦克风（MIC）音量。
    ld3320_write_reg(0x1C, 0x09);	&#x2F;&#x2F;ADC开关控制写09H Reserve保留命令字
    ld3320_write_reg(0xBD, 0x20);	&#x2F;&#x2F;初始化控制寄存器
    ld3320_write_reg(0x08, 0x01);	&#x2F;&#x2F;写入20H；Reserve保留命令字
    delay_ms(10);
    ld3320_write_reg(0x08, 0x00);	&#x2F;&#x2F;清除FIFO内容（清除指定FIFO后再写入一次00H）
    delay_ms(10);

    if(ld3320_check_asrbusyflag_b2() &#x3D;&#x3D; 0)
    &#123;
        return 0;
    &#125;

    ld3320_write_reg(0xB2, 0xff);	&#x2F;&#x2F;DSP忙闲状态
    ld3320_write_reg(0x37, 0x06);	&#x2F;&#x2F;写06H：通知DSP开始识别语音
    delay_ms(10);

    temp &#x3D; ld3320_read_reg(0xBF);&#x2F;&#x2F;看是否是32-3a 读到数值为0x35，可以确定是一次语音识别流程正常结束


    ld3320_write_reg(0x1C, 0x0b);	&#x2F;&#x2F;写0BH 麦克风输入ADC通道可用
    ld3320_write_reg(0x29, 0x10);	&#x2F;&#x2F;中断允许

    ld3320_write_reg(0xBD, 0x00);	&#x2F;&#x2F;写入00H；然后启动；为ASR模块；
    return 1;
&#125;
&#x2F;&#x2F;获取识别最佳结果
u8 LD_GetResult(void)
&#123;
    return ld3320_read_reg(0xc5);	&#x2F;&#x2F;读取ASR结果（最佳）
&#125;
void ld3320_process_init(void)
&#123;
    u8 nAsrResCount &#x3D; 0;
    u8 temp;

    ucRegVal &#x3D; ld3320_read_reg(0x2B);	&#x2F;&#x2F;中断请求编号
    &#x2F;&#x2F;printf(&quot;ucRegVal &#x3D; %02x\r\n&quot;,ucRegVal);

    ucHighInt &#x3D; ld3320_read_reg(0x29);	&#x2F;&#x2F;中断允许
    &#x2F;&#x2F;printf(&quot;ucHighInt &#x3D; %02x\r\n&quot;,ucHighInt);

    ld3320_write_reg(0x29, 0) ;
    ucLowInt &#x3D; ld3320_read_reg(0x02);	&#x2F;&#x2F;FIFO中断允许
    &#x2F;&#x2F;printf(&quot;ucLowInt &#x3D; %02x\r\n&quot;,ucLowInt);


    ld3320_write_reg(0x02, 0) ;
    if(nLD_Mode &#x3D;&#x3D; LD_MODE_ASR_RUN)
    &#123;
		&#x2F;&#x2F;ucRegVal&#x3D;&#x3D;0x10表示语音识别有结果产生且芯片内部FIFO中断发生
		&#x2F;&#x2F;读到数值为0x35，可以确定是一次语音识别流程正常结束
		&#x2F;&#x2F;0x21表示空闲
        if( (ucRegVal &amp; 0x10) &amp;&amp; ld3320_read_reg(0xbf) &#x3D;&#x3D; 0x35 &amp;&amp; ld3320_read_reg(0xb2) &#x3D;&#x3D; 0x21)
        &#123;
			&#x2F;&#x2F;中断辅助信息
			&#x2F;&#x2F;ASR：中断时，是语音识别有几个识别候选 Value: 1 – 4: N个识别候选 0或者大于4：没有识别候选
            nAsrResCount &#x3D; ld3320_read_reg(0xba);	
            &#x2F;&#x2F;printf(&quot;nAsrResCount &#x3D; %02x\r\n&quot;,nAsrResCount);


            if(nAsrResCount &gt; 0 &amp;&amp; nAsrResCount &lt; 4)
            &#123;
                nAsrStatus &#x3D; LD_ASR_FOUNDOK;	&#x2F;&#x2F;表示一次识别流程结束后，有一个识别结果

                temp &#x3D; LD_GetResult();
                printf(&quot;temp &#x3D; %02x\r\n&quot;, temp);
            &#125;
            else
            &#123;
                nAsrStatus &#x3D; LD_ASR_FOUNDZERO;	&#x2F;&#x2F;表示一次识别流程结束后，没有识别结果
            &#125;
        &#125;
        else
        &#123;
            nAsrStatus &#x3D; LD_ASR_FOUNDZERO;	&#x2F;&#x2F;&#x2F;&#x2F;表示一次识别流程结束后，没有识别结果
        &#125;
        ld3320_write_reg(0x2b, 0);	&#x2F;&#x2F;清除中断标志
        ld3320_write_reg(0x1C, 0);	&#x2F;&#x2F;ADC开关控制 写00H ADC不可用

        return;
    &#125;
&#125;</code></pre>
<h4 id="摄像头">摄像头</h4>
<p>摄像头型号OV2640，I2C接口对摄像头进行设置</p>
<table>
<thead>
<tr>
<th style="text-align:center">所用模块</th>
<th style="text-align:center">连接注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STM32模块扩展板</td>
<td style="text-align:center">插口袋机右边</td>
</tr>
<tr>
<td style="text-align:center">语音识别模块</td>
<td style="text-align:center">模块有灯的在右下角</td>
</tr>
</tbody>
</table>
<p>硬件连接：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221110171514.jpg" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221110171613.jpg" alt=" "></p>
<table>
<thead>
<tr>
<th style="text-align:center">管脚号</th>
<th style="text-align:center">对应扩展板管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Y0(8位数据输出)</td>
<td style="text-align:center">PE13</td>
</tr>
<tr>
<td style="text-align:center">Y1</td>
<td style="text-align:center">PF15</td>
</tr>
<tr>
<td style="text-align:center">Y2</td>
<td style="text-align:center">PE15</td>
</tr>
<tr>
<td style="text-align:center">Y3</td>
<td style="text-align:center">PE14</td>
</tr>
<tr>
<td style="text-align:center">Y4</td>
<td style="text-align:center">PB13</td>
</tr>
<tr>
<td style="text-align:center">Y5</td>
<td style="text-align:center">PA4</td>
</tr>
<tr>
<td style="text-align:center">Y6</td>
<td style="text-align:center">PD7</td>
</tr>
<tr>
<td style="text-align:center">Y7</td>
<td style="text-align:center">PA5</td>
</tr>
<tr>
<td style="text-align:center">SDA(I2C数据)</td>
<td style="text-align:center">PE14</td>
</tr>
<tr>
<td style="text-align:center">SCL(I2C时钟)</td>
<td style="text-align:center">PD15</td>
</tr>
<tr>
<td style="text-align:center">VSYNC(帧同步输出)</td>
<td style="text-align:center">PD14</td>
</tr>
<tr>
<td style="text-align:center">PWND(掉电模式使能)</td>
<td style="text-align:center">PD12</td>
</tr>
<tr>
<td style="text-align:center">PCLK(像素时钟)</td>
<td style="text-align:center">PE1</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_GPIO_Init.h*************************&#x2F;
# define READ_SDA		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_14)

# define READ_VSYNC		GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_14)

# define READ_HREF		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_1)

# define READ_PCLK		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_1)

# define READ_Y0		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_13)
# define READ_Y1		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_15)
# define READ_Y2		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_15)
# define READ_Y3		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_14)
# define READ_Y4		GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)
# define READ_Y5		GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_4)
# define READ_Y6		GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_7)
# define READ_Y7		GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_5)

# define SCL_L		(GPIOD-&gt;BSRRH &#x3D; GPIO_Pin_15)
# define SCL_H		(GPIOD-&gt;BSRRL &#x3D; GPIO_Pin_15)

# define SDA_L		(GPIOF-&gt;BSRRH &#x3D; GPIO_Pin_14)
# define SDA_H		(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_14)

# define PWDN_L		(GPIOD-&gt;BSRRH &#x3D; GPIO_Pin_12)
# define PWDN_H		(GPIOD-&gt;BSRRL &#x3D; GPIO_Pin_12)


# define OV2640_DATA1   	GPIOA-&gt;IDR
# define OV2640_DATA2   	GPIOB-&gt;IDR
# define OV2640_DATA3   	GPIOD-&gt;IDR
# define OV2640_DATA4   	GPIOE-&gt;IDR
# define OV2640_DATA5   	GPIOF-&gt;IDR



&#x2F;&#x2F;IO方向设置
# define SCCB_SDA_IN()  &#123;GPIOF-&gt;MODER&amp;&#x3D;(u32)(~(3&lt;&lt;(14*2)));GPIOF-&gt;MODER|&#x3D;(u32)(0&lt;&lt;14*2);&#125;	&#x2F;&#x2F;PF14 输入
# define SCCB_SDA_OUT() &#123;GPIOF-&gt;MODER&amp;&#x3D;(u32)(~(3&lt;&lt;(14*2)));GPIOF-&gt;MODER|&#x3D;(u32)(1&lt;&lt;14*2);&#125; 	&#x2F;&#x2F;PF14 输出</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_GPIO_Init.c*************************&#x2F;

void GPIO_init_all(void)
&#123;
	GPIO_init(GPIO_E,GPIO_Pin_14,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;SDA
	GPIO_init(GPIO_D,GPIO_Pin_15,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;SCL
	
	GPIO_init(GPIO_D,GPIO_Pin_14,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;VSYNC
	GPIO_init(GPIO_D,GPIO_Pin_12,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;PWND
	GPIO_init(GPIO_F,GPIO_Pin_1,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);		&#x2F;&#x2F;HREF
	
	GPIO_init(GPIO_A,GPIO_Pin_5,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);		&#x2F;&#x2F;Y7
	GPIO_init(GPIO_D,GPIO_Pin_7,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);		&#x2F;&#x2F;Y6
	GPIO_init(GPIO_A,GPIO_Pin_4,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);		&#x2F;&#x2F;Y5
	GPIO_init(GPIO_E,GPIO_Pin_15,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;Y2
	GPIO_init(GPIO_F,GPIO_Pin_15,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;Y1
	GPIO_init(GPIO_E,GPIO_Pin_14,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;Y3
	GPIO_init(GPIO_E,GPIO_Pin_13,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;Y0
	GPIO_init(GPIO_B,GPIO_Pin_13,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;Y4
	
	GPIO_init(GPIO_E,GPIO_Pin_1,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;PCLK
&#125;</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c(I2C部分)*************************&#x2F;
&#x2F;&#x2F;SCCB起始信号
&#x2F;&#x2F;当时钟为高的时候,数据线的高到低,为SCCB起始信号
&#x2F;&#x2F;在激活状态下,SDA和SCL均为低电平
void SCCB_Start(void)
&#123;
    SDA_H;     &#x2F;&#x2F;数据线高电平	   
    SCL_H;	    &#x2F;&#x2F;在时钟线高的时候数据线由高至低
    delay_us(50);  
    SDA_L;
    delay_us(50);	 
    SCL_L;	    &#x2F;&#x2F;数据线恢复低电平，单操作函数必要	  
&#125;



&#x2F;&#x2F;SCCB停止信号
&#x2F;&#x2F;当时钟为高的时候,数据线的低到高,为SCCB停止信号
&#x2F;&#x2F;空闲状况下,SDA,SCL均为高电平
void SCCB_Stop(void)
&#123;
    SDA_L;
    delay_us(50);	 
    SCL_L;	
    delay_us(50); 
    SDA_H;	
    delay_us(50);
&#125; 



&#x2F;&#x2F;产生NA信号
void SCCB_No_Ack(void)
&#123;
	delay_us(50);
	SDA_H;	
	SCL_H;	
	delay_us(50);
	SCL_L;	
	delay_us(50);
	SDA_L;	
	delay_us(50);
&#125;




&#x2F;&#x2F;SCCB,写入一个字节
&#x2F;&#x2F;返回值:0,成功;1,失败. 
u8 SCCB_WR_Byte(u8 dat)
&#123;
	u8 j,res;	 
	for(j&#x3D;0;j&lt;8;j++) &#x2F;&#x2F;循环8次发送数据
	&#123;
		if(dat&amp;0x80)SDA_H;	
		else SDA_L;
		dat&lt;&lt;&#x3D;1;
		delay_us(50);
		SCL_H;	
		delay_us(50);
		SCL_L;		   
	&#125;			 
	SCCB_SDA_IN();		&#x2F;&#x2F;设置SDA为输入 
	delay_us(50);
	SCL_H;			&#x2F;&#x2F;接收第九位,以判断是否发送成功
	delay_us(50);
	if(READ_SDA)res&#x3D;1;  &#x2F;&#x2F;SDA&#x3D;1发送失败，返回1
	else res&#x3D;0;         &#x2F;&#x2F;SDA&#x3D;0发送成功，返回0
	SCL_L;		 
	SCCB_SDA_OUT();		&#x2F;&#x2F;设置SDA为输出    
	return res;  
&#125;	 




&#x2F;&#x2F;SCCB 读取一个字节
&#x2F;&#x2F;在SCL的上升沿,数据锁存
&#x2F;&#x2F;返回值:读到的数据
u8 SCCB_RD_Byte(void)
&#123;
	u8 temp&#x3D;0,j;    
	SCCB_SDA_IN();		&#x2F;&#x2F;设置SDA为输入  
	for(j&#x3D;8;j&gt;0;j--) 	&#x2F;&#x2F;循环8次接收数据
	&#123;		     	  
		delay_us(50);
		SCL_H;
		temp&#x3D;temp&lt;&lt;1;
		if(READ_SDA)temp++;   
		delay_us(50);
		SCL_L;
	&#125;	
	SCCB_SDA_OUT();		&#x2F;&#x2F;设置SDA为输出    
	return temp;
&#125; </code></pre>
<p>其他代码略(源码在阿里云网盘)</p>
<h4 id="超声波测距">超声波测距</h4>
<p>硬件连接：</p>
<table>
<thead>
<tr>
<th style="text-align:center">所用模块</th>
<th style="text-align:center">连接注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STM32模块扩展板</td>
<td style="text-align:center">插口袋机右边</td>
</tr>
<tr>
<td style="text-align:center">超声波模块</td>
<td style="text-align:center">模块有灯的在左上角</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221110182808.jpg" alt=" "></p>
<p>使用两个超声波探头，一个发送，一个接收； <code>CS100A</code> 是超声波测距控制芯片</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_Timer_eval.c*************************&#x2F;
__IO uint16_t Tim3_Cont_val &#x3D; 0;


extern u32 t_count;

&#x2F;&#x2F;定时器3
void Timer3_Config(uint16_t period, uint16_t prescaler)
&#123;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  NVIC_InitTypeDef NVIC_InitStructure;
	
  &#x2F;* TIM3 clock enable *&#x2F;
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

  &#x2F;* Time base configuration *&#x2F;
  TIM_TimeBaseStructure.TIM_Period &#x3D; period;
  TIM_TimeBaseStructure.TIM_Prescaler &#x3D; prescaler;
  TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; 0;
  TIM_TimeBaseStructure.TIM_CounterMode &#x3D; TIM_CounterMode_Up;

  TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);

	&#x2F;* TIM3 enable *&#x2F;
  TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);

  &#x2F;* TIM3 enable counter *&#x2F;
  TIM_Cmd(TIM3, ENABLE);
	
&#x2F;&#x2F;	&#x2F;* Configure and enable TIM3 interrupt *&#x2F;
	NVIC_InitStructure.NVIC_IRQChannel &#x3D; TIM3_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 6;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0;
  NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;
  NVIC_Init(&amp;NVIC_InitStructure);
&#125;
&#x2F;&#x2F;定时器中断函数
void TIM3_IRQHandler(void)
&#123;
	if(TIM_GetITStatus(TIM3, TIM_IT_Update) !&#x3D; RESET)
  &#123;
    &#x2F;* Clear interrupt pending bit *&#x2F;
    TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
		t_count ++;
  &#125;
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
&#x2F;&#x2F;外部中断服务程序
void EXTI15_10_IRQHandler(void)
&#123;
	if(EXTI_GetITStatus(EXTI_Line14) !&#x3D; RESET)
	&#123;
		read_bit &#x3D; READ_ECHO;&#x2F;&#x2F;读端口电平
		if(read_bit&#x3D;&#x3D;1)&#x2F;&#x2F;如果是1 计数清零
		&#123;
			t_count &#x3D; 0;
		&#125;
		else		&#x2F;&#x2F;如果是0  停止计数   保存计数值
		&#123;
			race_count &#x3D; t_count;
			race_ok_bit &#x3D; 1;
		&#125;
		EXTI_ClearITPendingBit(EXTI_Line14);
	&#125;
&#125;




&#x2F;&#x2F;外部中断初始化函数
void EXTIX_Init(void)
&#123;
  NVIC_InitTypeDef   NVIC_InitStructure;
	EXTI_InitTypeDef   EXTI_InitStructure;
	
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);&#x2F;&#x2F;设置系统中断优先级分组2
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);&#x2F;&#x2F;使能SYSCFG时钟
	
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOE, EXTI_PinSource14);&#x2F;&#x2F;E14

	EXTI_InitStructure.EXTI_Line &#x3D; EXTI_Line14;
	
  EXTI_InitStructure.EXTI_Mode &#x3D; EXTI_Mode_Interrupt;&#x2F;&#x2F;中断事件
  EXTI_InitStructure.EXTI_Trigger &#x3D; EXTI_Trigger_Rising_Falling; &#x2F;&#x2F;上升沿下降沿 都触发
  EXTI_InitStructure.EXTI_LineCmd &#x3D; ENABLE;&#x2F;&#x2F;中断线使能
  EXTI_Init(&amp;EXTI_InitStructure);&#x2F;&#x2F;配置
 

	NVIC_InitStructure.NVIC_IRQChannel &#x3D; EXTI15_10_IRQn;&#x2F;&#x2F;外部中断10-15
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 0x01;&#x2F;&#x2F;抢占优先级1
  NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0x02;&#x2F;&#x2F;子优先级2
  NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;&#x2F;&#x2F;使能外部中断通道
  NVIC_Init(&amp;NVIC_InitStructure);&#x2F;&#x2F;配置

&#125;

int main(void)
&#123;
    Timer3_Config(20,19);&#x2F;&#x2F;5us 21*20&#x2F;42000000&#x3D;10us
    
      while (1)
  &#123;
		TRIG_H;				&#x2F;&#x2F;发射管教变高
		delay_us(10);	&#x2F;&#x2F;延时
		TRIG_L;				&#x2F;&#x2F;发射管教变低
		
		DIS_mm_f &#x3D; (float)race_count;&#x2F;&#x2F;读取计数
		
		DIS_mm_f &#x3D; DIS_mm_f * 5.0f * 0.34f &#x2F; 2.0f;&#x2F;&#x2F;计算
		
		DIS_mm_u16 &#x3D; DIS_mm_f&#x2F;10;&#x2F;&#x2F;变成整形
		
		
		
		LCD_Draw_Rect_Win(144,0,80,32,BACKGROND);&#x2F;&#x2F;刷新显示
		LCD_ShowNum(144,0,DIS_mm_u16,5,32,TYPEFACE);&#x2F;&#x2F;显示数据
		
		
		if(race_ok_bit&#x3D;&#x3D;1)&#x2F;&#x2F;是否收到返回的脉冲
		&#123;
			race_ok_bit &#x3D; 0;
			
			printf(&quot;%.1f\r\n&quot;,DIS_mm_u16);&#x2F;&#x2F;串口打印
		&#125;
		else
		&#123;
			printf(&quot;no_race\r\n&quot;);&#x2F;&#x2F;串口打印
		&#125;
		
		
		delay_ms(50);&#x2F;&#x2F;间隔50ms采集一次
		
  &#125;
&#125;
</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_GPIO_Init.c*************************&#x2F;
void GPIO_init_all(void)
&#123;
GPIO_init(GPIO_E,GPIO_Pin_14,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_NOPULL);&#x2F;&#x2F;E14
	GPIO_init(GPIO_E,GPIO_Pin_13,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;E13
&#125;</code></pre>
<h2 id="提供的函数详解">提供的函数详解</h2>
<p>代码集合</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_GPIO_Init.c*************************&#x2F;
void GPIO_init(u16 GPIOx, u16 GPIO_Pin, GPIOMode_TypeDef mode, GPIOOType_TypeDef type, GPIOPuPd_TypeDef pupd)
&#123;

&#x2F;&#x2F;宏定义端口组	
# define GPIO_A	0x0000
# define GPIO_B	0x0001
# define GPIO_C	0x0002
# define GPIO_D	0x0003
# define GPIO_E	0x0004
# define GPIO_F	0x0005
# define GPIO_G	0x0006
	
	
	GPIO_InitTypeDef        GPIO_InitStructure;
	
	
	GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin;	&#x2F;&#x2F;引脚
	GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_100MHz;	&#x2F;&#x2F;速度
	GPIO_InitStructure.GPIO_Mode &#x3D; mode;	&#x2F;&#x2F;操作模式
	GPIO_InitStructure.GPIO_OType &#x3D; type;	&#x2F;&#x2F;输出类型
	GPIO_InitStructure.GPIO_PuPd &#x3D; pupd;	&#x2F;&#x2F;是否上拉&#x2F;下拉
	
	
	switch(GPIOx)
	&#123;
		case GPIO_A:
			RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
			GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
			break;
		
		case GPIO_B:
			RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
			GPIO_Init(GPIOB,&amp;GPIO_InitStructure);
			break;
		
		case GPIO_C:
			RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
			GPIO_Init(GPIOC,&amp;GPIO_InitStructure);
			break;
		
		case GPIO_D:
			RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
			GPIO_Init(GPIOD,&amp;GPIO_InitStructure);
			break;
		
		case GPIO_E:
			RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
			GPIO_Init(GPIOE,&amp;GPIO_InitStructure);
			break;
		
		case GPIO_F:
			RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
			GPIO_Init(GPIOF,&amp;GPIO_InitStructure);
			break;
		
		case GPIO_G:
			RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
			GPIO_Init(GPIOG,&amp;GPIO_InitStructure);
			break;
		
	&#125;
&#125;	
&#x2F;*************************STM32F40x_LCD_SPI.c*************************&#x2F;
一个字符占16*32(大字体)，16*16(小字体)
&#x2F;&#x2F;显示字符串
void LCD_ShowString(uint16_t x, uint16_t y, char *p, uint8_t size, uint16_t Color)
● 参数1：x横坐标，0~240
● 参数2：y纵坐标才，0~320
● 参数3：要显示的字符串
● 参数4：显示大小(16是小字体，32是大字体)
● 参数5：颜色    
    
&#x2F;*************************STM32F40x_Usart_eval.c(USART5部分)*************************&#x2F;    
char usart5_race_buf[100];
u16 usart5_race_count;

u8 usart5_race_over_bit;

void uart5_race_buf_init(void)
&#123;
	u16 i;
	
	for(i&#x3D;0;i&lt;100;i++)
	&#123;
		usart5_race_buf[i] &#x3D; 0;
	&#125;
&#125;
&#x2F;&#x2F;串口5初始化
void Uart5_Init(void)
&#123;
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	

  &#x2F;* Enable GPIO clock *&#x2F;
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	
  &#x2F;* Connect PXx to USARTx_Tx*&#x2F;
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_UART5);
	
  &#x2F;* Connect PXx to USARTx_Rx*&#x2F;
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource2, GPIO_AF_UART5);
	
	&#x2F;* Configure USART Tx as alternate function  *&#x2F;
  GPIO_InitStructure.GPIO_OType &#x3D; GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd &#x3D; GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;

  GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_12;	&#x2F;&#x2F;PC12
  GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz;
  GPIO_Init(GPIOC, &amp;GPIO_InitStructure);

  &#x2F;* Configure USART Rx as alternate function  *&#x2F;
  GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_2;	&#x2F;&#x2F;PD2
  GPIO_Init(GPIOD, &amp;GPIO_InitStructure);
	

	
  NVIC_InitStructure.NVIC_IRQChannel &#x3D; UART5_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 2;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0;
  NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;
  NVIC_Init(&amp;NVIC_InitStructure);
	
	
  &#x2F;* Enable USART clock *&#x2F;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);&#x2F;&#x2F;串口5的时钟使能
	
	&#x2F;&#x2F;USART5 初始化设置
	USART_InitStructure.USART_BaudRate &#x3D; 115200;&#x2F;&#x2F;一般设置为115200;
	USART_InitStructure.USART_WordLength &#x3D; USART_WordLength_8b;&#x2F;&#x2F;8bit
	USART_InitStructure.USART_StopBits &#x3D; USART_StopBits_1;&#x2F;&#x2F;停止位1位
	USART_InitStructure.USART_Parity &#x3D; USART_Parity_No;&#x2F;&#x2F;不使用奇偶校验位
	USART_InitStructure.USART_HardwareFlowControl &#x3D; USART_HardwareFlowControl_None;	&#x2F;&#x2F;不使用硬件流控制
	USART_InitStructure.USART_Mode &#x3D; USART_Mode_Rx | USART_Mode_Tx;
	
 
  USART_Init(UART5, &amp;USART_InitStructure);	&#x2F;&#x2F;初始化USART5
  
	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);&#x2F;&#x2F;开启接收中断
	
 
  USART_Cmd(UART5, ENABLE);	&#x2F;&#x2F;使能USART5
	
  USART_ClearFlag(UART5, USART_FLAG_TC);	&#x2F;&#x2F;清除发送完成标志位
&#125;


&#x2F;&#x2F;串口5发送数组  dat是数组   len是长度
void Uart5_send_data(char *dat, unsigned short len)
&#123;
	usart5_race_count &#x3D; 0;
	uart5_race_buf_init();&#x2F;&#x2F;接收数组清零
	
	while(len--)
	&#123;
        &#x2F;&#x2F;stm32中DR寄存器只有低9位有效，其余高位是保留的，为了保证正确性和将来的兼容性，只取Data的低9位数据，所以&amp;(uint16_t)0x01FF
		UART5-&gt;DR &#x3D; (*dat &amp; (uint16_t)0x01FF);
		while(USART_GetFlagStatus(UART5, USART_FLAG_TC) &#x3D;&#x3D; RESET);&#x2F;&#x2F;传输完成
		dat++;
	&#125;
&#125;



&#x2F;&#x2F;串口5接收中断
void UART5_IRQHandler(void)
&#123;
	unsigned char Res;
	
	if(USART_GetITStatus(UART5, USART_IT_RXNE) !&#x3D; RESET)  &#x2F;&#x2F;接收中断
	&#123;
		Res &#x3D; USART_ReceiveData(UART5);&#x2F;&#x2F;(UART5-&gt;DR);	&#x2F;&#x2F;读取接收到的数据
		
		
		usart5_race_buf[usart5_race_count] &#x3D; Res;
		usart5_race_count++;
		if(usart5_race_count&#x3D;&#x3D;100)
		&#123;
			usart5_race_count &#x3D; 0;
			usart5_race_over_bit &#x3D; 1;
		&#125;
  &#125;
&#125;
&#x2F;&#x2F;重定向printf到USART1
int fputc(int ch, FILE *f)
&#123;
	USART1-&gt;DR &#x3D; (ch &amp; (uint16_t)0x01FF);
  while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) &#x3D;&#x3D; RESET);

  return ch;
&#125;</code></pre>
<h3 id="口袋机端口">口袋机端口</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221109155633.png" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221109155740.png" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221110233931.jpg" alt=" "></p>
<ul>
<li>
<p><code>PD7</code> 接口 连接了内部RAM的使能， <code>外部是不可以使用的，必须输出高电平</code>，否则会影响其他端口的电平</p>
</li>
<li>
<p>左侧是口袋机原理图的 P3，00 ~ 29 对应网络标号 <code>GPIO_30 ~ GPIO_59</code>；右 侧是口袋机原理图的 P1，00 ~ 29 对应网络标号 <code>GPIO_00 ~ GPIO_29</code></p>
</li>
<li>
<p>口袋机按键(初始化为输入，开漏，上拉)，低电平时表示按下</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">按键(管脚)</th>
<th style="text-align:center">对应程序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A(PA^0)</td>
<td style="text-align:center">BUTTON_A<br>READ_BUTTON4</td>
</tr>
<tr>
<td style="text-align:center">B(PG^6)</td>
<td style="text-align:center">BUTTON_B<br>READ_BUTTON3</td>
</tr>
<tr>
<td style="text-align:center">C(PG^7)</td>
<td style="text-align:center">BUTTON_C<br>READ_BUTTON2</td>
</tr>
<tr>
<td style="text-align:center">D(PG^8)</td>
<td style="text-align:center">BUTTON_D<br>READ_BUTTON1</td>
</tr>
<tr>
<td style="text-align:center">上(PG^11)</td>
<td style="text-align:center">BUTTON_UP<br>READ_BUTTON7</td>
</tr>
<tr>
<td style="text-align:center">下(PD^6)</td>
<td style="text-align:center">BUTTON_DOWN<br>READ_BUTTON6</td>
</tr>
<tr>
<td style="text-align:center">左(PG^10)</td>
<td style="text-align:center">BUTTON_LEFT<br>READ_BUTTON8</td>
</tr>
<tr>
<td style="text-align:center">右(PD^3)</td>
<td style="text-align:center">BUTTON_RIGHT<br>READ_BUTTON5</td>
</tr>
</tbody>
</table>
<ul>
<li>串口1(波特率9600)，拿来单片机与电脑通信</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">USART1(管脚)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PA^9(USB_UART_Rx)</td>
</tr>
<tr>
<td style="text-align:center">PA^10(USB_UART_Tx)</td>
</tr>
</tbody>
</table>
<h2 id="其他注意问题">其他注意问题</h2>
<ul>
<li>在使用串口中断函数处理数据时，不用调用函数 <code>USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)</code> 清除发送完成标志位，否则程序可能会发生异常混乱</li>
<li>STM32F4系列 — <code>TIM1,TIM8,TIM11</code> 时钟频率是APB2两分频的2倍时钟频率(即168MHz)； <code>TIM2~TIM7</code>, <code>TIM12~TIM14</code> 时钟频率是APB1四分频的2倍频率(即84MHz)；所以定时时需要注意预分频值取 <code>167还是83</code></li>
<li><code>BSRRH</code> 表示BSRR寄存器高16位（BRy），哪一个BRy置1，引脚输出 <code>低电平</code>； <code>BSRRL</code> 表示BSRR寄存器低16位（BSy），哪一个BRy置1，引脚输出 <code>高电平</code></li>
</ul>
<h2 id="硬件注意问题">硬件注意问题</h2>
<ul>
<li>小车 12V 充电器；垃圾桶 13.8V 充电器</li>
<li>如果小车夹子没反应查看一下线是否松了(如果代码正常的话)</li>
</ul>
<h2 id="函数问题-第一次用的">函数问题(第一次用的)</h2>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">函数作用</th>
<th style="text-align:left">注意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)</td>
<td style="text-align:center">更改指定引脚的映射</td>
<td style="text-align:left">不要用 “或” 一次多选引脚；要分开写<br>第二个参数是 <code>GPIO_PinSourcex</code>，不要写成 <code>GPIO_Pin_x</code>，它们是有区别的<br>参数3是选择用作备用功能的引脚</td>
</tr>
</tbody>
</table>
<ul>
<li>外部中断的一般配置步骤</li>
</ul>
<p>1、使能SYSCFG时钟：RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYACFG,ENABLE);</p>
<p>2、初始化IO口为输入：GPIO_Init();（中断与IO口电平无关）</p>
<p>3、设置IO口与中断线的映射关系：void SYSCFG_EXTILineConfig();</p>
<p>4、初始化线上中断，设置触发条件：EXTI_init();</p>
<p>5、配置中断分组（NVIC），并使能中断：NVIC_Init();</p>
<p>6、编写中断服务函数：EXTIx_IRQHandler();</p>
<p>7、清除中断标志位：EXTI_ClearITPendingBit();</p>
<ul>
<li>使用定时器的外部时钟 <code>ETR</code> 的方式实现，从ETR输入方波作为外部时钟，输出PWM波触发ADC采集(用来对引脚上的输入信号进行统计)。定时时间计算与内部时钟时一样计算，只是 <code>总时钟频率变化了</code>，在检测验证时要注意计算输出的频率，避免乱设置导致频率太小，计数时用外部时钟模式2</li>
<li><code>GPIOG-&gt;ODR</code> 是直接操作寄存器(对ODR赋值是一次操作16位的，也就是同时设置了16个引脚的输出电平)； <code>IDR</code> 是查看引脚电平状态用的寄存器（只读）， <code>ODR</code> 是引脚电平输出的寄存器</li>
<li>清除空闲中断方法：USART的状态位TC是置位的，TC位的置零则是通过软件序列来清除的，具体的步骤是“ <code>先读USART_SR，然后写入USART_DR</code> ”，只有这样才能够清除标志位TC</li>
<li>TIM1做计数时的中断通道是:<code>TIM1_UP_TIM10_IRQn</code>(TIM1 更新中断和 TIM10 全局中断)</li>
</ul>
<h2 id="各设备通信全局定义">各设备通信全局定义</h2>
<table>
<thead>
<tr>
<th style="text-align:center">单元</th>
<th style="text-align:center">ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">转盘</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">小车</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">集中站</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">垃圾桶1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">垃圾桶2</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">垃圾桶3</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">垃圾桶4</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<h2 id="沙盘存在的问题汇总">沙盘存在的问题汇总</h2>
<ul>
<li><del>轮子到第2个转弯会打滑几秒</del></li>
<li><del>夹子夹不准</del>(现在夹到的几率有80%)</li>
<li>轮子的PWM看不懂频率是初始化为多少，根据计算结果不太准(待解决)</li>
<li><del>在小车没回到原点时要是有垃圾进入托盘小车回到原点后不会去夹，需要在小车在原点再去放垃圾到转盘才行</del></li>
<li>转盘识别有时候傻傻的，纸皮被识别成厨余垃圾也是醉了</li>
</ul>
<h2 id="1-小车部分">&lt;1&gt;小车部分</h2>
<h3 id="小车代码详解-主要代码">小车代码详解(主要代码)</h3>
<h4 id="TIM5-车轮编码器">TIM5/车轮编码器</h4>
<ul>
<li>编码器管脚</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
<th style="text-align:center">哪个轮</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PA^5</td>
<td style="text-align:center">CODE-F-L-1</td>
<td style="text-align:center">输入，开漏，上拉</td>
<td style="text-align:center">前左</td>
<td style="text-align:center">编码器</td>
</tr>
<tr>
<td style="text-align:center">PB^1(TIM3_CH4)</td>
<td style="text-align:center">CODE-F-L-2</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">PD^14</td>
<td style="text-align:center">CODE-F-R-1</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">前右</td>
<td style="text-align:center">编码器</td>
</tr>
<tr>
<td style="text-align:center">PD^15(TIM4_CH4)</td>
<td style="text-align:center">CODE-F-R-2</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">PC^8</td>
<td style="text-align:center">CODE-B-L-1</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">后左</td>
<td style="text-align:center">编码器</td>
</tr>
<tr>
<td style="text-align:center">PC^10(UART4_Tx)</td>
<td style="text-align:center">CODE-B-L-2</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">PC^12(UART5_Tx)</td>
<td style="text-align:center">CODE-B-R-1</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">后右</td>
<td style="text-align:center">编码器</td>
</tr>
<tr>
<td style="text-align:center">PC^11(UART4_Rx)</td>
<td style="text-align:center">CODE-B-R-2</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
<td style="text-align:center">/</td>
</tr>
</tbody>
</table>
<ul>
<li>轮子用到的PWM(使用TIM1的通道)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">频率</th>
<th style="text-align:center">哪个轮</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PE^9</td>
<td style="text-align:center">TIM1_CH1</td>
<td style="text-align:center"></td>
<td style="text-align:center">前左</td>
<td style="text-align:center">PWM</td>
</tr>
<tr>
<td style="text-align:center">PE^11</td>
<td style="text-align:center">TIM1_CH2</td>
<td style="text-align:center"></td>
<td style="text-align:center">前右</td>
<td style="text-align:center">PWM</td>
</tr>
<tr>
<td style="text-align:center">PE^14</td>
<td style="text-align:center">TIM1_CH4</td>
<td style="text-align:center"></td>
<td style="text-align:center">后左</td>
<td style="text-align:center">PWM</td>
</tr>
<tr>
<td style="text-align:center">PE^13</td>
<td style="text-align:center">TIM1_CH3</td>
<td style="text-align:center"></td>
<td style="text-align:center">后右</td>
<td style="text-align:center">PWM</td>
</tr>
</tbody>
</table>
<ul>
<li>方向控制端口</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">哪个轮</th>
<th style="text-align:center">模式</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PB^15</td>
<td style="text-align:center">前左</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
<td style="text-align:center">方向控制</td>
</tr>
<tr>
<td style="text-align:center">PB^8</td>
<td style="text-align:center">前右</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">方向控制</td>
</tr>
<tr>
<td style="text-align:center">PG^13</td>
<td style="text-align:center">后左</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">方向控制</td>
</tr>
<tr>
<td style="text-align:center">PG^12</td>
<td style="text-align:center">后右</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">方向控制</td>
</tr>
</tbody>
</table>
<ul>
<li>B表示向后走，F表示向前</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************CAR.h*************************&#x2F;
# define MOTO_0_B		(GPIOB-&gt;BSRRH &#x3D; GPIO_Pin_15)  &#x2F;&#x2F; 复位 置0 前左
# define MOTO_0_F		(GPIOB-&gt;BSRRL &#x3D; GPIO_Pin_15)  &#x2F;&#x2F;置1  默认向前转

# define MOTO_1_B		(GPIOB-&gt;BSRRH &#x3D; GPIO_Pin_8)	&#x2F;&#x2F;前右
# define MOTO_1_F		(GPIOB-&gt;BSRRL &#x3D; GPIO_Pin_8)

# define MOTO_2_B		(GPIOG-&gt;BSRRH &#x3D; GPIO_Pin_13)	&#x2F;&#x2F;后左
# define MOTO_2_F		(GPIOG-&gt;BSRRL &#x3D; GPIO_Pin_13)

# define MOTO_3_B		(GPIOG-&gt;BSRRH &#x3D; GPIO_Pin_12)	&#x2F;&#x2F;后右
# define MOTO_3_F		(GPIOG-&gt;BSRRL &#x3D; GPIO_Pin_12)</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************car_init.c*************************&#x2F;
void encoder_gpio_init(void)
&#123;

    EXTIX_Init_A5();	&#x2F;&#x2F;前左
    EXTIX_Init_D14();	&#x2F;&#x2F;前右
    EXTIX_Init_C8();	&#x2F;&#x2F;后左
    EXTIX_Init_C12();	&#x2F;&#x2F;后右
&#125;
&#x2F;&#x2F;PA5  中断初始化  用于四个电机的编码器 前左(其余3个配置一样只是中断线不一样)
void EXTIX_Init_A5(void)
&#123;
    NVIC_InitTypeDef   NVIC_InitStructure;	&#x2F;&#x2F;定义结构体
    EXTI_InitTypeDef   EXTI_InitStructure;

    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);		&#x2F;&#x2F;中断分组2
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);	&#x2F;&#x2F;使用外部中断必须要使能的时钟
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource5);	&#x2F;&#x2F;把A组引脚5设置为外部中断5
	
    EXTI_InitStructure.EXTI_Line &#x3D; EXTI_Line5;	&#x2F;&#x2F;5号线
    EXTI_InitStructure.EXTI_Mode &#x3D; EXTI_Mode_Interrupt; &#x2F;&#x2F;中断模式
    EXTI_InitStructure.EXTI_Trigger &#x3D; EXTI_Trigger_Rising_Falling;&#x2F;&#x2F;下降沿触发
    EXTI_InitStructure.EXTI_LineCmd &#x3D; ENABLE;	&#x2F;&#x2F;使能中断
    EXTI_Init(&amp;EXTI_InitStructure);	&#x2F;&#x2F;初始化

    NVIC_InitStructure.NVIC_IRQChannel &#x3D; EXTI9_5_IRQn;	&#x2F;&#x2F;中断通道选择
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 0x01;	&#x2F;&#x2F;抢占优先级
    NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0x00;	&#x2F;&#x2F;子优先级
    NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;	&#x2F;&#x2F;使能通道
    NVIC_Init(&amp;NVIC_InitStructure);	&#x2F;&#x2F;初始化

    GPIO_init(GPIO_A, GPIO_Pin_5, GPIO_Mode_IN, GPIO_OType_OD, GPIO_PuPd_UP);	&#x2F;&#x2F;输入，开漏，上拉
&#125;

&#x2F;&#x2F;底盘电机 初始化
void moto_car_init(void)
&#123;
    TIM1_CH1_PWM_Init_PE9(1000, 8); &#x2F;&#x2F;前左轮的 PWM初始化
    TIM1_CH2_PWM_Init_PE11(1000, 8); &#x2F;&#x2F;前右的 PWM初始化
    TIM1_CH4_PWM_Init_PE14(1000, 8); &#x2F;&#x2F;后左的 PWM初始化
    TIM1_CH3_PWM_Init_PE13(1000, 8); &#x2F;&#x2F;后右的 PWM初始化

    GPIO_init(GPIO_B, GPIO_Pin_15, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;前左轮的转动方向控制端口初始化
    GPIO_init(GPIO_B, GPIO_Pin_8, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;前右
    GPIO_init(GPIO_G, GPIO_Pin_13, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;后左
    GPIO_init(GPIO_G, GPIO_Pin_12, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;后右

    MOTO_0_F;&#x2F;&#x2F;前左轮 默认向前转
    MOTO_1_F;&#x2F;&#x2F;前右
    MOTO_2_F;&#x2F;&#x2F;后左
    MOTO_3_F;&#x2F;&#x2F;后右

    TIM_SetCompare1(TIM1, 0); &#x2F;&#x2F;0-100   前左轮 PWM输出设置为0  先不转
    TIM_SetCompare2(TIM1, 0); &#x2F;&#x2F;0-100		前右轮
    TIM_SetCompare4(TIM1, 0); &#x2F;&#x2F;0-100		后左轮
    TIM_SetCompare3(TIM1, 0); &#x2F;&#x2F;0-100		后右轮
&#125;
&#x2F;&#x2F;TIM1_CH3   PE13   PWM    前左轮
&#x2F;&#x2F;参数：1000, 8
&#x2F;&#x2F;剩下3个配置也一样管脚不一样而已
void TIM1_CH3_PWM_Init_PE13(u32 arr, u32 psc)
&#123;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;	&#x2F;&#x2F;定义结构体
    TIM_OCInitTypeDef TIM_OCInitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);	&#x2F;&#x2F;使能TIM1时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);	&#x2F;&#x2F;使能E组时钟

    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;	&#x2F;&#x2F;复用
    GPIO_InitStructure.GPIO_OType &#x3D; GPIO_OType_PP;	&#x2F;&#x2F;推挽
    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_13;	&#x2F;&#x2F;PE^13
    GPIO_InitStructure.GPIO_PuPd &#x3D; GPIO_PuPd_NOPULL;	&#x2F;&#x2F;无上下拉
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_100MHz;	&#x2F;&#x2F;速度
    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);

    GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_TIM1);	&#x2F;&#x2F;把PE^13复用为TIM1

    TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; TIM_CKD_DIV1;	&#x2F;&#x2F;分频因子
    TIM_TimeBaseStructure.TIM_CounterMode &#x3D; TIM_CounterMode_Up;	&#x2F;&#x2F;向上计数
    TIM_TimeBaseStructure.TIM_Prescaler &#x3D; psc;	&#x2F;&#x2F;预分频系数
    TIM_TimeBaseStructure.TIM_RepetitionCounter &#x3D; 0;	&#x2F;&#x2F;默认
    TIM_TimeBaseStructure.TIM_Period &#x3D; arr;	&#x2F;&#x2F;重装载值

    TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure);	&#x2F;&#x2F;初始化

    TIM_OCInitStructure.TIM_OCMode &#x3D; TIM_OCMode_PWM1;	&#x2F;&#x2F;PWM1模式 CNT &lt; CCR1为有效电平
    TIM_OCInitStructure.TIM_OutputState &#x3D; TIM_OutputState_Enable; &#x2F;&#x2F;使能输出比较模式
    TIM_OCInitStructure.TIM_OutputNState &#x3D; TIM_OutputNState_Enable;&#x2F;&#x2F;使能互补输出
    TIM_OCInitStructure.TIM_Pulse &#x3D; (arr + 1) &#x2F; 2;
    TIM_OCInitStructure.TIM_OCPolarity &#x3D; TIM_OCPolarity_High; &#x2F;&#x2F; 输出比较极性高
    TIM_OCInitStructure.TIM_OCNPolarity &#x3D; TIM_OCPolarity_High;&#x2F;&#x2F; 互补输出极性高
    TIM_OCInitStructure.TIM_OCIdleState &#x3D; TIM_OCIdleState_Set;&#x2F;&#x2F;MOE&#x3D;0 设置TIM1输出比较空闲
    TIM_OCInitStructure.TIM_OCNIdleState &#x3D; TIM_OCNIdleState_Reset;&#x2F;&#x2F;MOE&#x3D;0 重置TIM1输出比较空闲状态

    TIM_OC3Init(TIM1, &amp;TIM_OCInitStructure);
    TIM_Cmd(TIM1, ENABLE);

    TIM_CtrlPWMOutputs(TIM1, ENABLE);	&#x2F;&#x2F;高级定时器必须要加
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_Timer_eval.c*************************&#x2F;
&#x2F;&#x2F;TIM5中断服务函数
void TIM5_IRQHandler(void)
&#123;
    if(TIM_GetITStatus(TIM5, TIM_IT_Update) !&#x3D; RESET)	&#x2F;&#x2F;当触发中断
    &#123;
        TIM_ClearITPendingBit(TIM5, TIM_IT_Update);	&#x2F;&#x2F;清除标志位
        &#x2F;&#x2F;PG9_L;
        timer_interrupt_fun();
        &#x2F;&#x2F;PG9_H;
    &#125;
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************Car.c*************************&#x2F;
&#x2F;&#x2F;定时器5中断要执行的函数
void timer_interrupt_fun(void)&#x2F;&#x2F;定时器中需要运行的函数
&#123;
    timer5_speed_calculation_fun();&#x2F;&#x2F;计算4个轮子的速度  和 求平均后 计算小车走的距离

    if(Tracing_dis_bit)&#x2F;&#x2F;是否需要寻迹走
    &#123;
        timer_Tracing_fun();&#x2F;&#x2F;寻迹走函数
        chack_MAG_fun();		&#x2F;&#x2F;检查是否有十字磁条或者左转磁条
    &#125;

    if(speed_PID_bit)&#x2F;&#x2F;是否需要4个轮子的速度PID
    &#123;
        timer5_speed_0_pid_fun(speed_set_mun_L);
        timer5_speed_1_pid_fun(speed_set_mun_R);
        timer5_speed_2_pid_fun(speed_set_mun_L);
        timer5_speed_3_pid_fun(speed_set_mun_R);
    &#125;


&#125;
&#x2F;&#x2F;在定时器5中断中执行的函数  记录转速  记录路程
void timer5_speed_calculation_fun(void)
&#123;
    u8 i;

    speed_avg &#x3D; 0;
    for(i &#x3D; 0; i &lt; 4; i++)
    &#123;
        speed_actual[i] &#x3D; speed_count[i];&#x2F;&#x2F;记录速度     speed_count是在编码器中断中累加的
        speed_count[i] &#x3D; 0;&#x2F;&#x2F;一个计数周期清零

        speed_avg &#x3D; speed_avg + speed_actual[i];&#x2F;&#x2F;速度求和
    &#125;

    speed_avg &#x3D; speed_avg &#x2F; 4;&#x2F;&#x2F;速度求平均

    distance_now_u32 &#x3D; distance_now_u32 + speed_avg;&#x2F;&#x2F;累计走形距离    distance_now_u32是小车走的距离计数
&#125;</code></pre>
<h4 id="磁条传感器-走-夹过程">磁条传感器/走+夹过程</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF^2</td>
<td style="text-align:center">MAG_1</td>
<td style="text-align:center">输入，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PD^9</td>
<td style="text-align:center">MAG_2</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^4</td>
<td style="text-align:center">MAG_3</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^3</td>
<td style="text-align:center">MAG_4</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PB^13</td>
<td style="text-align:center">MAG_5</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^1</td>
<td style="text-align:center">MAG_6</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PE^1</td>
<td style="text-align:center">MAG_7</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PD^12</td>
<td style="text-align:center">MAG_8</td>
<td style="text-align:center">同上</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************Car_init.c*************************&#x2F;
&#x2F;&#x2F;磁条传感器端口初始化
void gpio_MAG_init_all(void)
&#123;
    GPIO_init(GPIO_F, GPIO_Pin_2, GPIO_Mode_IN, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;F2
    GPIO_init(GPIO_D, GPIO_Pin_9, GPIO_Mode_IN, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;D9
    GPIO_init(GPIO_F, GPIO_Pin_4, GPIO_Mode_IN, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;F4
    GPIO_init(GPIO_F, GPIO_Pin_3, GPIO_Mode_IN, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;F3
    GPIO_init(GPIO_B, GPIO_Pin_13, GPIO_Mode_IN, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;B13
    GPIO_init(GPIO_F, GPIO_Pin_1, GPIO_Mode_IN, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;F1
    GPIO_init(GPIO_E, GPIO_Pin_1, GPIO_Mode_IN, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;E1
    GPIO_init(GPIO_D, GPIO_Pin_12, GPIO_Mode_IN, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;D12
&#125;</code></pre>
<ul>
<li>4个托盘的距离+4个集中站距离</li>
<li><code>Tracing_to_cross_and_dis_fun</code> 函数：走过十字磁条后再走一段距离，参数 <code>tuopan_dis[x]</code> 是第几个托盘的距离(x分别是0,1,2,3)；前提必须是在起点，不能在任意一个托盘前再执行走到另一个托盘</li>
<li><code>car_move_back_fun</code> 函数：小车后退多少个距离</li>
<li><code>Tracing_to_L_fun</code> 函数：走到第一个左转(前3个转弯的参数都是1，第4个转弯参数是3，这样会回到原点)</li>
<li><code>car_turn_L_fun</code> 函数：左转90度</li>
<li><code>find_MAG_fun</code> 函数：转弯后车身修正(防止偏离路线)</li>
<li><code>arm_0_L</code> 函数：整个机械臂左转多少脉冲(参数是数字，一个个试)；<code>arm_0_R</code> 函数：整个机械臂右转多少脉冲(参数是数字，一个个试)</li>
<li><code>arm_1_F</code> 函数：大臂向前多少脉冲；<code>arm_1_B</code> 函数：大臂向后多少脉冲</li>
<li><code>arm_2_DN</code> 函数：小臂向前多少脉冲；<code>arm_2_UP</code> 函数：小臂向后多少脉冲</li>
<li>关于夹子夹托盘的东西需要考虑 <code>走到托盘的距离</code> + <code>底盘转的角度</code> + <code>大小臂的角度</code> + <code>激光扫描后的向右偏移多少的问题</code>(有可能第一个托盘可以但是到第4个托盘参数就会不适用就得又改，改到通用4个托盘为止，也可以用判断语句每个托盘的参数都不一样用if进入)</li>
</ul>
<p>测试代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;测试走到设定托盘夹完东西走一圈到原点(不丢到垃圾桶)		
Tracing_to_cross_and_dis_fun(tuopan_dis[3]);
arm_pick_up_block_fun();
car_move_back_fun(500);&#x2F;&#x2F;小车后退300个距离
Tracing_to_L_fun(1);&#x2F;&#x2F;走到第一个左转
car_turn_L_fun();&#x2F;&#x2F;自己左转90度
find_MAG_fun();&#x2F;&#x2F;小车车身修正磁条
Tracing_to_L_fun(1);&#x2F;&#x2F;一直走到左转磁条
car_turn_L_fun();&#x2F;&#x2F;左转90度
find_MAG_fun();&#x2F;&#x2F;摆正车身
Tracing_to_L_fun(1);&#x2F;&#x2F;走到左转位置
car_turn_L_fun();&#x2F;&#x2F;左转90度
find_MAG_fun();&#x2F;&#x2F;修正车身
Tracing_to_L_fun(3);&#x2F;&#x2F;走到第三个左转磁条
car_turn_L_fun();&#x2F;&#x2F;左转90度
find_MAG_fun();&#x2F;&#x2F;修正车身</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.h*************************&#x2F;
&#x2F;&#x2F;小车走 托盘的4个距离  
# define TUOPAN_DIS_0		20				  &#x2F;&#x2F;210
# define TUOPAN_DIS_1		1000				&#x2F;&#x2F;1100
# define TUOPAN_DIS_2		1970				&#x2F;&#x2F;1900
# define TUOPAN_DIS_3		2870				&#x2F;&#x2F;2700




&#x2F;&#x2F;小车走 集中站的4个距离
# define JIZHONGZHAN_DIS_0		0
# define JIZHONGZHAN_DIS_1		90
# define JIZHONGZHAN_DIS_2		1920
# define JIZHONGZHAN_DIS_3		3645</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
u32 tuopan_dis[4];								&#x2F;&#x2F;托盘4个距离
u32 jizhongzhan_dis[4];						&#x2F;&#x2F;集中站4个距离


void ram_init(void)&#x2F;&#x2F;小车在转盘路 走的4个距离    集中站路 走的4个距离 赋值
&#123;
	tuopan_dis[0] &#x3D; TUOPAN_DIS_0;&#x2F;&#x2F;
	tuopan_dis[1] &#x3D; TUOPAN_DIS_1;&#x2F;&#x2F;
	tuopan_dis[2] &#x3D; TUOPAN_DIS_2;&#x2F;&#x2F;
	tuopan_dis[3] &#x3D; TUOPAN_DIS_3;&#x2F;&#x2F;

	jizhongzhan_dis[0] &#x3D; JIZHONGZHAN_DIS_0;&#x2F;&#x2F;
	jizhongzhan_dis[1] &#x3D; JIZHONGZHAN_DIS_1;&#x2F;&#x2F;
	jizhongzhan_dis[2] &#x3D; JIZHONGZHAN_DIS_2;&#x2F;&#x2F;
	jizhongzhan_dis[3] &#x3D; JIZHONGZHAN_DIS_3;&#x2F;&#x2F;
&#125;
&#x2F;&#x2F;执行从托盘拿物块 送到集中站的全部过程
void Grab_garbage_fun(u8 tuopan,u8 jizhongzhan)&#x2F;&#x2F;小车从起始点开始  抓取物块  走到集中站   tuopan是托盘编号  jizhongzhan 是集中站编号    走到起点
&#123;
	&#x2F;&#x2F;转盘路
	Tracing_to_cross_and_dis_fun(tuopan_dis[tuopan]);&#x2F;&#x2F;走过十字磁条后再走一段距离    tuopan_dis[1]是第一个距离
	delay_ms(1000);
	arm_pick_up_block_fun();&#x2F;&#x2F;机械臂抓物块 全部动作
	car_move_back_fun(500);&#x2F;&#x2F;小车后退300个距离
	Tracing_to_L_fun(1);&#x2F;&#x2F;走到第一个左转
	car_turn_L_fun();&#x2F;&#x2F;自己左转90度
	find_MAG_fun();&#x2F;&#x2F;小车车身修正磁条
	
	&#x2F;&#x2F;垃圾桶路
	Tracing_to_L_fun(1);&#x2F;&#x2F;一直走到左转磁条
	car_turn_L_fun();&#x2F;&#x2F;左转90度
	find_MAG_fun();&#x2F;&#x2F;摆正车身
	
	&#x2F;&#x2F;集中站路
	if(jizhongzhan&#x3D;&#x3D;0)&#x2F;&#x2F;如果是集中站第一个门
	&#123;
		car_move_back_fun(100);&#x2F;&#x2F;小车后退100个距离
		
		send_cmd_to_Concentration_station_fun(DOOR_OPEN,jizhongzhan);&#x2F;&#x2F;通过串口2给集中站发送开门命令 DOOR_OPEN是开门的命令 jizhongzhan是集中站第几个门
		jizhongzhan_fun();&#x2F;&#x2F;机械臂扔集中站全部动作
		send_cmd_to_Concentration_station_fun(DOOR_CLOSE,jizhongzhan);&#x2F;&#x2F;通过串口2发送关门命令
		
		car_move_forward_fun(100);&#x2F;&#x2F;小车向前移动100个距离
		
		Tracing_to_L_fun(1);&#x2F;&#x2F;小车走到左转位置
		car_turn_L_fun();&#x2F;&#x2F;左转90度
		find_MAG_fun();&#x2F;&#x2F;依据修正车身
	&#125;
	if((jizhongzhan&#x3D;&#x3D;1)||(jizhongzhan&#x3D;&#x3D;2))&#x2F;&#x2F;如果是集中站的2门和3门
	&#123;
		Tracing_to_cross_and_dis_fun(jizhongzhan_dis[jizhongzhan]);&#x2F;&#x2F;小车走过十字磁条后再走一段距离
		send_cmd_to_Concentration_station_fun(DOOR_OPEN,jizhongzhan);&#x2F;&#x2F;发送开门命令
		jizhongzhan_fun();&#x2F;&#x2F;机械臂扔集中站全部动作
		send_cmd_to_Concentration_station_fun(DOOR_CLOSE,jizhongzhan);&#x2F;&#x2F;小车发送关门命令
		
		Tracing_to_L_fun(1);&#x2F;&#x2F;走到左转位置
		car_turn_L_fun();&#x2F;&#x2F;左转90度
		find_MAG_fun();&#x2F;&#x2F;修正车身
	&#125;
	if(jizhongzhan&#x3D;&#x3D;3)&#x2F;&#x2F;如果是第四个门
	&#123;
		&#x2F;&#x2F;Tracing_to_cross_and_dis_fun(jizhongzhan_dis[jizhongzhan]);&#x2F;&#x2F;走过十字磁条后 再走一段距离
		Tracing_to_L_fun(1);&#x2F;&#x2F;走到左转位置
		send_cmd_to_Concentration_station_fun(DOOR_OPEN,jizhongzhan);&#x2F;&#x2F;发送开门命令
		jizhongzhan_fun();&#x2F;&#x2F;扔集中站
		send_cmd_to_Concentration_station_fun(DOOR_CLOSE,jizhongzhan);&#x2F;&#x2F;发送关门命令
		
		car_turn_L_fun();&#x2F;&#x2F;左转90度
		find_MAG_fun();&#x2F;&#x2F;修正车身
	&#125;
	
	&#x2F;&#x2F;车库路
	Tracing_to_L_fun(3);&#x2F;&#x2F;走到第三个左转磁条
	car_turn_L_fun();&#x2F;&#x2F;左转90度
	find_MAG_fun();&#x2F;&#x2F;修正车身

&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************car.c*************************&#x2F;
void Tracing_to_cross_and_dis_fun(u32 dis)&#x2F;&#x2F;寻迹走到十字后再走一定距离
&#123;
    u8 i;

    MOTO_0_F;	&#x2F;&#x2F;轮子方向控制(默认向前)
    MOTO_1_F;
    MOTO_2_F;
    MOTO_3_F;

    speed_PID_data_init();	&#x2F;&#x2F;PID清0

    distance_now_u32 &#x3D; 0;

    speed_set_mun_L &#x3D; 0;
    speed_set_mun_R &#x3D; 0;

    Tracing_dis_bit &#x3D; 1;

    ok_bit &#x3D; 1;

    shizi_bit &#x3D; 0;

    &#x2F;&#x2F;缓启动
    for(i &#x3D; 0; i &lt; 20; i++)
    &#123;
        speed_set_mun_L++;
        speed_set_mun_R++;
        delay_ms(25);

        &#x2F;&#x2F;if(chack_MAG_fun()&#x3D;&#x3D;1)
        if(shizi_bit &#x3D;&#x3D; 1)
        &#123;
            ok_bit &#x3D; 0;
            distance_now_u32 &#x3D; 0;
        &#125;
    &#125;

    if(ok_bit &#x3D;&#x3D; 1)
    &#123;
        while(ok_bit)
        &#123;
            &#x2F;&#x2F;if(chack_MAG_fun()&#x3D;&#x3D;1)
            if(shizi_bit &#x3D;&#x3D; 1)
            &#123;
                ok_bit &#x3D; 0;
                distance_now_u32 &#x3D; 0;
            &#125;
        &#125;
    &#125;



    ok_bit &#x3D; 1;
    while(ok_bit)
    &#123;
        if(distance_now_u32 &gt;&#x3D; dis)
        &#123;
            ok_bit &#x3D; 0;
        &#125;
    &#125;


    speed_set_mun_L &#x3D; 20;
    speed_set_mun_R &#x3D; 20;

    for(i &#x3D; 0; i &lt; 20; i++)
    &#123;
        speed_set_mun_L--;
        speed_set_mun_R--;
        delay_ms(50);
    &#125;

    car_pwm_stop();
&#125;
void speed_PID_data_init(void)&#x2F;&#x2F;4个车轮PID参数 清零 在运行PID程序之前  调用
&#123;
    u8 i;

    for(i &#x3D; 0; i &lt; 4; i++)
    &#123;
        e[i] &#x3D; 0;
        num[i] &#x3D; 0;
        duk[i] &#x3D; 0;
        e1[i] &#x3D; 0;
        uk[i] &#x3D; 0;
        uk1[i] &#x3D; 0;
        out[i] &#x3D; 0;
        e2[i] &#x3D; 0;
        PWMTime[i] &#x3D; 0;
    &#125;
&#125;
void timer_Tracing_fun(void)&#x2F;&#x2F;&#x2F;&#x2F;寻迹走 定时器5中断函数中 运行
&#123;
    u16 speed_Tracing_L;
    u16 speed_Tracing_R;


    MAG_dat &#x3D; mag_test();&#x2F;&#x2F;读磁条

    &#x2F;&#x2F;printf(&quot;%d\r\n&quot;,MAG_dat);


    if(MAG_dat &#x3D;&#x3D; 0)
    &#123;
        speed_Tracing_L &#x3D; speed_set_mun_L;
        speed_Tracing_R &#x3D; speed_set_mun_R;
    &#125;
    else if((MAG_dat &gt; 0) &amp;&amp; (MAG_dat &lt;&#x3D; 4)) &#x2F;&#x2F;1到4之间  磁条在右边   小车偏左   左边加速
    &#123;
        speed_Tracing_L &#x3D; gain_fun(speed_set_mun_L, 0.2);
        speed_Tracing_R &#x3D; gain_fun(speed_set_mun_R, -0.2);
    &#125;
    else if((MAG_dat &gt;&#x3D; 5) &amp;&amp; (MAG_dat &lt;&#x3D; 7)) &#x2F;&#x2F;5到7之间  磁条在右边   小车偏左   左边加速
    &#123;
        speed_Tracing_L &#x3D; gain_fun(speed_set_mun_L, 0.4);
        speed_Tracing_R &#x3D; gain_fun(speed_set_mun_R, -0.4);
    &#125;
    else if((MAG_dat &lt; 0) &amp;&amp; (MAG_dat &gt;&#x3D; -4)) &#x2F;&#x2F;-1到-4  磁条在左边   小车偏右   右边加速
    &#123;
        speed_Tracing_L &#x3D; gain_fun(speed_set_mun_L, -0.2);
        speed_Tracing_R &#x3D; gain_fun(speed_set_mun_R, 0.2);
    &#125;
    else if((MAG_dat &lt;&#x3D; -5) &amp;&amp; (MAG_dat &gt;&#x3D; -7)) &#x2F;&#x2F;-5到-7  磁条在左边   小车偏右   右边加速
    &#123;
        speed_Tracing_L &#x3D; gain_fun(speed_set_mun_L, -0.4);
        speed_Tracing_R &#x3D; gain_fun(speed_set_mun_R, 0.4);
    &#125;
    else if(MAG_dat &#x3D;&#x3D; 200) &#x2F;&#x2F;跑出磁条了
    &#123;
        car_pwm_stop();&#x2F;&#x2F;小车停止
        bell_fun(3);&#x2F;&#x2F;蜂鸣器响3下
    &#125;
    else
    &#123;
        speed_Tracing_L &#x3D; speed_set_mun_L;&#x2F;&#x2F;设置左边轮子速度
        speed_Tracing_R &#x3D; speed_set_mun_R;&#x2F;&#x2F;设置右边轮子速度
    &#125;

    timer5_speed_0_pid_fun(speed_Tracing_L);&#x2F;&#x2F;设置4个轮字的PID转速
    timer5_speed_1_pid_fun(speed_Tracing_R);&#x2F;&#x2F;
    timer5_speed_2_pid_fun(speed_Tracing_L);&#x2F;&#x2F;
    timer5_speed_3_pid_fun(speed_Tracing_R);&#x2F;&#x2F;
&#125;</code></pre>
<h4 id="机械臂-舵机">机械臂/舵机</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221115213542.jpg" alt=" "></p>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF^14</td>
<td style="text-align:center">JXB01</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PE^8</td>
<td style="text-align:center">JXB02</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PE^10</td>
<td style="text-align:center">JXB11</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^13</td>
<td style="text-align:center">JXB12</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^12</td>
<td style="text-align:center">JXB21</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^11</td>
<td style="text-align:center">JXB22</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^15</td>
<td style="text-align:center">TJ1(机械臂复位)</td>
<td style="text-align:center">输入，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PG^0</td>
<td style="text-align:center">TJ2(机械臂复位)</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PG^1</td>
<td style="text-align:center">TJ3(机械臂复位)</td>
<td style="text-align:center">同上</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PB^0(TIM3_CH3)</td>
<td style="text-align:center">DJ</td>
<td style="text-align:center">50Hz(20ms)</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.h*************************&#x2F;
# define STEERING_ENGINE_OPEN		335			&#x2F;&#x2F;爪子张开时舵机的参数				舵机张开不能太大  会卡住  卡住会发热</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************Mechanical_arm.h*************************&#x2F;
# define JXB01_L		(GPIOF-&gt;BSRRH &#x3D; GPIO_Pin_14)&#x2F;&#x2F;小臂脉冲
# define JXB01_H		(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_14)&#x2F;&#x2F;
# define	JXB01_PP		GPIOF-&gt;ODR^&#x3D;GPIO_Pin_14

# define JXB02_UP		(GPIOE-&gt;BSRRH &#x3D; GPIO_Pin_8)&#x2F;&#x2F;小臂上
# define JXB02_DN		(GPIOE-&gt;BSRRL &#x3D; GPIO_Pin_8)&#x2F;&#x2F;小臂下

# define JXB11_L		(GPIOE-&gt;BSRRH &#x3D; GPIO_Pin_10)&#x2F;&#x2F;底盘脉冲
# define JXB11_H		(GPIOE-&gt;BSRRL &#x3D; GPIO_Pin_10)&#x2F;&#x2F;

# define JXB12_R		(GPIOF-&gt;BSRRH &#x3D; GPIO_Pin_13)&#x2F;&#x2F;底盘右
# define JXB12_L		(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_13)&#x2F;&#x2F;底盘左

# define JXB21_L		(GPIOF-&gt;BSRRH &#x3D; GPIO_Pin_12)&#x2F;&#x2F;大臂脉冲
# define JXB21_H		(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_12)&#x2F;&#x2F;

# define JXB22_F		(GPIOF-&gt;BSRRH &#x3D; GPIO_Pin_11)&#x2F;&#x2F;大臂前
# define JXB22_B		(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_11)&#x2F;&#x2F;大臂后

&#x2F;&#x2F;机械臂复位
# define JSB_W1_Input		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_15)&#x2F;&#x2F;F15
# define JSB_W2_Input		GPIO_ReadInputDataBit(GPIOG,GPIO_Pin_0)&#x2F;&#x2F;G0
# define JSB_W3_Input		GPIO_ReadInputDataBit(GPIOG,GPIO_Pin_1)&#x2F;&#x2F;G1</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************Mechanical_arm.c*************************&#x2F;
&#x2F;&#x2F;机械臂全部端口初始化
void gpio_arm_init(void)
&#123;
	&#x2F;&#x2F;机械臂控制输出
	GPIO_init(GPIO_F,GPIO_Pin_11,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;F11
	GPIO_init(GPIO_F,GPIO_Pin_12,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;F12
	GPIO_init(GPIO_F,GPIO_Pin_13,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;F13
	GPIO_init(GPIO_E,GPIO_Pin_10,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;E10
	GPIO_init(GPIO_E,GPIO_Pin_8,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;E8
	GPIO_init(GPIO_F,GPIO_Pin_14,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;F14
	
	&#x2F;&#x2F;机械臂归位信号输入
	GPIO_init(GPIO_F,GPIO_Pin_15,GPIO_Mode_IN,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;F15
	GPIO_init(GPIO_G,GPIO_Pin_14,GPIO_Mode_IN,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;G0
	GPIO_init(GPIO_G,GPIO_Pin_14,GPIO_Mode_IN,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;G1
	
	
	TIM3_CH3_PWM_Init_PB0(5000-1,336-1);&#x2F;&#x2F;夹子舵机初始化调用  50HZ  20MS
	
	steering_engine(STEERING_ENGINE_OPEN);	&#x2F;&#x2F;夹子舵机 设置位置
&#125;

&#x2F;&#x2F;TIM3_CH3   PB0   PWM   舵机    0.5ms  2.5ms
&#x2F;&#x2F;参数：5000-1,336-1
void TIM3_CH3_PWM_Init_PB0(u32 arr,u32 psc)&#x2F;&#x2F;    小车机械臂  夹子的 舵机初始化  舵机是PWM控制的
&#123; 
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;	&#x2F;&#x2F;定义结构体
	TIM_OCInitTypeDef TIM_OCInitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);	&#x2F;&#x2F;使能TIM3时钟
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);	&#x2F;&#x2F;使能B组时钟
	
	GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;	&#x2F;&#x2F;复用
	GPIO_InitStructure.GPIO_OType &#x3D; GPIO_OType_PP;	&#x2F;&#x2F;推挽
	GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_0;	&#x2F;&#x2F;PB^0
	GPIO_InitStructure.GPIO_PuPd &#x3D; GPIO_PuPd_NOPULL;	&#x2F;&#x2F;没上下拉
	GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_100MHz;	&#x2F;&#x2F;速度
	GPIO_Init(GPIOB,&amp;GPIO_InitStructure);	&#x2F;&#x2F;初始化
	
	GPIO_PinAFConfig(GPIOB,GPIO_PinSource0,GPIO_AF_TIM3);	&#x2F;&#x2F;把管脚PB^0复用为TIM3
	
	TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; TIM_CKD_DIV1;	&#x2F;&#x2F;分频因子
	TIM_TimeBaseStructure.TIM_CounterMode &#x3D; TIM_CounterMode_Up;	&#x2F;&#x2F;向上计数
	TIM_TimeBaseStructure.TIM_Prescaler &#x3D; psc;	&#x2F;&#x2F;预分频值
	TIM_TimeBaseStructure.TIM_RepetitionCounter &#x3D; 0; 	&#x2F;&#x2F;默认
	TIM_TimeBaseStructure.TIM_Period &#x3D; arr;	&#x2F;&#x2F;重装载值
	
	TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseStructure);	&#x2F;&#x2F;初始化
	
	TIM_OCInitStructure.TIM_OCMode &#x3D; TIM_OCMode_PWM1;	&#x2F;&#x2F;PWM1模式
	TIM_OCInitStructure.TIM_OutputState &#x3D; TIM_OutputState_Enable;	&#x2F;&#x2F;开启OC输出到对应引脚
	TIM_OCInitStructure.TIM_OutputNState &#x3D; TIM_OutputNState_Enable;	&#x2F;&#x2F;互补输出使能
	TIM_OCInitStructure.TIM_Pulse &#x3D; (arr+1)&#x2F;2;	&#x2F;&#x2F;占空比
	TIM_OCInitStructure.TIM_OCPolarity &#x3D; TIM_OCPolarity_High;	&#x2F;&#x2F;极性高
	TIM_OCInitStructure.TIM_OCNPolarity &#x3D; TIM_OCPolarity_High;	&#x2F;&#x2F;互补通道极性高
	TIM_OCInitStructure.TIM_OCIdleState &#x3D; TIM_OCIdleState_Set;	&#x2F;&#x2F;空闲状态输出高电平
	TIM_OCInitStructure.TIM_OCNIdleState &#x3D; TIM_OCNIdleState_Reset;	&#x2F;&#x2F;互补通道的空闲时输出低电平
	
	TIM_OC3Init(TIM3,&amp;TIM_OCInitStructure);	&#x2F;&#x2F;初始化
	TIM_Cmd(TIM3,ENABLE);	&#x2F;&#x2F;使能TIM3
	
	TIM_CtrlPWMOutputs(TIM3,ENABLE);	&#x2F;&#x2F;可有可无
	
	&#x2F;&#x2F;TIM_SetCompare3(TIM3,350);&#x2F;&#x2F;620&#x3D;2.5ms    125&#x3D;0.5ms   370&#x3D;1.5ms    620是夹住   125是放开
&#125;
&#x2F;&#x2F;夹子舵机 设置位置  
void steering_engine(u16 dat)
&#123;
	TIM_SetCompare3(TIM3,dat);&#x2F;&#x2F;620&#x3D;2.5ms    125&#x3D;0.5ms   370&#x3D;1.5ms    620是夹住   125是放开
&#125;
&#x2F;&#x2F;机械臂 底盘 大臂 小臂  依次归位
void arm_position_init_all(void)
&#123;
	arm0_position_init();
	delay_ms(500);
	arm1_position_init();
	delay_ms(500);
	arm2_position_init();
	delay_ms(500);
	
	&#x2F;&#x2F;可以在这里添加下面的 机械臂控制函数  达到调整的目的
	arm_2_UP(90);&#x2F;&#x2F;小臂向上
	arm_1_B(80);&#x2F;&#x2F;大臂向后
	
	
	&#x2F;*
	&#x2F;&#x2F;下面是控制 大臂 和 小臂的 函数   参数是脉冲数  根据需要修改大小 20只是示意   需要哪个就复制哪个到上面
	arm_1_F(20);&#x2F;&#x2F;大臂向前
	arm_1_B(20);&#x2F;&#x2F;大臂向后
	arm_2_UP(20);&#x2F;&#x2F;小臂向上
	arm_2_DN(20);&#x2F;&#x2F;小臂向下
	*&#x2F;
&#125;
&#x2F;&#x2F;机械臂大臂 归位
void arm1_position_init(void)
&#123;
	u8 ok_bit&#x3D;1;
	u8 read_bit;
	u16 count;
	
	count &#x3D; 0;
	
	read_bit &#x3D; JSB_W2_Input;
	
	if(read_bit&#x3D;&#x3D;0)&#x2F;&#x2F;在原位
	&#123;
		&#x2F;&#x2F;需要伸出  直到出去
		while(ok_bit)
		&#123;
			JXB22_F;&#x2F;&#x2F;向前
			JXB21_H;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			JXB21_L;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			
			read_bit &#x3D; JSB_W2_Input;
			
			if(read_bit&#x3D;&#x3D;1)
			&#123;
				ok_bit &#x3D; 0;
			&#125;
			
			count++;
			if(count&gt;&#x3D;200)
			&#123;
				ok_bit &#x3D; 0;
				bell_fun(3);
			&#125;
		&#125;
		
		arm_1_F(20);
		
		ok_bit &#x3D; 1;
		
		while(ok_bit)
		&#123;
			JXB22_B;&#x2F;&#x2F;向后
			JXB21_H;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			JXB21_L;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			
			read_bit &#x3D; JSB_W2_Input;
			
			if(read_bit&#x3D;&#x3D;0)
			&#123;
				ok_bit &#x3D; 0;
			&#125;
		&#125;
	&#125;
	else
	&#123;
		arm_1_F(120);
		
		read_bit &#x3D; JSB_W2_Input;
		
		if(read_bit&#x3D;&#x3D;0)&#x2F;&#x2F;在原位
		&#123;
			&#x2F;&#x2F;需要伸出  直到出去
			while(ok_bit)
			&#123;
				JXB22_F;&#x2F;&#x2F;向前
				JXB21_H;&#x2F;&#x2F;给脉冲
				delay_ms(TIME_arm);
				JXB21_L;&#x2F;&#x2F;给脉冲
				delay_ms(TIME_arm);
				
				read_bit &#x3D; JSB_W2_Input;
				
				if(read_bit&#x3D;&#x3D;1)
				&#123;
					ok_bit &#x3D; 0;
				&#125;
				
				count++;
				if(count&gt;&#x3D;200)
				&#123;
					ok_bit &#x3D; 0;
					bell_fun(3);
				&#125;
			&#125;
			
			arm_1_F(20);
			
			ok_bit &#x3D; 1;
			
			while(ok_bit)
			&#123;
				JXB22_B;&#x2F;&#x2F;向后
				JXB21_H;&#x2F;&#x2F;给脉冲
				delay_ms(TIME_arm);
				JXB21_L;&#x2F;&#x2F;给脉冲
				delay_ms(TIME_arm);
				
				read_bit &#x3D; JSB_W2_Input;
				
				if(read_bit&#x3D;&#x3D;0)
				&#123;
					ok_bit &#x3D; 0;
				&#125;
			&#125;
		&#125;
		else
		&#123;
			while(ok_bit)
			&#123;
				JXB22_B;&#x2F;&#x2F;向后
				JXB21_H;&#x2F;&#x2F;给脉冲
				delay_ms(TIME_arm);
				JXB21_L;&#x2F;&#x2F;给脉冲
				delay_ms(TIME_arm);
				
				read_bit &#x3D; JSB_W2_Input;
				
				if(read_bit&#x3D;&#x3D;0)
				&#123;
					ok_bit &#x3D; 0;
				&#125;
			&#125;
		&#125;
	&#125;
	
	arm1_position_now &#x3D; 0;
&#125;



&#x2F;&#x2F;机械臂小臂 归位
void arm2_position_init(void)
&#123;
	u8 ok_bit&#x3D;1;
	u8 read_bit;
	u16 count;
	
	read_bit &#x3D; JSB_W3_Input;
	
	if(read_bit&#x3D;&#x3D;0)&#x2F;&#x2F;在原位
	&#123;
		&#x2F;&#x2F;需要伸出  直到出去
		while(ok_bit)
		&#123;
			JXB02_UP;&#x2F;&#x2F;向上
			JXB01_H;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			JXB01_L;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			
			read_bit &#x3D; JSB_W3_Input;
			
			if(read_bit&#x3D;&#x3D;1)
			&#123;
				ok_bit &#x3D; 0;
			&#125;
			
			count++;
			if(count&gt;&#x3D;300)
			&#123;
				ok_bit &#x3D; 0;
				bell_fun(3);
			&#125;
		&#125;
		
		arm_2_UP(20);
		
		ok_bit &#x3D; 1;
		
		while(ok_bit)
		&#123;
			JXB02_DN;&#x2F;&#x2F;向下
			JXB01_H;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			JXB01_L;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			
			read_bit &#x3D; JSB_W3_Input;
			
			if(read_bit&#x3D;&#x3D;0)
			&#123;
				ok_bit &#x3D; 0;
			&#125;
		&#125;
	&#125;
	else
	&#123;
		while(ok_bit)
		&#123;
			JXB02_DN;&#x2F;&#x2F;向下
			JXB01_H;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			JXB01_L;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			
			read_bit &#x3D; JSB_W3_Input;
			
			if(read_bit&#x3D;&#x3D;0)
			&#123;
				ok_bit &#x3D; 0;
			&#125;
		&#125;
	&#125;
	
	arm2_position_now &#x3D; 0;
&#125;








&#x2F;&#x2F;机械臂底座左右 归位
void arm0_position_init(void)
&#123;
	u8 ok_bit&#x3D;1;
	u8 read_bit;
	u8 read_bit_new;
	u8 read_bit_old;
	
	u16 recode_1 &#x3D; 0;
	u16 recode_2 &#x3D; 0;
	u16 middle;
	u16 i;
	
	read_bit &#x3D; JSB_W1_Input;&#x2F;&#x2F;转盘有洞的位置是1    没有洞的位置时0
	
	if(read_bit&#x3D;&#x3D;1)&#x2F;&#x2F;在中点
	&#123;
		&#x2F;&#x2F;需要伸出  直到出去
		while(ok_bit)
		&#123;
			JXB12_L;&#x2F;&#x2F;向左
			JXB11_H;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			JXB11_L;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			
			read_bit &#x3D; JSB_W1_Input;
			
			if(read_bit&#x3D;&#x3D;0)&#x2F;&#x2F;到了原点边缘
			&#123;
				ok_bit &#x3D; 0;
			&#125;
		&#125;
		
		delay_ms(100);
		
		arm_0_R(26);&#x2F;&#x2F;26个脉冲可以回到洞的 正中心  如果不是  就可以调26这个数据
	&#125;
	else
	&#123;
		arm_0_R(100);
	
		for(i&#x3D;0;i&lt;200;i++)
		&#123;
			read_bit_new &#x3D; JSB_W1_Input; 
			if((read_bit_new&#x3D;&#x3D;1)&amp;&amp;(read_bit_old&#x3D;&#x3D;0)) &#x2F;&#x2F; 第一次在有洞的地方
			&#123;
				recode_1 &#x3D; i;
			&#125;
			if((read_bit_new&#x3D;&#x3D;0)&amp;&amp;(read_bit_old&#x3D;&#x3D;1)) &#x2F;&#x2F; 第一次在没有洞的地方
			&#123;
				recode_2 &#x3D; i;
			&#125;
			
			read_bit_old &#x3D; read_bit_new;
			JXB12_L;&#x2F;&#x2F;向左
			JXB11_H;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			JXB11_L;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			
		&#125;
		
		delay_ms(100);
		
		if((recode_1!&#x3D;0)&amp;&amp;(recode_2!&#x3D;0))
		&#123;
			middle &#x3D; (200 - recode_2) + (recode_2 - recode_1)&#x2F;2;
		
			arm_0_R(middle);
		&#125;
		else
		&#123;
			bell_fun(3);
		&#125;
		
		
		
		&#x2F;&#x2F;再按照第一个步骤 重新校准一下
		while(ok_bit)
		&#123;
			JXB12_L;&#x2F;&#x2F;向左
			JXB11_H;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
			JXB11_L;&#x2F;&#x2F;给脉冲
			delay_ms(TIME_arm);
				
			read_bit &#x3D; JSB_W1_Input;
				
			if(read_bit&#x3D;&#x3D;0)&#x2F;&#x2F;到了原点边缘
			&#123;
				ok_bit &#x3D; 0;
			&#125;
		&#125;
			
		delay_ms(100);
			
		arm_0_R(26);&#x2F;&#x2F;26个脉冲可以回到洞的 正中心  如果不是  就可以调26这个数据
	&#125;
	
	arm0_position_now &#x3D; 0;
&#125;
&#x2F;&#x2F;机械臂大臂  向后
void arm_1_B(u32 mun)
&#123;
	u32 i;
	
	JXB22_B;
	
	for(i&#x3D;0;i&lt;mun;i++)
	&#123;
		JXB21_H;&#x2F;&#x2F;给脉冲
		delay_ms(TIME_arm);
		JXB21_L;
		delay_ms(TIME_arm);
	&#125;
&#125;




&#x2F;&#x2F;小臂 向上
void arm_2_UP(u32 mun)
&#123;
	u32 i;
	
	JXB02_UP;
	for(i&#x3D;0;i&lt;mun;i++)
	&#123;
		JXB01_H;
		delay_ms(TIME_arm);
		JXB01_L;
		delay_ms(TIME_arm);
	&#125;
&#125;</code></pre>
<h4 id="蜂鸣器">蜂鸣器</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PB^9</td>
<td style="text-align:center">FMQ</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************CAR.h*************************&#x2F;
# define BELL_OFF	(GPIOB-&gt;BSRRH &#x3D; GPIO_Pin_9)	&#x2F;&#x2F;低电平不响
# define BELL_ON		(GPIOB-&gt;BSRRL &#x3D; GPIO_Pin_9)	&#x2F;&#x2F;高电平响(NPN管)</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************Car_init.c*************************&#x2F;
&#x2F;&#x2F;蜂鸣器端口 初始化
void gpio_bell_init(void)
&#123;
    GPIO_init(GPIO_B, GPIO_Pin_9, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;B9

    BELL_ON;				&#x2F;&#x2F;蜂鸣器响
    delay_ms(200);	&#x2F;&#x2F;
    BELL_OFF;				&#x2F;&#x2F;蜂鸣器灭
    delay_ms(500);	&#x2F;&#x2F;
&#125;</code></pre>
<h4 id="激光测距">激光测距</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PB^6</td>
<td style="text-align:center">SDA</td>
<td style="text-align:center">输出，开漏，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PD^2</td>
<td style="text-align:center">SCL</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************Car_init.c*************************&#x2F;
&#x2F;&#x2F;激光测距端口初始化
void laser_gpio_init(void)
&#123;
    GPIO_init(GPIO_B, GPIO_Pin_6, GPIO_Mode_OUT, GPIO_OType_OD, GPIO_PuPd_NOPULL); &#x2F;&#x2F;B6		SDA
    GPIO_init(GPIO_D, GPIO_Pin_2, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;D2		SCL
&#125;</code></pre>
<h4 id="串口2无线通信">串口2无线通信</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_Usart_eval.c*************************&#x2F;
void uart2_race_chack(void)&#x2F;&#x2F;检测串口2 是否收到一帧数据
&#123;
    if(usart2_race_over_bit)
    &#123;
        LCD_ShowString_fun(&quot;433race&quot;);&#x2F;&#x2F;屏幕显示

        if(usart2_race_buf[0] &#x3D;&#x3D; 1)	&#x2F;&#x2F;判断是否是小车ID
            LCD_ShowString_fun(&quot;ID&#x3D;1&quot;);
        if(usart2_race_buf[0] &#x3D;&#x3D; 2)
            LCD_ShowString_fun(&quot;ID&#x3D;2&quot;);
        if(usart2_race_buf[0] &#x3D;&#x3D; 3)
            LCD_ShowString_fun(&quot;ID&#x3D;3&quot;);


        copy_fun(usart2_race_buf, cmd_race_buf, usart2_race_count); &#x2F;&#x2F;拷贝usart2_race_buf 串口2接收数组 到 cmd_race_buf     usart2_race_count是拷贝字节数
        usart2_race_over_bit &#x3D; 0;&#x2F;&#x2F;收到一帧数据标志清零
        usart2_race_count &#x3D; 0;&#x2F;&#x2F;接收字节数清零

        delay_ms(1000);&#x2F;&#x2F;转盘发命令会响一声  这里也响一声  延时半秒  能听到发送的嘀和 小车接收的嘀  便于判断  不延时 两个声音会混在一起

        bell_fun(1);&#x2F;&#x2F;蜂鸣器响一声

        cmd_explan_fun();&#x2F;&#x2F;命令解释函数  判断是不是自己的ID  提取里面的参数
    &#125;
&#125;
void copy_fun(u8 *p_in, u8 *p_out, u8 mun) &#x2F;&#x2F;拷贝一个数组 到 另一个数组
&#123;
    u8 i;
    for(i &#x3D; 0; i &lt; mun; i++)
    &#123;
        *(p_out + i) &#x3D; *(p_in + i);
    &#125;
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
&#x2F;*
第一字节是 ID  			小车的ID是2
第二字节是命令类型   小车拿送物块  1:轮盘--&gt;集中站
第三字节是托盘号  		0-3
第四字节是集中站号 	0-3
*&#x2F;

void cmd_explan_fun(void)&#x2F;&#x2F;无线模块串口2发过来的数据  解析
&#123;
	if(cmd_race_buf[0]&#x3D;&#x3D;ID)&#x2F;&#x2F;如果是自己的ID
	&#123;
		switch(cmd_race_buf[1])&#x2F;&#x2F;判断第二个字节
		&#123;
			case 1:&#x2F;&#x2F;转盘到集中站命令
				tuopan_number &#x3D; cmd_race_buf[2];		&#x2F;&#x2F;托盘编号      第三字节
				lajitong_number &#x3D; cmd_race_buf[3];	&#x2F;&#x2F;集中站编号			第四字节
			
				&#x2F;&#x2F;判断托盘号然后显示在屏上
				if(tuopan_number&#x3D;&#x3D;0)
					LCD_ShowString_fun(&quot;tuopan&#x3D;0&quot;);
				if(tuopan_number&#x3D;&#x3D;1)
					LCD_ShowString_fun(&quot;tuopan&#x3D;1&quot;);
				if(tuopan_number&#x3D;&#x3D;2)
					LCD_ShowString_fun(&quot;tuopan&#x3D;2&quot;);
				if(tuopan_number&#x3D;&#x3D;3)
					LCD_ShowString_fun(&quot;tuopan&#x3D;3&quot;);
				
				&#x2F;&#x2F;判断集中站号然后显示在屏上
				if(lajitong_number&#x3D;&#x3D;0)
					LCD_ShowString_fun(&quot;jizhongzhan&#x3D;0&quot;);
				if(lajitong_number&#x3D;&#x3D;1)
					LCD_ShowString_fun(&quot;jizhongzhan&#x3D;1&quot;);
				if(lajitong_number&#x3D;&#x3D;2)
					LCD_ShowString_fun(&quot;jizhongzhan&#x3D;2&quot;);
				if(lajitong_number&#x3D;&#x3D;3)
					LCD_ShowString_fun(&quot;jizhongzhan&#x3D;3&quot;);
			
				&#x2F;&#x2F;小车开始执行命令
				Grab_garbage_fun(tuopan_number,lajitong_number);	&#x2F;&#x2F;执行从托盘拿物块 送到集中站的全部过程
			
				send_to_zhuanpan_cmd_fun();&#x2F;&#x2F;给转盘发送一个数据  让转盘知道 小车的任务已经完成  转盘就可以再发送下一个任务
				delay_ms(2000);&#x2F;&#x2F;延时
				send_to_zhuanpan_cmd_fun();
				&#x2F;&#x2F;delay_ms(1000);&#x2F;&#x2F;延时
				&#x2F;&#x2F;send_to_zhuanpan_cmd_fun();
				break;
		&#125;
	&#125;
&#125;</code></pre>
<h3 id="代码修改-添加记录">代码修改/添加记录</h3>
<h4 id="11-15">11/15</h4>
<ul>
<li>TIM5定时20ms改成别的计算方式</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_Timer_eval.c*************************&#x2F;
&#x2F;&#x2F;定时器5初始化 定时20ms
&#x2F;&#x2F;参数：10000, 168 计算公式:10000*168&#x2F;84000000 &#x3D; 0.02s &#x3D; 20ms
void Timer5_Config(uint16_t period, uint16_t prescaler)
&#123;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;	&#x2F;&#x2F;定义结构体
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);	&#x2F;&#x2F;使能TIM5时钟

    TIM_TimeBaseStructure.TIM_Period &#x3D; period - 1;	&#x2F;&#x2F;重装载值
    TIM_TimeBaseStructure.TIM_Prescaler &#x3D; prescaler;	&#x2F;&#x2F;预分频系数
    TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; 0;	&#x2F;&#x2F;分频因子
    TIM_TimeBaseStructure.TIM_CounterMode &#x3D; TIM_CounterMode_Up;	&#x2F;&#x2F;向上计数
    TIM_TimeBaseInit(TIM5, &amp;TIM_TimeBaseStructure);	&#x2F;&#x2F;初始化

    TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);	&#x2F;&#x2F;TIM5中断使能
    TIM_Cmd(TIM5, ENABLE);	&#x2F;&#x2F;使能TIM5

    NVIC_InitStructure.NVIC_IRQChannel &#x3D; TIM5_IRQn;	&#x2F;&#x2F;中断通道为TIM5
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 6;	&#x2F;&#x2F;抢占优先级
    NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 1;	&#x2F;&#x2F;子优先级
    NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;	&#x2F;&#x2F;使能通道
    NVIC_Init(&amp;NVIC_InitStructure);	&#x2F;&#x2F;中断初始化
&#125;</code></pre>
<h4 id="11-16">11/16</h4>
<ul>
<li>修改了宏定义 <code>TUOPAN_DIS_3</code>  的值，原本是2870</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># define TUOPAN_DIS_3		2670				&#x2F;&#x2F;2700第4个托盘的距离(已弃用)
# define TUOPAN_DIS_3		2900				&#x2F;&#x2F;2022.11.17</code></pre>
<ul>
<li>修改了 <code>find_MAG_fun</code> 函数</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;找磁条
void find_MAG_fun(void)&#x2F;&#x2F; 小车左转后  可能磁条不在中间  这个函数是让小车磁条 修正到中间
&#123;
    u8 arr[10];
    speed_set_mun_L &#x3D; 0;&#x2F;&#x2F;设置左右速度为0
    speed_set_mun_R &#x3D; 0;
    ok_bit &#x3D; 1;


    while(ok_bit)
    &#123;
        MAG_dat &#x3D; mag_test();&#x2F;&#x2F;读磁条
        sprintf((char *)arr, &quot;num:%d&quot;, MAG_dat);
        LCD_ShowString_fun((char *)arr);
        speed_PID_bit &#x3D; 1;&#x2F;&#x2F;开始执行PID函数

        if(speed_set_mun_L &lt; 10) &#x2F;&#x2F;缓启动  限制速度在10以内
        &#123;
            speed_set_mun_L++;
            speed_set_mun_R++;
        &#125;

        if((MAG_dat &gt;&#x3D; 0 &amp;&amp; MAG_dat &lt;&#x3D; 5) || (MAG_dat &lt;&#x3D; -4 &amp;&amp; MAG_dat &gt;&#x3D; -1) ) &#x2F;&#x2F;这个范围就不用管
        &#123;
            ok_bit &#x3D; 0;&#x2F;&#x2F; 表示清零
            delay_ms(100);
            car_pwm_stop();&#x2F;&#x2F;小车停止
        &#125;
        else if(MAG_dat &gt;&#x3D; -5) &#x2F;&#x2F;如果小车偏左或者右  就是设置车轮的方向   达到车身修正的目的
        &#123;
            MOTO_0_B;
            MOTO_1_F;
            MOTO_2_B;
            MOTO_3_F;
        &#125;
        else if(MAG_dat &gt; 5) &#x2F;&#x2F;如果小车偏左或者右  就是设置车轮的方向   达到车身修正的目的
        &#123;
            MOTO_0_F;
            MOTO_1_B;
            MOTO_2_F;
            MOTO_3_B;
        &#125;
        delay_ms(50);
    &#125;
&#125;</code></pre>
<h4 id="11-17">11/17</h4>
<ul>
<li>修改了 <code>arm_pick_up_block_fun</code> 函数</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void arm_pick_up_block_fun(void)&#x2F;&#x2F;机械臂 在 托盘处  向右抓取全部动作
&#123;
	
	arm_0_R(490);&#x2F;&#x2F;右转490脉冲(原本500)
	delay_ms(500);
	
	
	arm_1_F(100);&#x2F;&#x2F;大臂向前
	delay_ms(500);
	
	arm_2_DN(70);&#x2F;&#x2F;小臂向下
	delay_ms(500);
	
	arm_1_F(115);&#x2F;&#x2F;大臂向前
	delay_ms(500);
	
	arm_2_DN(30);&#x2F;&#x2F;小臂向下(原本55)	这个太大会导致扫描前碰到物品所以调小点
	delay_ms(500);
	
	acoustic_wave_find_box_fun();&#x2F;&#x2F;用激光找找盒子动作
	delay_ms(500);
	&#x2F;&#x2F;添加1
	arm_0_R(4);	&#x2F;&#x2F;底盘右转
	delay_ms(500);
	
	arm_2_DN(60);&#x2F;&#x2F;小臂向下
	delay_ms(500);
	&#x2F;&#x2F;添加2
	arm_1_F(5);	&#x2F;&#x2F;大臂向前
	arm_2_UP(10);	&#x2F;&#x2F;小臂抬起
	
	arm3_clip_fun();&#x2F;&#x2F;夹子夹物块
	delay_ms(500);
	
	arm_2_UP(150);&#x2F;&#x2F;小臂抬起
	delay_ms(500);
	
	arm_0_L(500);&#x2F;&#x2F;底盘向左500
	delay_ms(500);
	
	arm_position_init_all();&#x2F;&#x2F;三臂归位
&#125;</code></pre>
<ul>
<li>在 <code>uart2_race_chack</code> 函数里添加</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void uart2_race_chack(void)&#x2F;&#x2F;检测串口2 是否收到一帧数据
&#123;
    if(usart2_race_over_bit)
    &#123;
        LCD_ShowString_fun(&quot;433race&quot;);&#x2F;&#x2F;屏幕显示
		if(usart2_race_buf[0]&#x3D;&#x3D;1)
			LCD_ShowString_fun(&quot;ID&#x3D;1&quot;);
		if(usart2_race_buf[0]&#x3D;&#x3D;1)
			LCD_ShowString_fun(&quot;ID&#x3D;2&quot;);
		if(usart2_race_buf[0]&#x3D;&#x3D;1)
			LCD_ShowString_fun(&quot;ID&#x3D;3&quot;);


        copy_fun(usart2_race_buf, cmd_race_buf, usart2_race_count); &#x2F;&#x2F;拷贝usart2_race_buf 串口2接收数组 到 cmd_race_buf     usart2_race_count是拷贝字节数
        usart2_race_over_bit &#x3D; 0;&#x2F;&#x2F;收到一帧数据标志清零
        usart2_race_count &#x3D; 0;&#x2F;&#x2F;接收字节数清零
		uart2_buf_init();	&#x2F;&#x2F;添加这个清空数组
        delay_ms(1000);&#x2F;&#x2F;转盘发命令会响一声  这里也响一声  延时半秒  能听到发送的嘀和 小车接收的嘀  便于判断  不延时 两个声音会混在一起

        bell_fun(1);&#x2F;&#x2F;蜂鸣器响一声

        cmd_explan_fun();&#x2F;&#x2F;命令解释函数  判断是不是自己的ID  提取里面的参数
    &#125;
&#125;</code></pre>
<ul>
<li>把 <code>cmd_explan_fun</code> 函数里的两行屏蔽掉，只留下一行(这个bug搞了我几个小时一直只能接收一次任务…)，这样就可以接收完一次任务回到原点又接收下一次任务了</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">send_to_zhuanpan_cmd_fun();
&#x2F;&#x2F;delay_ms(2000);&#x2F;&#x2F;延时
&#x2F;&#x2F;send_to_zhuanpan_cmd_fun();</code></pre>
<h4 id="串口测试函数">串口测试函数</h4>
<ul>
<li>此函数是拿来测试底盘和机械臂的方便调参 ``</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void uart1_race_chack(void)&#x2F;&#x2F;检查串口1 是否接收完毕
&#123;
    &#x2F;*底盘调试*&#x2F;
    if(usart1_race_over_bit)
    &#123;
        usart1_race_over_bit &#x3D; 0;


        if(usart1_race_buf[0] &#x3D;&#x3D; &#39;0&#39;)
        &#123;
            bell_fun(1);
            arm_0_L(maichong);&#x2F;&#x2F;左转
            printf(&quot;左转底盘：%d@@\r\n&quot;, maichong);
        &#125;
        if(usart1_race_buf[0] &#x3D;&#x3D; &#39;1&#39;)		&#x2F;&#x2F;执行步骤1底盘
        &#123;
            bell_fun(1);
            arm_0_R(maichong);&#x2F;&#x2F;右转
            printf(&quot;右转底盘：%d@@\r\n&quot;, maichong);
        &#125;
        if(usart1_race_buf[0] &#x3D;&#x3D; &#39;+&#39;)	&#x2F;&#x2F;脉冲+
        &#123;
            bell_fun(1);
            maichong +&#x3D; 1;
            printf(&quot;底盘脉冲加：%d@@\r\n&quot;, maichong);
        &#125;
        if(usart1_race_buf[0] &#x3D;&#x3D; &#39;-&#39;)	&#x2F;&#x2F;脉冲-
        &#123;
            bell_fun(1);
            maichong -&#x3D; 1;
            printf(&quot;底盘脉冲减：%d@@\r\n&quot;, maichong);
        &#125;


        &#x2F;*第一次大臂调试*&#x2F;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;x&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;1&#39;)) &#x2F;&#x2F;大臂前		&#x2F;&#x2F;执行步骤2
        &#123;
            bell_fun(1);
            arm_1_F(x1);
            printf(&quot;第一次大臂前：%d@@\r\n&quot;, x1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;x&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;0&#39;)) &#x2F;&#x2F;大臂后
        &#123;
            bell_fun(1);
            arm_1_B(x1);
            printf(&quot;第一次大臂后：%d@@\r\n&quot;, x1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;x&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;+&#39;)) &#x2F;&#x2F;脉冲+
        &#123;
            bell_fun(1);
            x1 +&#x3D; 1;
            printf(&quot;第一次大臂加：%d@@\r\n&quot;, x1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;x&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;-&#39;)) &#x2F;&#x2F;脉冲-
        &#123;
            bell_fun(1);
            x1 -&#x3D; 1;
            printf(&quot;第一次大臂减：%d@@\r\n&quot;, x1);
        &#125;


        &#x2F;*第一次小臂调试*&#x2F;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;d&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;1&#39;)) &#x2F;&#x2F;小臂前		&#x2F;&#x2F;执行步骤3
        &#123;
            bell_fun(1);
            arm_2_DN(d1);
            printf(&quot;第一次小臂前：%d@@\r\n&quot;, d1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;d&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;0&#39;)) &#x2F;&#x2F;小臂后
        &#123;
            bell_fun(1);
            arm_2_UP(d1);
            printf(&quot;第一次小臂后：%d@@\r\n&quot;, d1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;d&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;+&#39;)) &#x2F;&#x2F;脉冲+
        &#123;
            bell_fun(1);
            d1 +&#x3D; 1;
            printf(&quot;第一次小臂加：%d@@\r\n&quot;, d1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;d&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;-&#39;)) &#x2F;&#x2F;脉冲-
        &#123;
            bell_fun(1);
            d1 -&#x3D; 1;
            printf(&quot;第一次小臂减：%d@@\r\n&quot;, a1);
        &#125;

        &#x2F;*第二次小臂调试*&#x2F;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;a&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;1&#39;)) &#x2F;&#x2F;小臂前		&#x2F;&#x2F;执行步骤4
        &#123;
            bell_fun(1);
            arm_1_F(a1);
            printf(&quot;第二次小臂前：%d@@\r\n&quot;, a1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;a&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;0&#39;)) &#x2F;&#x2F;小臂后
        &#123;
            bell_fun(1);
            arm_1_B(a1);
            printf(&quot;第二次小臂后：%d@@\r\n&quot;, a1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;a&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;+&#39;)) &#x2F;&#x2F;脉冲+
        &#123;
            bell_fun(1);
            a1 +&#x3D; 1;
            printf(&quot;第二次小臂加：%d@@\r\n&quot;, a1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;a&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;-&#39;)) &#x2F;&#x2F;脉冲-
        &#123;
            bell_fun(1);
            a1 -&#x3D; 1;
            printf(&quot;第二次小臂减：%d@@\r\n&quot;, a1);
        &#125;


        &#x2F;*第二次大臂调试*&#x2F;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;b&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;1&#39;)) &#x2F;&#x2F;大臂前		&#x2F;&#x2F;执行步骤5
        &#123;
            bell_fun(1);
            arm_2_DN(b1);
            printf(&quot;第二次大臂前：%d@@\r\n&quot;, b1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;b&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;0&#39;)) &#x2F;&#x2F;大臂后
        &#123;
            bell_fun(1);
            arm_2_UP(b1);
            printf(&quot;第二次大臂后：%d@@\r\n&quot;, b1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;b&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;+&#39;)) &#x2F;&#x2F;脉冲+
        &#123;
            bell_fun(1);
            b1 +&#x3D; 1;
            printf(&quot;第二次大臂加：%d@@\r\n&quot;, b1);
        &#125;
        if((usart1_race_buf[0] &#x3D;&#x3D; &#39;b&#39;) &amp;&amp; (usart1_race_buf[1] &#x3D;&#x3D; &#39;-&#39;)) &#x2F;&#x2F;脉冲-
        &#123;
            bell_fun(1);
            b1 -&#x3D; 1;
            printf(&quot;第二次大臂减：%d@@\r\n&quot;, b1);
        &#125;


        uart1_buf_init();	&#x2F;&#x2F;清空数组
    &#125;
&#125;</code></pre>
<h2 id="2-集中站">&lt;2&gt;集中站</h2>
<table>
<thead>
<tr>
<th style="text-align:center">问题</th>
<th style="text-align:center">答</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">组成</td>
<td style="text-align:center">口袋机，集中站控制板，LED点阵屏(可以用于显示信息)，有害垃圾箱，其他垃圾箱，厨余垃圾箱，可回收垃圾箱；4个舵机输出接口，分别控制4个箱门</td>
</tr>
<tr>
<td style="text-align:center">集中站功能</td>
<td style="text-align:center">接收小车或者其他单元发过来的命令，开启或者关闭箱门<br>接收其他单元发过来的命令，开启或者关闭LED灯条<br>接收控制转盘的口袋机发送过来的文字显示在LED点阵屏上</td>
</tr>
<tr>
<td style="text-align:center">点阵</td>
<td style="text-align:center">GT30L32S4W为字库芯片，通过SPI接口与口袋机通讯，可实现读取字库数据，显示在LED点阵屏上</td>
</tr>
<tr>
<td style="text-align:center">LED</td>
<td style="text-align:center">每个垃圾箱都安装了SW2812灯条，可以独立控制每个灯条的颜色</td>
</tr>
</tbody>
</table>
<h3 id="代码修改-添加记录-2">代码修改/添加记录</h3>
<h3 id="集中站代码详解-主要部分">集中站代码详解(主要部分)</h3>
<ul>
<li>
<p>首先把管脚 <code>D7</code> 初始化(没有用到所以要输出高电平，防止SRAM干扰其他端口)</p>
</li>
<li>
<p>定时器1定时功能代码(暂没用上)</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;定时器1初始化
void Timer1_Config(uint16_t period, uint16_t prescaler)
&#123;
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;	&#x2F;&#x2F;定义结构体
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);	&#x2F;&#x2F;使能TIM5时钟
    TIM_TimeBaseStructure.TIM_Period &#x3D; period - 1;	&#x2F;&#x2F;自动重装载值（溢出值）
    TIM_TimeBaseStructure.TIM_Prescaler &#x3D; prescaler - 1;	&#x2F;&#x2F;预分频系数
    TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; 0;	&#x2F;&#x2F;分频因子，不分频
    TIM_TimeBaseStructure.TIM_CounterMode &#x3D; TIM_CounterMode_Up;	&#x2F;&#x2F;向上计数
	TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure);	&#x2F;&#x2F;初始化

    NVIC_InitStructure.NVIC_IRQChannel &#x3D; TIM1_UP_TIM10_IRQn;	&#x2F;&#x2F;定时器1通道
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 0;	&#x2F;&#x2F;抢占优先级
    NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0;	&#x2F;&#x2F;子优先级
    NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;	&#x2F;&#x2F;使能通道
    NVIC_Init(&amp;NVIC_InitStructure);	&#x2F;&#x2F;中断初始化
	
	TIM_ClearITPendingBit(TIM1,TIM_IT_Update);&#x2F;&#x2F;清空中断标志位
    TIM_ITConfig(TIM1, TIM_IT_Update|TIM_IT_Trigger, ENABLE);	&#x2F;&#x2F;定时器中断源为 更新中断源&#x2F;触发中断源
    TIM_Cmd(TIM1, ENABLE);	&#x2F;&#x2F;使能定时器1
&#125;

void TIM1_UP_TIM10_IRQHandler(void)
&#123;
	static uint16_t count &#x3D; 0;
	if(TIM_GetITStatus(TIM1,TIM_IT_Update) !&#x3D; RESET)
	&#123;
		count++;
		if(count &gt;&#x3D; 20)
		&#123;		
            &#x2F;&#x2F;执行动作
		&#125;
		TIM_ClearITPendingBit(TIM1,TIM_IT_Update);&#x2F;&#x2F;清空中断
	&#125;
&#125;

Timer1_Config(1000,168);	&#x2F;&#x2F;定时1ms</code></pre>
<h3 id="舵机">舵机</h3>
<ul>
<li>4个舵机(顺序是从有害垃圾那开始1—2—3—4)</li>
<li>管脚定义等跟转盘一样</li>
</ul>
<h3 id="串口2无线通信-2">串口2无线通信</h3>
<ul>
<li>管脚定义等跟转盘一样</li>
</ul>
<h3 id="灯条">灯条</h3>
<ul>
<li>SPI1引脚</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PB^3</td>
<td style="text-align:center">LCD_CLK</td>
<td style="text-align:center">复用，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PB^4</td>
<td style="text-align:center">LCD_MISO(输入)</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PB^5</td>
<td style="text-align:center">LCD_MOSI(输出)</td>
<td style="text-align:center">同上</td>
</tr>
</tbody>
</table>
<ul>
<li>灯的控制引脚</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
<th style="text-align:center">对应集中站</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PD^4</td>
<td style="text-align:center">2812_EN1</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
<td style="text-align:center">有害垃圾</td>
</tr>
<tr>
<td style="text-align:center">PA^8</td>
<td style="text-align:center">2812_EN2</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">其他垃圾</td>
</tr>
<tr>
<td style="text-align:center">PE^7</td>
<td style="text-align:center">2812_EN3</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">厨余垃圾</td>
</tr>
<tr>
<td style="text-align:center">PE^0</td>
<td style="text-align:center">2812_EN4</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">可回收物</td>
</tr>
</tbody>
</table>
<ul>
<li>WS2812芯片</li>
</ul>
<p>高位在前低位在后(和一般十六进制颜色码相反)</p>
<table>
<thead>
<tr>
<th style="text-align:center">正常十六进制(16位)</th>
<th style="text-align:center">此程序里十六进制(32位)</th>
<th style="text-align:center">表示颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0xFFFFFF</td>
<td style="text-align:center">0xFFFFFFFF</td>
<td style="text-align:center">白色</td>
</tr>
<tr>
<td style="text-align:center">0x000000</td>
<td style="text-align:center">0x00000000</td>
<td style="text-align:center">全灭</td>
</tr>
<tr>
<td style="text-align:center">0xFF0000</td>
<td style="text-align:center">0x000000FF</td>
<td style="text-align:center">红色</td>
</tr>
<tr>
<td style="text-align:center">0x00FF00</td>
<td style="text-align:center">0x0000FF00</td>
<td style="text-align:center">绿色</td>
</tr>
<tr>
<td style="text-align:center">0x0000FF</td>
<td style="text-align:center">0x00FF0000</td>
<td style="text-align:center">蓝色</td>
</tr>
<tr>
<td style="text-align:center">0xFFFF00</td>
<td style="text-align:center">0x0000FFFF</td>
<td style="text-align:center">黄色</td>
</tr>
<tr>
<td style="text-align:center">0xCE09FB</td>
<td style="text-align:center">0x00BF90EC</td>
<td style="text-align:center">紫色</td>
</tr>
<tr>
<td style="text-align:center">0xFB0083</td>
<td style="text-align:center">0x003800BF</td>
<td style="text-align:center">粉红色</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<ul>
<li><code>74HC32芯片</code>：四组2输入端 <code>或</code> 门</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_GPIO_Init.c*************************&#x2F;
# define WS2812_EN1_L	(GPIOD-&gt;BSRRH &#x3D; GPIO_Pin_4)
# define WS2812_EN1_H	(GPIOD-&gt;BSRRL &#x3D; GPIO_Pin_4)	&#x2F;&#x2F;

# define WS2812_EN2_L	(GPIOA-&gt;BSRRH &#x3D; GPIO_Pin_8)
# define WS2812_EN2_H	(GPIOA-&gt;BSRRL &#x3D; GPIO_Pin_8)

# define WS2812_EN3_L	(GPIOE-&gt;BSRRH &#x3D; GPIO_Pin_7)
# define WS2812_EN3_H	(GPIOE-&gt;BSRRL &#x3D; GPIO_Pin_7)

# define WS2812_EN4_L	(GPIOE-&gt;BSRRH &#x3D; GPIO_Pin_0)
# define WS2812_EN4_H	(GPIOE-&gt;BSRRL &#x3D; GPIO_Pin_0)</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************WS2812.c*************************&#x2F;
&#x2F;&#x2F;灯带使用的是SPI的 mosi 这个端口  所以要初始化SPI1
void SPI1_WS2812_Init(void)
&#123;

    SPI_InitTypeDef  SPI_InitStructure;	&#x2F;&#x2F;定义结构体
    GPIO_InitTypeDef  GPIO_InitStructure;

    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB | RCC_AHB1Periph_GPIOC, ENABLE);	&#x2F;&#x2F;使能对应时钟

    GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI1);	&#x2F;&#x2F;将管脚PB^3复用为SPI1
    GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI1);	&#x2F;&#x2F;将管脚PB^4复用为SPI1
    GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI1);	&#x2F;&#x2F;将管脚PB^5复用为SPI1

    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_100MHz;	&#x2F;&#x2F;速度
    GPIO_InitStructure.GPIO_OType &#x3D; GPIO_OType_PP;	&#x2F;&#x2F;推挽
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;	&#x2F;&#x2F;复用
    GPIO_InitStructure.GPIO_PuPd  &#x3D; GPIO_PuPd_NOPULL;	&#x2F;&#x2F;无上下拉

    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_3;	&#x2F;&#x2F;PB^3
    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);	&#x2F;&#x2F;初始化

    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_4;	&#x2F;&#x2F;PB^4
    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);	&#x2F;&#x2F;初始化

    GPIO_InitStructure.GPIO_Pin &#x3D;  GPIO_Pin_5;	&#x2F;&#x2F;PB^5
    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);	&#x2F;&#x2F;初始化

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);	&#x2F;&#x2F;使能SPI时钟

    SPI_I2S_DeInit(SPI1);	&#x2F;&#x2F;将外设SPI1寄存器重设为缺省值

    SPI_InitStructure.SPI_Direction &#x3D; SPI_Direction_2Lines_FullDuplex;	&#x2F;&#x2F;SPI设置为双线双向全双工
    SPI_InitStructure.SPI_Mode &#x3D; SPI_Mode_Master;	&#x2F;&#x2F;设置为主SPI
    SPI_InitStructure.SPI_DataSize &#x3D; SPI_DataSize_8b;	&#x2F;&#x2F;SPI发送接收8位帧结构
    SPI_InitStructure.SPI_CPOL &#x3D; SPI_CPOL_Low;	&#x2F;&#x2F;时钟悬空低
    SPI_InitStructure.SPI_CPHA &#x3D; SPI_CPHA_1Edge;	&#x2F;&#x2F;数据捕获于第一个时钟沿
    SPI_InitStructure.SPI_NSS &#x3D; SPI_NSS_Soft;	&#x2F;&#x2F;内部NSS信号有SSI位控制
    SPI_InitStructure.SPI_BaudRatePrescaler &#x3D; SPI_BaudRatePrescaler_16;	&#x2F;&#x2F;波特率预分频值为16
    SPI_InitStructure.SPI_FirstBit &#x3D; SPI_FirstBit_MSB;	&#x2F;&#x2F;数据传输从MSB位开始(高位)
    SPI_InitStructure.SPI_CRCPolynomial &#x3D; 7;	&#x2F;&#x2F;不使用校验
    SPI_Init(SPI1, &amp;SPI_InitStructure);	&#x2F;&#x2F;初始化

    SPI_Cmd(SPI1, ENABLE);&#x2F;&#x2F;使能SPI1
&#125;
&#x2F;&#x2F;灯带用到了门电路  有4个控制端口
void SW2812_init_fun(void)
&#123;
    SPI1_WS2812_Init();

    GPIO_init(GPIO_D, GPIO_Pin_4, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;EN1
    GPIO_init(GPIO_A, GPIO_Pin_8, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;EN2
    GPIO_init(GPIO_E, GPIO_Pin_7, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;EN3
    GPIO_init(GPIO_E, GPIO_Pin_0, GPIO_Mode_OUT, GPIO_OType_PP, GPIO_PuPd_NOPULL); &#x2F;&#x2F;EN4

    WS2812_EN1_H;
    WS2812_EN2_H;
    WS2812_EN3_H;
    WS2812_EN4_H;

    light_change_color_1(0x00000000);
    light_change_color_2(0x00000000);
    light_change_color_3(0x00000000);
    light_change_color_4(0x00000000);

&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
&#x2F;&#x2F;设置颜色
light_change_color_1(0x000000FF);&#x2F;&#x2F;第一个灯红
light_change_color_2(0x00FFFFFF);&#x2F;&#x2F;第二个灯白
light_change_color_3(0x0000FF00);&#x2F;&#x2F;第三个灯绿
light_change_color_4(0x00FF0000);&#x2F;&#x2F;第四个灯蓝</code></pre>
<h3 id="点阵-2">点阵</h3>
<ul>
<li>字库芯片GT30L32S4W</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PG^1</td>
<td style="text-align:center">SIP2 SCK</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PE^13</td>
<td style="text-align:center">SIP2 NSS</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PE^15</td>
<td style="text-align:center">SIP2 MOSI</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PE^14</td>
<td style="text-align:center">SIP2 MISO</td>
<td style="text-align:center">输入，开漏，上拉</td>
</tr>
</tbody>
</table>
<ul>
<li>LED点阵屏</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PG^9</td>
<td style="text-align:center">LA</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PG^15</td>
<td style="text-align:center">LB</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PD^2</td>
<td style="text-align:center">LC</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PG^13</td>
<td style="text-align:center">LD</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PD^1</td>
<td style="text-align:center">CLK</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PA^15</td>
<td style="text-align:center">LAT</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PC^11</td>
<td style="text-align:center">R1</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PC^10</td>
<td style="text-align:center">R2</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PG^12</td>
<td style="text-align:center">G1</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PB^15</td>
<td style="text-align:center">G2</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PC^12</td>
<td style="text-align:center">EN</td>
<td style="text-align:center">同上</td>
</tr>
</tbody>
</table>
<ul>
<li>点阵是通过 <code>74hc595</code> 芯片控制行列</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************LED8080.c*************************&#x2F;
&#x2F;&#x2F;字库芯片的GPIO初始化
void GT30L32S4W_init(void)
&#123;
	
&#x2F;*
SIP2 SCK		G1
SIP2 MOSI		E15
SIP2 MISO		E14
SIP2 NSS		E13
*&#x2F;
	
	GPIO_init(GPIO_G,GPIO_Pin_1,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;SCK
	GPIO_init(GPIO_E,GPIO_Pin_15,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;MOSI
	GPIO_init(GPIO_E,GPIO_Pin_14,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_UP);&#x2F;&#x2F;MISO
	GPIO_init(GPIO_E,GPIO_Pin_13,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;NSS
	
	SPI_SCK_H;&#x2F;&#x2F;SCK 输出高
	SPI_NSS_H;&#x2F;&#x2F;NSS 输出高
&#125;



&#x2F;&#x2F;LED点阵屏的端口初始化
void LED8080_gpio_init(void)
&#123;
&#x2F;*
LA	G9
LB	G15
LC	D2
LD	G13
CLK	D1
LAT	A15
R1	C11
R2	C10
G1	G12
G2	B15
EN	C12
*&#x2F;
	
	GPIO_init(GPIO_G,GPIO_Pin_9,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;LA
	GPIO_init(GPIO_G,GPIO_Pin_15,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;LB
	GPIO_init(GPIO_D,GPIO_Pin_2,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;LC
	GPIO_init(GPIO_G,GPIO_Pin_13,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;LD
	GPIO_init(GPIO_D,GPIO_Pin_1,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;CLK
	GPIO_init(GPIO_A,GPIO_Pin_15,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;LAT
	GPIO_init(GPIO_C,GPIO_Pin_11,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;R1
	GPIO_init(GPIO_C,GPIO_Pin_10,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;R2
	GPIO_init(GPIO_G,GPIO_Pin_12,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;G1
	GPIO_init(GPIO_B,GPIO_Pin_15,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;G2
	GPIO_init(GPIO_C,GPIO_Pin_12,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;EN
	
	EN_L;
	LA_H;
	LB_H;
	LC_H;
	LD_H;
&#125;</code></pre>
<h3 id="串口2无线通信-3">串口2无线通信</h3>
<ul>
<li>管脚定义等跟转盘一样</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.h*************************&#x2F;
# define ID						0X03	&#x2F;&#x2F;集中站的ID</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_Usart_eval.c*************************&#x2F;
u8 usart2_send_buf[100];	&#x2F;&#x2F;串口2发送数据数组


# define UART2_RACE_MUN	200	&#x2F;&#x2F;定义接收的命令最大不能超过这个数

u8 usart2_race_buf[UART2_RACE_MUN];	&#x2F;&#x2F;接收数组
u8 usart2_race_over_bit;	&#x2F;&#x2F;接收完成标志位
u8 usart2_race_count;	&#x2F;&#x2F;接收的命令长度(如果超过UART2_RACE_MUN变回0)


&#x2F;&#x2F;命令分析
void cmd_explan(void)
&#123;
	u8 door_mun;
	u8 cmd_data;
	
	if(usart2_race_buf[0]&#x3D;&#x3D;ID)	&#x2F;&#x2F;判断是不是自己的ID
	&#123;
		LCD_ShowString_fun(&quot;ID&#x3D;3&quot;);	&#x2F;&#x2F;显示自己的ID
		cmd_data &#x3D; usart2_race_buf[1];
		door_mun &#x3D; usart2_race_buf[2];
		
		if(cmd_data&#x3D;&#x3D;0x01)
			LCD_ShowString_fun(&quot;kaimen&quot;);	&#x2F;&#x2F;开门
		if(cmd_data&#x3D;&#x3D;0x02)
			LCD_ShowString_fun(&quot;guanmen&quot;);	&#x2F;&#x2F;关门
		
		if(door_mun&#x3D;&#x3D;0)
			LCD_ShowString_fun(&quot;0&quot;);
		if(door_mun&#x3D;&#x3D;1)
			LCD_ShowString_fun(&quot;1&quot;);
		if(door_mun&#x3D;&#x3D;2)
			LCD_ShowString_fun(&quot;2&quot;);
		if(door_mun&#x3D;&#x3D;3)
			LCD_ShowString_fun(&quot;3&quot;);
			
		steering_engine_ctl(cmd_data,door_mun);&#x2F;&#x2F;开门或者关门函数  data 1是开门  2是关门    door_mun是门编号 0-3
	&#125;
&#125;

&#x2F;&#x2F;判断是否接收到命令
void uart2_race_chack(void)
&#123;
	if(usart2_race_over_bit)
	&#123;
		usart2_race_over_bit&#x3D; 0;
		
		Uart2_send_data(usart2_race_buf,usart2_race_count);
		
		usart2_race_count &#x3D; 0;
		
		LCD_ShowString_fun(&quot;433_race&quot;);&#x2F;&#x2F;屏上显示收到数据  但是不一定是给自己的
		
		cmd_explan();	&#x2F;&#x2F;命令分析
	&#125;
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************MOTO.c*************************&#x2F;
&#x2F;&#x2F;舵机控制      dat  1是开  2是关   mun是 门编号
void steering_engine_ctl(u8 cmd,u8 mun)
&#123;
	switch(mun)
	&#123;
		case 0:
			if(cmd&#x3D;&#x3D;1)
				steering_engine_1_open();
			if(cmd&#x3D;&#x3D;2)
				steering_engine_1_close();
			break;
		case 1:
			if(cmd&#x3D;&#x3D;1)
				steering_engine_2_open();
			if(cmd&#x3D;&#x3D;2)
				steering_engine_2_close();
			break;
		case 2:
			if(cmd&#x3D;&#x3D;1)
				steering_engine_3_open();
			if(cmd&#x3D;&#x3D;2)
				steering_engine_3_close();
			break;
		case 3:
			if(cmd&#x3D;&#x3D;1)
				steering_engine_4_open();
			if(cmd&#x3D;&#x3D;2)
				steering_engine_4_close();
			break;
	&#125;
&#125;</code></pre>
<h2 id="3-转盘">&lt;3&gt;转盘</h2>
<table>
<thead>
<tr>
<th style="text-align:center">问题</th>
<th style="text-align:center">答</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">组成</td>
<td style="text-align:center">AI智能图像识别部分（英伟达NANO主机，工业摄像头）<br>转盘（减速电机，光电码盘）<br>4个舵机<br>4个光电反射传感器<br>2个红外对射传感器<br>转盘控制板<br>口袋机</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221111000255.png" alt=" "></p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>整个一个单独步骤运行流程</p>
</div>
<p>① 将沙盘上的所有单元上电，NANO主机开机并<code>运行垃圾识别软件</code>，在屏幕上能都看到图像，并 <code>点击识别按钮</code></p>
<p>② 将要识别的模拟垃圾物块放置到转盘上(一般为1-4个)，<code>RFID刷卡</code>(转盘控制板上有RFID读卡模块)，启动转盘开始转动，当物块<code>经过第一红外对射光电管后</code>，口袋机知道物块已经进入识别区域，等待NANO主机通过<code>MQTT通讯</code>将垃圾分类的结果(0是可回收垃圾，1是有害垃圾，2是厨余垃圾，3是其他垃圾) 发送过来，当物块经过第二个红外对射光电管后，口袋机知道物块已经通过识别区域，<code>将这个物块的类别和位置计数清零</code> (通过编码器可以知道物块走了多少个脉冲，<code>第二个红外对射管是物块移动多少脉冲的记录的起始位置</code>)</p>
<p>③ 口袋机得到NANO发来的0-3的数据后，当垃圾走到对应的托盘(0-3)，<code>口袋机控制舵机将垃圾推入托盘</code></p>
<p>④ 推入托盘后，口袋机通过<code>无线模块</code>(转盘控制板上)，<code>发送命令给小车</code>(夹几号托盘的物块扔到几号集中站)，小车收到命令后<code>从起始位置出发，经过十字磁条，开始计数</code> (走多少距离到一号托盘)，停下，夹物块</p>
<p>⑤ 托盘的下面有<code>反射光电开关</code>，当小车拿走物块后，转盘的口袋机知道小车已经把物块夹走了</p>
<p>⑥ 小车夹到物块后，通过<code>磁条寻迹</code>，<code>走到指定的集中站</code>(转盘发给小车的命令中有)，<code>小车发送命令给集中站</code>(开几号门)，<code>集中站通过舵机控制几号门开门</code></p>
<p>⑦ 小车执行扔垃圾程序，<code>将物块扔进集中站，给集中站发送关门命令</code></p>
<p>⑧ 小车<code>回到起始位置</code>，给转盘发送命令(动作全部完成，集中站收到命令后，可以再给小车分配新的任务)</p>
<p>转盘上有 <code>3个光电对射管</code> ，用于检测垃圾的通过， <code>1和2是用来检测垃圾在1和2之间的时候是否收到摄像发过来的分类数据</code>(通过网线，使用MQTT协议)， <code>3号光电对射是用来记录垃圾走到这个位置后开始编码器计数</code>(转盘的电机上装有光电编码器，通过程序可以知道每个垃圾经过光电对射管3后走了多少距离)，垃圾到达对应的托盘后，通过舵机，将垃圾推到托盘上</p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>假设任务</p>
</div>
<p>小车收到转盘发过来的命令(例如：将1号托盘的垃圾运送到1号垃圾桶)</p>
<p>小车开始寻迹向前走，走过一个横着的十字磁条后，再走若干的脉冲，达到1号托盘；拿到垃圾后，小车继续寻迹向前，直到遇到左转磁条后停止，然后小车原地左转90度；直走若干脉冲直到遇到左转磁条，然后小车原地左转90度；将垃圾扔到1号集中站中；继续走到左转磁条，然后小车原地左转90度；连续通过3个左转磁条后停止；小车原地左转90度，小车回到起始位置。</p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>沙盘各个单元之间的通讯</p>
</div>
<ul>
<li>图像识别的NANO主机与控制转盘的口袋机通过 <code>MQTT协议</code> 通讯，NANO通过网线连接路由器，转盘口袋机通过网线连接路由器，NANO运行图像识别分类程序后，建立了一个MQTT服务器，转盘口袋机作为客户端，订阅特定的主题，NANO每识别完一次垃圾后都会将分类结果向转盘口袋机发送一个消息</li>
<li>转盘，集中站，小车，垃圾桶，每个单元都有一个 <code>无线433模块</code>，分别在各自的控制板上，并有天线，无线模块采用 <code>透传广播</code> 的方式传输数据(透传广播意思是一个口袋机的串口发送数据给模块，所有上电的模块都能收到，并通过串口发送给口袋机)</li>
<li>口袋机和无线模块是通过 <code>串口</code> 收发数据的，波特率 <code>115200</code></li>
<li>如何做到单独通讯？</li>
</ul>
<p>用 <code>设置ID</code> 的方式(传输数据的第一个字节是ID)</p>
<table>
<thead>
<tr>
<th style="text-align:center">单元</th>
<th style="text-align:center">ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">转盘</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">小车</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">集中站</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">垃圾桶1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">垃圾桶2</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">垃圾桶3</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">垃圾桶4</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>举例：转盘给小车发送命令（串口发送的数据）</p>
<p>这个命令其他的单元也会受到，通过编写命令判断程序，可以判断第一字节是否是自己的ID， 是就执行命令，不是就不执行命令</p>
<table>
<thead>
<tr>
<th style="text-align:center">字节1</th>
<th style="text-align:center">字节2</th>
<th style="text-align:center">字节3</th>
<th style="text-align:center">字节4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2 （小车的ID）</td>
<td style="text-align:center">要执行的命令</td>
<td style="text-align:center">参数1</td>
<td style="text-align:center">参数2</td>
</tr>
</tbody>
</table>
<ul>
<li>口袋机给无线模块发送的数据要求</li>
</ul>
<p>① 波特率115200</p>
<p>② 数据长度可变（最大64字节）</p>
<p>③ 一条命令的全部数据必须是连续的（模块会判断一帧连续的数据，如果数据不连续了，就认为一帧完成，打包通过无线发送出去），所以给无线模块发送数据时，要一帧全部发完，不要分开发</p>
<h3 id="启动转盘步骤">启动转盘步骤</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221111134342.jpg" alt=" "></p>
<p>打开沙盘电脑(密码:123456) — 右上角设置 — 系统设置 — 网络 — 点击左边那几个有线，看看哪个有显示IP地址的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221111134728.jpg" alt=" "></p>
<p>下载程序到口袋机，然后打开桌面的 <code>垃圾分拣</code>  — 打开摄像头 — 开始识别</p>
<h3 id="代码修改-添加记录-3">代码修改/添加记录</h3>
<h4 id="11-12">11/12</h4>
<table>
<thead>
<tr>
<th style="text-align:center">修改的文件</th>
<th style="text-align:center">修改行号开始</th>
<th style="text-align:center">修改了某处</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">main.c<br>STM32F40x_Timer_eval.c</td>
<td style="text-align:center">330<br>22</td>
<td style="text-align:center">Timer5_Config(74, 5);改成Timer5_Config(20000, 84);<br>把溢出值/预分频值计算公式改变</td>
</tr>
</tbody>
</table>
<h4 id="11-15-2">11/15</h4>
<p>测试轮盘发命令给集中站开门关门–成功</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void send_to_jzz_cmd(uint8_t oc)
&#123;
	u8 cmd_buf[3];
	
	cmd_buf[0] &#x3D; 3;&#x2F;&#x2F;发送集中站的ID
	cmd_buf[1] &#x3D; oc;	&#x2F;&#x2F;开门
	cmd_buf[2] &#x3D; 0;	&#x2F;&#x2F;几号门
	
	Uart2_send_data(cmd_buf,3);&#x2F;&#x2F;发送函数
	
	bell_fun(1);	&#x2F;&#x2F;蜂鸣器响
&#125;
&#x2F;&#x2F;在按键里执行即可</code></pre>
<h3 id="轮盘代码详解-主要部分">轮盘代码详解(主要部分)</h3>
<ul>
<li>清除数组大小</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;数组初始化为0([x][0]:存储垃圾状态，[x][1]:垃圾类型，[x][2]转盘计数,[x][3]:暂没用到)
void task_buf_init(void)
&#123;
	u8 i,j;
	for(i&#x3D;0;i&lt;TASK_MUN;i++)
	&#123;
		for(j&#x3D;0;j&lt;4;j++)
		&#123;
			task_buf[i][j] &#x3D; 0;
		&#125;
	&#125;
&#125;</code></pre>
<ul>
<li>按键执行的内容</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;判断哪个按键按下
u8 button_scan_fun(void)
&#123;
	u8 i;
	u8 temp[8];
	u8 return_data;
	
	# define BUTTON_A  		4
	# define BUTTON_B  		3
	# define BUTTON_C  		2
	# define BUTTON_D  		1
	# define BUTTON_UP  		7
	# define BUTTON_DOWN  	6
	# define BUTTON_LEFT  	8
	# define BUTTON_RIGHT  5
	
	
	return_data &#x3D; 0;
	
	temp[0] &#x3D; READ_BUTTON1;	&#x2F;&#x2F;D
	temp[1] &#x3D; READ_BUTTON2;	&#x2F;&#x2F;C	
	temp[2] &#x3D; READ_BUTTON3;	&#x2F;&#x2F;B
	temp[3] &#x3D; READ_BUTTON4;	&#x2F;&#x2F;A
	temp[4] &#x3D; READ_BUTTON5;	&#x2F;&#x2F;右
	temp[5] &#x3D; READ_BUTTON6;	&#x2F;&#x2F;下
	temp[6] &#x3D; READ_BUTTON7;	&#x2F;&#x2F;上
	temp[7] &#x3D; READ_BUTTON8;	&#x2F;&#x2F;左
	
	for(i&#x3D;0;i&lt;8;i++)
	&#123;
		if(temp[i]&#x3D;&#x3D;0)	&#x2F;&#x2F;按下是低电平
		&#123;
			return_data &#x3D; i+1;	&#x2F;&#x2F;返回对应的按键编码
			break;
		&#125;
	&#125;
	
	return return_data;	&#x2F;&#x2F;没有按键按下则返回0
&#125;
&#x2F;&#x2F;根据返回的按键编码执行对应动作
void test_fun(void)
&#123;
	u8 button_dat;
	
	button_dat &#x3D; button_scan_fun();	&#x2F;&#x2F;接收按键编码
	
	switch(button_dat)
	&#123;
		case BUTTON_A:
			bell_fun(1);	&#x2F;&#x2F;响一下
			steering_engine_1_push();	&#x2F;&#x2F;舵机1推
			delay_ms(1000);	&#x2F;&#x2F;延时1s
			steering_engine_1_shrink();	&#x2F;&#x2F;舵机1收
			printf(&quot;%d\r\n&quot;,button_dat);	&#x2F;&#x2F;串口显示对应按键编码
			break;
		
		case BUTTON_B:
			bell_fun(1);	&#x2F;&#x2F;响一下
			steering_engine_2_push();	&#x2F;&#x2F;舵机2推
			delay_ms(1000);	&#x2F;&#x2F;延时1s
			steering_engine_2_shrink();	&#x2F;&#x2F;舵机2收
			printf(&quot;%d\r\n&quot;,button_dat);	&#x2F;&#x2F;串口显示对应按键编码
			break;
		
		case BUTTON_C:
			bell_fun(1);	&#x2F;&#x2F;响一下
			steering_engine_3_push();	&#x2F;&#x2F;舵机3推
			delay_ms(1000);	&#x2F;&#x2F;延时1s
			steering_engine_3_shrink();	&#x2F;&#x2F;舵机3收
			printf(&quot;%d\r\n&quot;,button_dat);	&#x2F;&#x2F;串口显示对应按键编码
			break;
		
		case BUTTON_D:
			bell_fun(1);	&#x2F;&#x2F;响一下
			steering_engine_4_push();	&#x2F;&#x2F;舵机4推
			delay_ms(1000);
			steering_engine_4_shrink();	&#x2F;&#x2F;舵机4收
			printf(&quot;%d\r\n&quot;,button_dat);	&#x2F;&#x2F;串口显示对应按键编码
			break;
		
		case BUTTON_UP:
			bell_fun(1);	&#x2F;&#x2F;响一下
			&#x2F;&#x2F;开始测试
			MOTO_run_fun();	&#x2F;&#x2F;转盘转动
			printf(&quot;%d\r\n&quot;,button_dat);	&#x2F;&#x2F;串口显示对应按键编码
			break;
	
		case BUTTON_DOWN:
			bell_fun(1);	&#x2F;&#x2F;响一下
			MOTO_stop_fun();	&#x2F;&#x2F;转盘停止
			printf(&quot;%d\r\n&quot;,button_dat);	&#x2F;&#x2F;串口显示对应按键编码
			break;
		
		case BUTTON_LEFT:
			bell_fun(1);	&#x2F;&#x2F;响一下
			printf(&quot;%d\r\n&quot;,button_dat);	&#x2F;&#x2F;串口显示对应按键编码
			break;
		
		case BUTTON_RIGHT:
			bell_fun(1);	&#x2F;&#x2F;响一下
			printf(&quot;%d\r\n&quot;,button_dat);	&#x2F;&#x2F;串口显示对应按键编码
			break;
	&#125;
&#125;</code></pre>
<h4 id="网口-TCP-MQTT部分">网口/TCP/MQTT部分</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PB^0/TIM3_CH3/网口</td>
</tr>
</tbody>
</table>
<p>某些代码意思</p>
<table>
<thead>
<tr>
<th style="text-align:center">英文(打印信息)</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10M，100M</td>
<td style="text-align:center">PHY速度(与下面一起的)</td>
</tr>
<tr>
<td style="text-align:center">PHY Speed is:</td>
<td style="text-align:center">PHY 速度为：</td>
</tr>
<tr>
<td style="text-align:center">PHY Init Successful！</td>
<td style="text-align:center">PHY 初始化成功！</td>
</tr>
<tr>
<td style="text-align:center">Network cable is not connected！</td>
<td style="text-align:center">网线未连接！</td>
</tr>
<tr>
<td style="text-align:center">Please connect the network cable.</td>
<td style="text-align:center">请连接网线。</td>
</tr>
<tr>
<td style="text-align:center">Network cable is now connected.</td>
<td style="text-align:center">网络电缆现已连接。</td>
</tr>
<tr>
<td style="text-align:center">Network cable is unplugged!</td>
<td style="text-align:center">网线被拔掉了！</td>
</tr>
<tr>
<td style="text-align:center">DHCP IP address：</td>
<td style="text-align:center">DHCP IP地址:(地址一般是Nano机有线网络IPv4地址)</td>
</tr>
<tr>
<td style="text-align:center">DHCP IP GOT</td>
<td style="text-align:center">IP已经得到</td>
</tr>
<tr>
<td style="text-align:center">DHCP IP address wait timeout</td>
<td style="text-align:center">DHCP IP 地址等待超时</td>
</tr>
<tr>
<td style="text-align:center">Static IP address：</td>
<td style="text-align:center">静态 IP 地址：</td>
</tr>
<tr>
<td style="text-align:center">Connect to Server …</td>
<td style="text-align:center">连接到服务器…</td>
</tr>
<tr>
<td style="text-align:center">Connect to Server Error !</td>
<td style="text-align:center">连接服务器错误！</td>
</tr>
<tr>
<td style="text-align:center">can not create tcp pcb</td>
<td style="text-align:center">无法创建 tcp pcb</td>
</tr>
<tr>
<td style="text-align:center">Connected to Server Successful</td>
<td style="text-align:center">连接服务器成功</td>
</tr>
<tr>
<td style="text-align:center">connected server flag set: 1</td>
<td style="text-align:center">连接的服务器标志集：1</td>
</tr>
<tr>
<td style="text-align:center">Memory allocate structure “s_es” Error !</td>
<td style="text-align:center">内存分配结构&quot;s_es&quot; 错误 !</td>
</tr>
<tr>
<td style="text-align:center">Server not found</td>
<td style="text-align:center">找不到服务器</td>
</tr>
<tr>
<td style="text-align:center">have one tcp client error !</td>
<td style="text-align:center">有一个 TCP 客户端错误！</td>
</tr>
<tr>
<td style="text-align:center">close connection</td>
<td style="text-align:center">紧密联系</td>
</tr>
<tr>
<td style="text-align:center">connected server flag set: 0</td>
<td style="text-align:center">关闭连接已连接的服务器标志集：0</td>
</tr>
<tr>
<td style="text-align:center">sign_in</td>
<td style="text-align:center">登入</td>
</tr>
<tr>
<td style="text-align:center">MQTT_sign_in</td>
<td style="text-align:center">MQTT登入</td>
</tr>
<tr>
<td style="text-align:center">topic_in</td>
<td style="text-align:center">服务器登入</td>
</tr>
<tr>
<td style="text-align:center">MQTT_topic_in</td>
<td style="text-align:center">MQTT服务器登入</td>
</tr>
<tr>
<td style="text-align:center">Connent command send OK</td>
<td style="text-align:center">连接命令发送OK</td>
</tr>
</tbody>
</table>
<ul>
<li><code>netconf.c/stm32f4x7_ eth_ bsp.c/tcp_ echoclient.c</code> 这3个主要文件是关于服务器/MQTT等</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************MQTT.c*************************&#x2F;
u8 MQTT_race_TOPIC_bit;	&#x2F;&#x2F;NAn0主机是否识别到结果标志位
u8 MQTT_race_TOPIC_dat;	&#x2F;&#x2F;MQTT_race_TOPIC_dat是识别物块的结果  0x30  0x31  0x32  0x33

&#x2F;&#x2F;发布消息
&#x2F;&#x2F;buff：数据包数组
&#x2F;&#x2F;dup ：重发标志
&#x2F;&#x2F;qos ：服务质量等级
&#x2F;&#x2F;retain：保留标志
&#x2F;&#x2F;topic:主题如“a&#x2F;c”
&#x2F;&#x2F;msg:消息</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">物品名</th>
<th style="text-align:center">对应数据(前面13字节一样)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">白菜</td>
<td style="text-align:center">30 0C 00 09 63 6F 6C 6C 65 63 74 30 36 <span style="color:red;">32</span></td>
</tr>
<tr>
<td style="text-align:center">芬达</td>
<td style="text-align:center"><span style="color:red;">30</span></td>
</tr>
<tr>
<td style="text-align:center">打火机</td>
<td style="text-align:center"><span style="color:red;">33</span></td>
</tr>
<tr>
<td style="text-align:center">纸箱</td>
<td style="text-align:center"><span style="color:red;">30</span></td>
</tr>
<tr>
<td style="text-align:center">完整的鱼</td>
<td style="text-align:center"><span style="color:red;">32</span></td>
</tr>
<tr>
<td style="text-align:center">药片</td>
<td style="text-align:center"><span style="color:red;">31</span></td>
</tr>
<tr>
<td style="text-align:center">鱼骨头</td>
<td style="text-align:center"><span style="color:red;">32</span></td>
</tr>
<tr>
<td style="text-align:center">西红柿</td>
<td style="text-align:center"><span style="color:red;">32</span></td>
</tr>
<tr>
<td style="text-align:center">可乐易拉罐</td>
<td style="text-align:center"><span style="color:red;">30</span></td>
</tr>
<tr>
<td style="text-align:center">香蕉</td>
<td style="text-align:center"><span style="color:red;">32</span></td>
</tr>
</tbody>
</table>
<ul>
<li><span style="color:red;">托盘是从小车出发点开始: 0—1—2—3   集中箱是从有害垃圾箱开始：0—1—2—3</span></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">最后一个数据表示</th>
<th style="text-align:center">对应托盘号(命令)</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">对应集中箱号()(命令)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x30(第4个托盘)</td>
<td style="text-align:center">3</td>
<td style="text-align:center">可回收物</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">0x31(第1个托盘)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">有害垃圾</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0x32(第3个托盘)</td>
<td style="text-align:center">2</td>
<td style="text-align:center">厨余垃圾</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">0x33(第2个托盘)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">其他垃圾</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<ul>
<li>转盘宏定义全局</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">宏定义</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"># define   TASK_MUN     10</td>
<td style="text-align:center">控制数组行的大小</td>
</tr>
<tr>
<td style="text-align:left"># define   GARBAGE_STATE     0</td>
<td style="text-align:center">垃圾状态(即数组第1列)</td>
</tr>
<tr>
<td style="text-align:left"># define	GARBAGE_TYPE     1</td>
<td style="text-align:center">垃圾类型(即数组第2列)</td>
</tr>
<tr>
<td style="text-align:left"># define	TURNTABLE_COUNT     2</td>
<td style="text-align:center">转盘计数(即数组第3列)</td>
</tr>
<tr>
<td style="text-align:left"># define    EMPTY     0</td>
<td style="text-align:center">空</td>
</tr>
<tr>
<td style="text-align:left"># define    WAIT_CAMERA     1</td>
<td style="text-align:center">等待识别</td>
</tr>
<tr>
<td style="text-align:left"># define    CAMERA_OK     2</td>
<td style="text-align:center">已经识别</td>
</tr>
<tr>
<td style="text-align:left"># define    CAMERA_TIME_OUT     3</td>
<td style="text-align:center">识别超时</td>
</tr>
<tr>
<td style="text-align:left"># define    WAIT_ENGINE     4</td>
<td style="text-align:center">等待舵机推</td>
</tr>
<tr>
<td style="text-align:left"># define    PUSH     5</td>
<td style="text-align:center">推的过程中</td>
</tr>
<tr>
<td style="text-align:left"># define    ARRIVE_OK     6</td>
<td style="text-align:center">已经到达托盘</td>
</tr>
<tr>
<td style="text-align:left"># define    SEND_OUT     7</td>
<td style="text-align:center">已经发送命令给小车</td>
</tr>
<tr>
<td style="text-align:left"># define    TRANSPORT      8</td>
<td style="text-align:center">被小车拿走运送中</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************task.c*************************&#x2F;
&#x2F;&#x2F;确认垃圾状态与类别
void MQTT_race_topic_data_fun(u8 type)
&#123;
	u8 i;
	u8 type_data;
	
&#x2F;&#x2F;	type_data &#x3D; type - 0x30;&#x2F;&#x2F;因为MQTT 发过来的数据是  0x30  0x31  0x32  0x33   所以这个数据要变成0123  就要减去0x30
	if(type-0x30&#x3D;&#x3D;0)&#123;type_data&#x3D;3;&#125;	&#x2F;&#x2F;可回收垃圾
	if(type-0x30&#x3D;&#x3D;1)&#123;type_data&#x3D;0;&#125;	&#x2F;&#x2F;有害垃圾
	if(type-0x30&#x3D;&#x3D;2)&#123;type_data&#x3D;2;&#125;	&#x2F;&#x2F;厨余垃圾
	if(type-0x30&#x3D;&#x3D;3)&#123;type_data&#x3D;1;&#125;	&#x2F;&#x2F;其他垃圾
	
	for(i&#x3D;0;i&lt;TASK_MUN;i++)&#x2F;&#x2F;从0开始查看  垃圾的状态  如果是等待识别的，就记录数据
	&#123;
		if(task_buf[i][GARBAGE_STATE]&#x3D;&#x3D;WAIT_CAMERA)&#x2F;&#x2F;如果是等待识别
		&#123;
			task_buf[i][GARBAGE_TYPE] &#x3D; (u32)type_data;&#x2F;&#x2F;确定垃圾类别
			task_buf[i][GARBAGE_STATE] &#x3D; CAMERA_OK;			&#x2F;&#x2F;是识别后的状态
			&#x2F;&#x2F;printf(&quot;MQTT RACE\r\n&quot;);										&#x2F;&#x2F;串口打印
			
			if(type_data&#x3D;&#x3D;0)
				LCD_ShowString_fun(&quot;2:MQTT_race &#x3D; 0&quot;);&#x2F;&#x2F;屏上显示(有害垃圾)
			if(type_data&#x3D;&#x3D;1)
				LCD_ShowString_fun(&quot;2:MQTT_race &#x3D; 1&quot;);&#x2F;&#x2F;屏上显示(其他垃圾)
			if(type_data&#x3D;&#x3D;2)
				LCD_ShowString_fun(&quot;2:MQTT_race &#x3D; 2&quot;);&#x2F;&#x2F;屏上显示(厨余垃圾)
			if(type_data&#x3D;&#x3D;3)
				LCD_ShowString_fun(&quot;2:MQTT_race &#x3D; 3&quot;);&#x2F;&#x2F;屏上显示(可回收垃圾)
			break;
		&#125;
		else	&#x2F;&#x2F;如果没有物在第一个光电管和第二个光电管之间  屏幕显示错误
		&#123;
			LCD_ShowString_fun(&quot;MQTT_race_late&quot;);						&#x2F;&#x2F;屏上显示表示MQTT_race_late 说明给消息的时间不对了  已经超过了第二个光电管
		&#125;
	&#125;
&#125;</code></pre>
<h4 id="转盘电机">转盘电机</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PD^4</td>
<td style="text-align:center">RUN</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PD^13(TIM4_CH2)</td>
<td style="text-align:center">BACK</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PA^8(TIM1_CH1)</td>
<td style="text-align:center">PWM_STM32(产生PWM)</td>
<td style="text-align:center">复用，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PD^2(D2/UART5 RX/TIM3 ETR)外部时钟做时钟源</td>
<td style="text-align:center">CODE1</td>
<td style="text-align:center">复用，开漏，无上下拉</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221112193054.jpg" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221112193752.png" alt=" "></p>
<p>由于电机那接了一个 <code>74HC02D</code> 与非门芯片(即输入1输出0，输入0输出1)，电机低电平才会动，故在配置 PWM时需要配成 <code>PWM1模式+高电平极性</code> 设置占空比100(即一直输出高电平，然后经过芯片就变成一直输出低电平驱动电机转动)</p>
<p><code>尝试</code>：把极性设为低电平会发现波形是一直低电平，经过与非门也就是一直高电平</p>
<p>转动是通过PID算法计算的(看不懂)</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************task.c*************************&#x2F;
&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;speed_PID&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

u16 speed_new;
float SpeedSet_dat;	&#x2F;&#x2F;设置的速度
float Kp &#x3D; 10;&#x2F;&#x2F;pi控制系数
float Ki &#x3D; 1;&#x2F;&#x2F;pi控制系数(没有用到d)

float e;	&#x2F;&#x2F;pid偏差
float e1;
float e2;
float duk;	&#x2F;&#x2F;pid输出值
float uk;
float uk1;
float out;
float num;	&#x2F;&#x2F;实际速度
u16 PWMTime;	&#x2F;&#x2F;脉冲宽度

void timer5_speed_pid_fun(u16 speed)
&#123;
	u8 i;
	
	speed_new &#x3D; TIM_GetCounter(TIM3);
	TIM_SetCounter(TIM3,0);
	MOTO_count &#x3D; MOTO_count + speed_new;
	
	
	for(i&#x3D;0;i&lt;TASK_MUN;i++)
	&#123;
		if(task_buf[i][GARBAGE_STATE]&#x3D;&#x3D;WAIT_ENGINE)
		&#123;
			task_buf[i][TURNTABLE_COUNT] &#x3D; task_buf[i][TURNTABLE_COUNT] + speed_new;
		&#125;
	&#125;
	

	num &#x3D; (float)speed_new;
	SpeedSet_dat &#x3D; speed;
	
	e&#x3D;SpeedSet_dat-num;&#x2F;&#x2F;设置速度-实际速度，两者的差值 
	duk&#x3D;(Kp*(e-e1)+Ki*e)&#x2F;100;&#x2F;&#x2F;只调节PI
	uk&#x3D;uk1+duk;&#x2F;&#x2F;uk&#x3D;u(k-1)+Δuk
	out&#x3D;(int)uk;&#x2F;&#x2F;取整后输出
	if(out&gt;90)	&#x2F;&#x2F;设置最大限制
		out&#x3D;90;
	else if(out&lt;0)&#x2F;&#x2F;设置最小限制
		out&#x3D;0;
	uk1&#x3D;uk;		  &#x2F;&#x2F;为下一次增量做准备
	e2&#x3D;e1;
	e1&#x3D;e;
	
	PWMTime&#x3D;(u16)out;  &#x2F;&#x2F;out对应于PWM高电平的时间

	MOTO_pwm_set(PWMTime);
&#125;
void PID_ram_init(void)
&#123;
    &#x2F;&#x2F;pid偏差
	e &#x3D; 0;
    e1 &#x3D; 0;
    e2 &#x3D; 0;
    &#x2F;&#x2F;pid输出值
    uk &#x3D; 0;
    uk1 &#x3D; 0;
    duk &#x3D; 0;
	num &#x3D; 0;
	out &#x3D; 0;
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_ GPIO_ Init.h*************************&#x2F;
&#x2F;&#x2F;电机
# define RUN_OFF		(GPIOD-&gt;BSRRH &#x3D; GPIO_Pin_4)	&#x2F;&#x2F;管脚设为低电平(相当于停止)
# define RUN_ON		(GPIOD-&gt;BSRRL &#x3D; GPIO_Pin_4)	&#x2F;&#x2F;管脚设为高电平(相当于启动)    </code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
&#x2F;&#x2F;轮盘速度(越大速度越快)
# define MOTO_SPEED_SET	30</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************MOTO.c*************************&#x2F;
&#x2F;&#x2F;转盘电机PWM初始化(这里没设置互补通道故相当于普通PWM模式)
void TIM1_PWM_Init_PA8(u32 arr,u32 psc)
&#123; 
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;	&#x2F;&#x2F;定义结构体
	TIM_OCInitTypeDef TIM_OCInitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);	&#x2F;&#x2F;使能TIM1时钟
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);	&#x2F;&#x2F;使能A组时钟
	
	GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;	&#x2F;&#x2F;复用模式
	GPIO_InitStructure.GPIO_OType &#x3D; GPIO_OType_PP;	&#x2F;&#x2F;推挽输出
	GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_8;	&#x2F;&#x2F;PA^8
	GPIO_InitStructure.GPIO_PuPd &#x3D; GPIO_PuPd_NOPULL;	&#x2F;&#x2F;无上下拉
	GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_100MHz;	&#x2F;&#x2F;速度
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);	&#x2F;&#x2F;初始化
	
	GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_TIM1);	&#x2F;&#x2F;PA^8复用为TIM1_CH1
	
	TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; TIM_CKD_DIV1;	&#x2F;&#x2F;分频因子为1
	TIM_TimeBaseStructure.TIM_CounterMode &#x3D; TIM_CounterMode_Up;	&#x2F;&#x2F;向上计数
	TIM_TimeBaseStructure.TIM_Prescaler &#x3D; psc;&#x2F;&#x2F;Timer clock &#x3D; sysclock &#x2F;(TIM_Prescaler+1) &#x3D; 168M 
	TIM_TimeBaseStructure.TIM_RepetitionCounter &#x3D; 0; &#x2F;&#x2F;此参数不用需配置为0(只有高级定时器才有)
	TIM_TimeBaseStructure.TIM_Period &#x3D; arr; &#x2F;&#x2F;Period &#x3D; (TIM counter clock &#x2F; TIM output clock) - 1 &#x3D; 20K 
	
	TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseStructure); 
	
	
	TIM_OCInitStructure.TIM_OCMode &#x3D; TIM_OCMode_PWM1; 	&#x2F;&#x2F;PWM1模式(CNT&lt;CCR有效，反之无效)
	TIM_OCInitStructure.TIM_OutputState &#x3D; TIM_OutputState_Enable; &#x2F;&#x2F;互补输出使能。开启OCN输出到对应的管脚
	TIM_OCInitStructure.TIM_OutputNState &#x3D; TIM_OutputNState_Enable; &#x2F;&#x2F;互补输出使能。开启OCN输出到对应的管脚   
	TIM_OCInitStructure.TIM_Pulse &#x3D; (arr+1)&#x2F;2; &#x2F;&#x2F;重装载值的一半
	TIM_OCInitStructure.TIM_OCPolarity &#x3D; TIM_OCPolarity_High; &#x2F;&#x2F;主通道的输出极性
	TIM_OCInitStructure.TIM_OCNPolarity &#x3D; TIM_OCPolarity_High; &#x2F;&#x2F;互补通道的输出极性
	TIM_OCInitStructure.TIM_OCIdleState &#x3D; TIM_OCIdleState_Set; &#x2F;&#x2F;空闲状态输出高电平
	TIM_OCInitStructure.TIM_OCNIdleState &#x3D; TIM_OCNIdleState_Reset; &#x2F;&#x2F;空闲状态输出低电平
	
	TIM_OC1Init(TIM1,&amp;TIM_OCInitStructure);	&#x2F;&#x2F;使能
	TIM_Cmd(TIM1,ENABLE);
	
	TIM_CtrlPWMOutputs(TIM1,ENABLE);	&#x2F;&#x2F;高级定时器才有  必须打开
&#125;

&#x2F;&#x2F;转盘电机控制初始化     PWM:PA8		RUN:PD4		BACK:PD13
void MOTO_init(void)
&#123;
	GPIO_init(GPIO_D,GPIO_Pin_4,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;D4			RUN
	GPIO_init(GPIO_D,GPIO_Pin_13,GPIO_Mode_OUT,GPIO_OType_PP,GPIO_PuPd_NOPULL);&#x2F;&#x2F;D13		BACK
	RUN_OFF;
	BACK_OFF;
	&#x2F;&#x2F;计算：100*84&#x2F;168000000 &#x3D; 0.00005s &#x3D; 0.05ms (1KHz &#x3D; 1ms --&gt; 20KHz &#x3D; 0.05ms)
    &#x2F;&#x2F;右边&#x2F;20,左边*20
	TIM1_PWM_Init_PA8(100-1,84-1);	&#x2F;&#x2F;频率 20kHz  占空比  0-100

	TIM_SetCompare1(TIM1,100);&#x2F;&#x2F;最大0   最小100   PWM输出经过了数字电路  低电平有效
&#125;
&#x2F;&#x2F;识别到RFID后开始设置速度，pid初始化，准备启动
void MOTO_run_fun(void)
&#123;
	PID_ram_init();
	moto_speed &#x3D; MOTO_SPEED_SET;	&#x2F;&#x2F;速度
	moto_run_bit &#x3D; 1;
&#125;

&#x2F;&#x2F;轮盘停止(暂时没用到)
void MOTO_stop_fun(void)
&#123;
	moto_run_bit &#x3D; 0;
	RUN_OFF;
	MOTO_pwm_set(0);
&#125;
&#x2F;&#x2F;转盘电机PWM输出
void MOTO_pwm_set(u16 speed)
&#123;
	RUN_ON;
	
	TIM_SetCompare1(TIM1,100-speed);&#x2F;&#x2F;因为电平有一个 74HC02 所以  电平是反的   低电平 开始转
&#125;

&#x2F;&#x2F;编码器 计数 TIM3 PD2 计数程序初始化  用于转盘电机编码器
void TIM3_PD2_encoder_Init(void)
&#123;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	GPIO_init(GPIO_D,GPIO_Pin_2,GPIO_Mode_AF,GPIO_OType_OD,GPIO_PuPd_NOPULL);	&#x2F;&#x2F;复用，开漏，无上下拉
	
	GPIO_PinAFConfig(GPIOD,GPIO_PinSource2,GPIO_AF_TIM3);	&#x2F;&#x2F;复用PD^2为TIM3
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);	&#x2F;&#x2F;使能TIM3时钟

	TIM_TimeBaseStructure.TIM_Prescaler &#x3D; 0x00; &#x2F;&#x2F;预分频系数
	TIM_TimeBaseStructure.TIM_Period &#x3D; 0xFFFF; &#x2F;&#x2F;重装载值
	TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; 0x0; 
	TIM_TimeBaseStructure.TIM_CounterMode &#x3D; TIM_CounterMode_Up; 
	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure);  &#x2F;&#x2F; 定时器3初始化

	TIM_ETRClockMode2Config(TIM3,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted, 0);	&#x2F;&#x2F;配置ETR外部输入触发模式，外部输入模式2

	TIM_SetCounter(TIM3, 0);	&#x2F;&#x2F;清0
	TIM_Cmd(TIM3, ENABLE); 
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_Timer_eval.c*************************&#x2F;
&#x2F;&#x2F;定时器中断服务函数
&#x2F;&#x2F;定时20ms
void TIM5_IRQHandler(void)
&#123;
    if(TIM_GetITStatus(TIM5, TIM_IT_Update) !&#x3D; RESET)	&#x2F;&#x2F;&#x3D;&#x3D;1表示发生溢出中断
    &#123;
        TIM_ClearITPendingBit(TIM5, TIM_IT_Update);	&#x2F;&#x2F;清除标志位
        timer5_int_bit &#x3D; 1;
        if(moto_run_bit &#x3D;&#x3D; 1)
        &#123;
            timer5_speed_pid_fun(moto_speed);	&#x2F;&#x2F;在这轮盘一直动
        &#125;

        PG9_F;	&#x2F;&#x2F;暂不知道这个什么用处
    &#125;
&#125;</code></pre>
<h4 id="舵机-2">舵机</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
<th style="text-align:center">对应舵机(小车出发点起)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PA^6(TIM13_CH1)</td>
<td style="text-align:center">DOUJI1</td>
<td style="text-align:center">复用，推挽，无上下拉</td>
<td style="text-align:center">舵机1</td>
</tr>
<tr>
<td style="text-align:center">PC^8(TIM8_CH3)</td>
<td style="text-align:center">DOUJI2</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">舵机2</td>
</tr>
<tr>
<td style="text-align:center">PD^12(TIM4_CH1)</td>
<td style="text-align:center">DOUJI3</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">舵机3</td>
</tr>
<tr>
<td style="text-align:center">PC^9(TIM8_CH4)</td>
<td style="text-align:center">DOUJI4</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">舵机4</td>
</tr>
</tbody>
</table>
<ul>
<li>对于180°的舵机，一般来说周期为 <code>20ms</code>（频率为50Hz），频率越高，舵机反应速度越快，但是力的输出却越小，脉宽(一个周期内高电平持续时间)为 <code>500–2500us</code>。其中为1500us使得舵机转轮处于中间位置，可以理解为90°的位置，为500-1500us和1500–2500us之间分别会朝着0–90°和90–180°的方向旋转(慢慢增大占空比的时间延长点可以把舵机旋转速度降下来)</li>
<li>本轮盘4个舵机型号是 <code>MG995</code>，下面是它的一些需要注意的地方</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">t占空比高电平持续时间(频率20ms)</th>
<th style="text-align:center">角度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0.5ms</td>
<td style="text-align:center">舵机会转动 0 °</td>
</tr>
<tr>
<td style="text-align:center">1.0ms</td>
<td style="text-align:center">舵机会转动 45°</td>
</tr>
<tr>
<td style="text-align:center">1.5ms</td>
<td style="text-align:center">舵机会转动 90°</td>
</tr>
<tr>
<td style="text-align:center">2.0ms</td>
<td style="text-align:center">舵机会转动 135°</td>
</tr>
<tr>
<td style="text-align:center">2.5ms</td>
<td style="text-align:center">舵机会转动180°</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
&#x2F;&#x2F;舵机推和收的PWM参数
# define PULL1		275&#x2F;&#x2F;290
# define SHRINK1	100&#x2F;&#x2F;120

# define PULL2		280&#x2F;&#x2F;265
# define SHRINK2	100&#x2F;&#x2F;105

# define PULL3		280&#x2F;&#x2F;280
# define SHRINK3	100&#x2F;&#x2F;115

# define PULL4		285&#x2F;&#x2F;255
# define SHRINK4	100&#x2F;&#x2F;95</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************MOTO.c*************************&#x2F;
&#x2F;&#x2F;舵机1(剩下3个舵机配置一样只是引脚不一样)
void TIM13_PWM_Init_PA6(u32 arr,u32 psc)
&#123; 
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;	&#x2F;&#x2F;定义结构体
	TIM_OCInitTypeDef TIM_OCInitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM13,ENABLE);	&#x2F;&#x2F;使能TIM13时钟
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);	&#x2F;&#x2F;使能A组时钟
	
	GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;	&#x2F;&#x2F;复用
	GPIO_InitStructure.GPIO_OType &#x3D; GPIO_OType_PP;	&#x2F;&#x2F;推挽
	GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_6;	&#x2F;&#x2F;PA^6
	GPIO_InitStructure.GPIO_PuPd &#x3D; GPIO_PuPd_NOPULL;	&#x2F;&#x2F;无上下拉
	GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_100MHz;	&#x2F;&#x2F;速度
	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);
	
	GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_TIM13);	&#x2F;&#x2F;复用引脚为TIM13
	
	TIM_TimeBaseStructure.TIM_ClockDivision &#x3D; TIM_CKD_DIV1;	&#x2F;&#x2F;分频因子
	TIM_TimeBaseStructure.TIM_CounterMode &#x3D; TIM_CounterMode_Up;	&#x2F;&#x2F;向上计数
	TIM_TimeBaseStructure.TIM_Prescaler &#x3D; psc;	&#x2F;&#x2F;预分频系数
	TIM_TimeBaseStructure.TIM_RepetitionCounter &#x3D; 0; 
	TIM_TimeBaseStructure.TIM_Period &#x3D; arr;	&#x2F;&#x2F;重装载值
	
	TIM_TimeBaseInit(TIM13,&amp;TIM_TimeBaseStructure);
	
	&#x2F;&#x2F;互补通道也就是含N的结构体成员可写可不写没影响(如果不需要互补通道的话)
	TIM_OCInitStructure.TIM_OCMode &#x3D; TIM_OCMode_PWM1;	&#x2F;&#x2F;PWM1模式(cnt&lt;rcc电平有效；反之无效)
	TIM_OCInitStructure.TIM_OutputState &#x3D; TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_OutputNState &#x3D; TIM_OutputNState_Enable;
	TIM_OCInitStructure.TIM_Pulse &#x3D; (arr+1)&#x2F;2;	&#x2F;&#x2F;重装载的一半
	TIM_OCInitStructure.TIM_OCPolarity &#x3D; TIM_OCPolarity_High;	&#x2F;&#x2F;有效电平为高
	TIM_OCInitStructure.TIM_OCNPolarity &#x3D; TIM_OCPolarity_High;
	TIM_OCInitStructure.TIM_OCIdleState &#x3D; TIM_OCIdleState_Set;
	TIM_OCInitStructure.TIM_OCNIdleState &#x3D; TIM_OCNIdleState_Reset;
	
	TIM_OC1Init(TIM13,&amp;TIM_OCInitStructure);
	TIM_Cmd(TIM13,ENABLE);	&#x2F;&#x2F;使能TIM13
	
	TIM_CtrlPWMOutputs(TIM13,ENABLE);	&#x2F;&#x2F;此函数仅高级定时器才需要加(其他定时器可省略)
&#125;

&#x2F;&#x2F;4个舵机初始化
void pwm_init(void)
&#123;
	&#x2F;&#x2F;PA6  	ok
	&#x2F;&#x2F;PC8	ok
	&#x2F;&#x2F;D12	OK
	&#x2F;&#x2F;C9	OK
	&#x2F;&#x2F;下面如果想更加精准点可以通过公式计算即可
	TIM13_PWM_Init_PA6(5000-1,335-1);	&#x2F;&#x2F; 5000*335&#x2F;84000000 ≈ 0.0199s ≈ 20ms(50Hz)
	TIM8_PWM_Init_PC8(5000-1,670-1);	&#x2F;&#x2F; 5000*670&#x2F;168000000 ≈ 0.0199s ≈ 20ms(50Hz) 为什么是670? 因为可以通过分母扩大2倍分子也扩大2倍来保持结果不变 
	TIM4_PWM_Init_PD12(5000-1,335-1);
	TIM8_PWM_Init_PC9(5000-1,670-1); 
	
	
	&#x2F;&#x2F;750&#x3D;2.5ms	125&#x3D;0.5ms
	
	steering_engine_1_shrink();
	steering_engine_2_shrink();
	steering_engine_3_shrink();
	steering_engine_4_shrink();
&#125;
&#x2F;&#x2F;舵机1推---收(剩下3个舵机配置一样占空比也是一样)
void steering_engine_1_push(void)
&#123;
	u16 pwm_data;
	&#x2F;&#x2F;printf(&quot;PWM1_open\r\n&quot;);
	
	
	pwm_data &#x3D; SHRINK1;
	while(pwm_data&lt;&#x3D;PULL1)	&#x2F;&#x2F;pwm_data:100 PULL1:275(占空比范围:2%~5.5%)
	&#123;
        &#x2F;&#x2F;最小占空比:100&#x2F;5000 &#x3D; 0.02 &#x3D; 2%
        &#x2F;&#x2F;最大占空比:275&#x2F;5000 &#x3D; 0.055 &#x3D; 5.5%
		TIM_SetCompare1(TIM13,pwm_data);
		pwm_data++;
		delay_ms(2);&#x2F;&#x2F;决定了舵机推出去的速度(延时越大速度越慢)
	&#125;
	
&#125;

void steering_engine_1_shrink(void)
&#123;
	TIM_SetCompare1(TIM13,SHRINK1);&#x2F;&#x2F;占空比:100&#x2F;5000 &#x3D; 0.02 &#x3D; 2%
	&#x2F;&#x2F;printf(&quot;PWM1_close\r\n&quot;);
&#125;
</code></pre>
<h4 id="蜂鸣器-2">蜂鸣器</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PG^1</td>
<td style="text-align:center">BELL</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_ GPIO _Init.h*************************&#x2F;
&#x2F;&#x2F;蜂鸣器
# define BELL_OFF	(GPIOG-&gt;BSRRH &#x3D; GPIO_Pin_1)	&#x2F;&#x2F;管脚设为低电平(不响)
# define BELL_ON		(GPIOG-&gt;BSRRL &#x3D; GPIO_Pin_1)	&#x2F;&#x2F;管脚设为高电平(响),因为原理图那个是NPN三极管需要高电平导通
&#x2F;&#x2F;没用到(蜂鸣器的)
# define	BELL_F		GPIOG-&gt;ODR^&#x3D;GPIO_Pin_2	</code></pre>
<h4 id="光电管">光电管</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PF^1</td>
<td style="text-align:center">WEIZHI1(托盘的反射管)</td>
<td style="text-align:center">输入，开漏，上拉(因为距离太近，有光是1，无光是0)</td>
</tr>
<tr>
<td style="text-align:center">PF^2</td>
<td style="text-align:center">WEIZHI2(托盘的反射管)</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^3</td>
<td style="text-align:center">WEIZHI3(托盘的反射管)</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF^4</td>
<td style="text-align:center">WEIZHI4(托盘的反射管)</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PA5</td>
<td style="text-align:center">SW1(第一个光电对射)</td>
<td style="text-align:center">输出，开漏，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PD7</td>
<td style="text-align:center">SW2(第二个光电对射)</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PE8</td>
<td style="text-align:center">SW3</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PE10</td>
<td style="text-align:center">SW4</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF12</td>
<td style="text-align:center">SW6</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PF11</td>
<td style="text-align:center">SW5</td>
<td style="text-align:center">同上</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>轮盘有 <code>2</code> 个对射管 ， <code>4</code> 个反射管(分别在4个托盘上用来识别是否有物体在托盘)； <code>有光是1  无光是0</code></p>
</li>
<li>
<p><code>第一个光电对射管</code>是判断物<code>块是否已经进入识别区域(需要MQTT把识别结果发送回来第二个光电对射管才会进行对应操作)； </code>第二个红外对射光电管` 判断物块是否已经通过识别区域(如果识别通过则将这个物块的类别和位置计数清零)</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_ GPIO _Init.h*************************&#x2F;
&#x2F;&#x2F;光电对射
# define READ_DUIGUAN1		GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_5)	&#x2F;&#x2F;读取第一个光电对射的电平状态
# define READ_DUIGUAN2		GPIO_ReadInputDataBit(GPIOD,GPIO_Pin_7)	&#x2F;&#x2F;读取第二个光电对射的电平状态
# define READ_DUIGUAN3		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_8)	&#x2F;&#x2F;这4个没用到暂时不用管
# define READ_DUIGUAN4		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_10)
# define READ_DUIGUAN5		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_12)
# define READ_DUIGUAN6		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_11)

&#x2F;&#x2F;托盘位置的反射管
# define READ_WEIZHI1		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_1)
# define READ_WEIZHI2		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_2)
# define READ_WEIZHI3		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_3)
# define READ_WEIZHI4		GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_4)</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32F40x_ GPIO _Init.c*************************&#x2F;
&#x2F;&#x2F;光电对射管
void Photoelectric_switch_gpio_init(void)
&#123;
	&#x2F;&#x2F;1:PF1
	&#x2F;&#x2F;2:PF2
	&#x2F;&#x2F;3:PF3
	&#x2F;&#x2F;4:PF4
&#x2F;&#x2F;反射管脚
	GPIO_init(GPIO_F,GPIO_Pin_1,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_UP);&#x2F;&#x2F;PF1   &#x2F;&#x2F;有光是1  无光是0   必须是上拉模式   不然距离有太近   不到10cm
	GPIO_init(GPIO_F,GPIO_Pin_2,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_UP);&#x2F;&#x2F;PF2
	GPIO_init(GPIO_F,GPIO_Pin_3,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_UP);&#x2F;&#x2F;PF3
	GPIO_init(GPIO_F,GPIO_Pin_4,GPIO_Mode_IN,GPIO_OType_OD,GPIO_PuPd_UP);&#x2F;&#x2F;PF4
	

&#x2F;&#x2F;第一个对射管脚	
   GPIO_init(GPIO_A,GPIO_Pin_5,GPIO_Mode_OUT,GPIO_OType_OD,GPIO_PuPd_NOPULL);&#x2F;&#x2F;PA5
	(GPIOA-&gt;BSRRL &#x3D; GPIO_Pin_5);	&#x2F;&#x2F;设为高电平
	
	
&#x2F;&#x2F;第二个对射管脚
   GPIO_init(GPIO_D,GPIO_Pin_7,GPIO_Mode_OUT,GPIO_OType_OD,GPIO_PuPd_NOPULL);&#x2F;&#x2F;PD7
	(GPIOD-&gt;BSRRL &#x3D; GPIO_Pin_7);
	
	GPIO_init(GPIO_E,GPIO_Pin_8,GPIO_Mode_OUT,GPIO_OType_OD,GPIO_PuPd_NOPULL);&#x2F;&#x2F;PE8
	(GPIOE-&gt;BSRRL &#x3D; GPIO_Pin_8);
	
	GPIO_init(GPIO_E,GPIO_Pin_10,GPIO_Mode_OUT,GPIO_OType_OD,GPIO_PuPd_NOPULL);&#x2F;&#x2F;PE10
	(GPIOE-&gt;BSRRL &#x3D; GPIO_Pin_10);
	
	GPIO_init(GPIO_F,GPIO_Pin_12,GPIO_Mode_OUT,GPIO_OType_OD,GPIO_PuPd_NOPULL);&#x2F;&#x2F;PF12
	(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_12);
	
	GPIO_init(GPIO_F,GPIO_Pin_11,GPIO_Mode_OUT,GPIO_OType_OD,GPIO_PuPd_NOPULL);&#x2F;&#x2F;PF11
	(GPIOF-&gt;BSRRL &#x3D; GPIO_Pin_11);
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************task.c*************************&#x2F;
&#x2F;&#x2F;两个对射管电平状态存储数组
u8 Photoelectric_switch_new[2];&#x2F;&#x2F;两个光电对射
u8 Photoelectric_switch_old[2];

&#x2F;&#x2F;托盘的反射管电平状态存储数组
u8 position_switch_new[4];&#x2F;&#x2F;四个光电反射
u8 position_switch_old[4];

u8 interrupt1;	&#x2F;&#x2F;经过第一个光电对射标志位
u8 interrupt2;	&#x2F;&#x2F;经过第二个光电对射标志位


u8 weizhi1_interrupt_in;	&#x2F;&#x2F;托盘有物品
u8 weizhi2_interrupt_in;
u8 weizhi3_interrupt_in;
u8 weizhi4_interrupt_in;

u8 weizhi1_interrupt_out;	&#x2F;&#x2F;托盘没有物品
u8 weizhi2_interrupt_out;
u8 weizhi3_interrupt_out;
u8 weizhi4_interrupt_out;


&#x2F;&#x2F;读取光电管的变化
void read_interrupt_fun(void)
&#123;
	&#x2F;&#x2F;第一个光电对射
	Photoelectric_switch_new[0] &#x3D; READ_DUIGUAN1;	&#x2F;&#x2F;读取最新的电平状态(第一次读取时是没有物体的所以一定是1，当有物体经过时变0)
	if((Photoelectric_switch_new[0]&#x3D;&#x3D;0)&amp;&amp;(Photoelectric_switch_old[0]&#x3D;&#x3D;1))
	&#123;
		interrupt1 &#x3D; 1;	&#x2F;&#x2F;标志位置1表示经过了第一个对射
		&#x2F;&#x2F;printf(&quot;interrupt1\r\n&quot;);
	&#125;
	Photoelectric_switch_old[0] &#x3D; Photoelectric_switch_new[0];	&#x2F;&#x2F;把当前状态存储起来
	
	&#x2F;&#x2F;第二个光电对射
	Photoelectric_switch_new[1] &#x3D; READ_DUIGUAN2;
	if((Photoelectric_switch_new[1]&#x3D;&#x3D;0)&amp;&amp;(Photoelectric_switch_old[1]&#x3D;&#x3D;1))
	&#123;
		interrupt2 &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;interrupt2\r\n&quot;);
	&#125;
	Photoelectric_switch_old[1] &#x3D; Photoelectric_switch_new[1];
	
	
	&#x2F;&#x2F;第一个位置
	position_switch_new[0] &#x3D; READ_WEIZHI1;
	if((position_switch_new[0]&#x3D;&#x3D;0)&amp;&amp;(position_switch_old[0]&#x3D;&#x3D;1))
	&#123;
		weizhi1_interrupt_in &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;weizhi1_in\r\n&quot;);
	&#125;
	if((position_switch_new[0]&#x3D;&#x3D;1)&amp;&amp;(position_switch_old[0]&#x3D;&#x3D;0))
	&#123;
		weizhi1_interrupt_out &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;weizhi1_out\r\n&quot;);
	&#125;
	position_switch_old[0] &#x3D; position_switch_new[0];
	
	
	
	&#x2F;&#x2F;第二个位置
	position_switch_new[1] &#x3D; READ_WEIZHI2;
	if((position_switch_new[1]&#x3D;&#x3D;0)&amp;&amp;(position_switch_old[1]&#x3D;&#x3D;1))
	&#123;
		weizhi2_interrupt_in &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;weizhi2_in\r\n&quot;);
	&#125;
	if((position_switch_new[1]&#x3D;&#x3D;1)&amp;&amp;(position_switch_old[1]&#x3D;&#x3D;0))
	&#123;
		weizhi2_interrupt_out &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;weizhi2_out\r\n&quot;);
	&#125;
	position_switch_old[1] &#x3D; position_switch_new[1];
	
	
	
	&#x2F;&#x2F;第三个位置
	position_switch_new[2] &#x3D; READ_WEIZHI3;
	if((position_switch_new[2]&#x3D;&#x3D;0)&amp;&amp;(position_switch_old[2]&#x3D;&#x3D;1))
	&#123;
		weizhi3_interrupt_in &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;weizhi3_in\r\n&quot;);
	&#125;
	if((position_switch_new[2]&#x3D;&#x3D;1)&amp;&amp;(position_switch_old[2]&#x3D;&#x3D;0))
	&#123;
		weizhi3_interrupt_out &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;weizhi3_out\r\n&quot;);
	&#125;
	position_switch_old[2] &#x3D; position_switch_new[2];
	
	
	
	&#x2F;&#x2F;第四个位置
	position_switch_new[3] &#x3D; READ_WEIZHI4;
	if((position_switch_new[3]&#x3D;&#x3D;0)&amp;&amp;(position_switch_old[3]&#x3D;&#x3D;1))
	&#123;
		weizhi4_interrupt_in &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;weizhi4_in\r\n&quot;);
	&#125;
	if((position_switch_new[3]&#x3D;&#x3D;1)&amp;&amp;(position_switch_old[3]&#x3D;&#x3D;0))
	&#123;
		weizhi4_interrupt_out &#x3D; 1;
		&#x2F;&#x2F;printf(&quot;weizhi4_out\r\n&quot;);
	&#125;
	position_switch_old[3] &#x3D; position_switch_new[3];
&#125;
&#x2F;&#x2F;经过第一个光电对射时执行动作
void Photoelectric_switch_1_fun(void)&#x2F;&#x2F;第一个光电开关信号处理
&#123;
	u8 i;
	
	for(i&#x3D;0;i&lt;TASK_MUN;i++)&#x2F;&#x2F;从0开始查看  垃圾的状态  为空的  设置成下一个状态  就是等待摄像头识别
	&#123;
		if(task_buf[i][GARBAGE_STATE]&#x3D;&#x3D;EMPTY)&#x2F;&#x2F;如果是空
		&#123;
			task_buf[i][GARBAGE_STATE] &#x3D; WAIT_CAMERA;&#x2F;&#x2F;垃圾状态变成等待摄像头识别
			&#x2F;&#x2F;printf(&quot;position 1 int\r\n&quot;);
			break;
		&#125;
	&#125;
&#125;


&#x2F;&#x2F;经过第二个光电对射时执行动作
void Photoelectric_switch_2_fun(void)&#x2F;&#x2F;第2个光电开关信号处理
&#123;
	u8 i;
	
	for(i&#x3D;0;i&lt;TASK_MUN;i++)
	&#123;
		if(task_buf[i][GARBAGE_STATE]&#x3D;&#x3D;CAMERA_OK)
		&#123;
			task_buf[i][GARBAGE_STATE] &#x3D; WAIT_ENGINE;&#x2F;&#x2F;等待舵机推
			task_buf[i][TURNTABLE_COUNT] &#x3D; 0;&#x2F;&#x2F;计数清零(准备开始计数脉冲)
			&#x2F;&#x2F;printf(&quot;position 2 int\r\n&quot;);
			break;
		&#125;
	&#125;
&#125;
&#x2F;&#x2F;位置有东西
void position_in_fun(void)
&#123;
	u8 i;
	
	for(i&#x3D;0;i&lt;TASK_MUN;i++)
	&#123;
		if(task_buf[i][GARBAGE_STATE]&#x3D;&#x3D;PUSH)	&#x2F;&#x2F;判断当前垃圾状态是否为推的过程，是则把状态改为到达托盘
		&#123;
			task_buf[i][GARBAGE_STATE]&#x3D;ARRIVE_OK;	&#x2F;&#x2F;垃圾状态为到达托盘
			break;
		&#125;
	&#125;
&#125;


&#x2F;&#x2F;位置没有东西
void position_out_fun(void)
&#123;
	u8 i;
	
	for(i&#x3D;0;i&lt;TASK_MUN;i++)
	&#123;
		if(task_buf[i][GARBAGE_STATE]&#x3D;&#x3D;ARRIVE_OK)	&#x2F;&#x2F;当垃圾状态为到达托盘且被车取走时
		&#123;
			task_buf[i][GARBAGE_STATE]&#x3D;TRANSPORT;&#x2F;&#x2F;状态为被小车拿走运送中
			break;
		&#125;
	&#125;
&#125;</code></pre>
<h4 id="RFID">RFID</h4>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PG^15</td>
<td style="text-align:center">MISO(SPI数据输入)</td>
<td style="text-align:center">输入，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PB^9</td>
<td style="text-align:center">SCK(SPI时钟)</td>
<td style="text-align:center">输出，推挽，无上下拉</td>
</tr>
<tr>
<td style="text-align:center">PG^13</td>
<td style="text-align:center">MOSI(SPI数据输出)</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PG^12</td>
<td style="text-align:center">NSS(SPI片选)</td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center">PB^8</td>
<td style="text-align:center">RST(复位)</td>
<td style="text-align:center">同上</td>
</tr>
</tbody>
</table>
<ul>
<li>RC522是13.56MHz非接触通讯高集成度的芯片，通过SPI接口与S50卡通讯，完成卡的识别，读卡，写卡等操作</li>
</ul>
<h3 id="串口2无线通信-4">串口2无线通信</h3>
<table>
<thead>
<tr>
<th style="text-align:center">管脚</th>
<th style="text-align:center">对应</th>
<th style="text-align:center">模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PA^3</td>
<td style="text-align:center">USART2_RX</td>
<td style="text-align:center">复用，推挽，上拉</td>
</tr>
<tr>
<td style="text-align:center">PD^5</td>
<td style="text-align:center">USART2_TX</td>
<td style="text-align:center">复用，推挽，上拉</td>
</tr>
</tbody>
</table>
<ul>
<li>目前只有小车会给转盘发命令  就一种命令  就是小车的任务完成</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************task.c*************************&#x2F;
u8 car_busy_bit &#x3D; 0;	&#x2F;&#x2F;小车忙的标志位 0:空闲 1:忙</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************STM32H40x_ Usart eval.h*************************&#x2F;
# define UART2_RACE_MUN	100	&#x2F;&#x2F;串口2数组大小
u8 uart2_cmd_buf[100];	&#x2F;&#x2F;命令数组(存储usart2_race_buf的数据)
u8 uart2_cmd_count;	&#x2F;&#x2F;数组索引
u8 usart2_send_buf[100];	&#x2F;&#x2F;USART2发送数据数组
u8 usart2_race_buf[UART2_RACE_MUN];	&#x2F;&#x2F;接收USART2接收到的数据
u8 usart2_race_over_bit;	&#x2F;&#x2F;接收一帧完成标志位
u8 usart2_race_count;	&#x2F;&#x2F;数组索引



&#x2F;*************************STM32H40x_ Usart eval.c*************************&#x2F;
&#x2F;&#x2F;USART2初始化
void Uart2_Init(void)
&#123;
	GPIO_InitTypeDef GPIO_InitStructure;	&#x2F;&#x2F;定义结构体
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	

  &#x2F;* Enable GPIO clock *&#x2F;
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);	&#x2F;&#x2F;使能对应时钟
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	
  &#x2F;* Connect PXx to USARTx_Tx*&#x2F;
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_USART2);	&#x2F;&#x2F;将对应管脚复用为USART2
	
  &#x2F;* Connect PXx to USARTx_Rx*&#x2F;
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);	
	
	&#x2F;* Configure USART Tx as alternate function  *&#x2F;
  GPIO_InitStructure.GPIO_OType &#x3D; GPIO_OType_PP;	&#x2F;&#x2F;推挽
  GPIO_InitStructure.GPIO_PuPd &#x3D; GPIO_PuPd_UP;	&#x2F;&#x2F;上拉
  GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;	&#x2F;&#x2F;复用

  GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_5;	&#x2F;&#x2F;PD^5
  GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz;
  GPIO_Init(GPIOD, &amp;GPIO_InitStructure);

  &#x2F;* Configure USART Rx as alternate function  *&#x2F;
  GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_3;	&#x2F;&#x2F;PA^3
  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
	

	&#x2F;* Configure and enable I2C DMA TX Stream interrupt *&#x2F;
  NVIC_InitStructure.NVIC_IRQChannel &#x3D; USART2_IRQn;	&#x2F;&#x2F;串口中断通道
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 2;	&#x2F;&#x2F;先占优先级
  NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0;	&#x2F;&#x2F;子优先级
  NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;	&#x2F;&#x2F;使能通道
  NVIC_Init(&amp;NVIC_InitStructure);	&#x2F;&#x2F;初始化
	
	
  &#x2F;* Enable USART clock *&#x2F;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);&#x2F;&#x2F;串口2的时钟使能
	
	&#x2F;&#x2F;USART2 初始化设置
	USART_InitStructure.USART_BaudRate &#x3D; 115200;&#x2F;&#x2F;一般设置为115200;
	USART_InitStructure.USART_WordLength &#x3D; USART_WordLength_8b;&#x2F;&#x2F;8bit
	USART_InitStructure.USART_StopBits &#x3D; USART_StopBits_1;&#x2F;&#x2F;停止位1位
	USART_InitStructure.USART_Parity &#x3D; USART_Parity_No;&#x2F;&#x2F;无流控
	USART_InitStructure.USART_HardwareFlowControl &#x3D; USART_HardwareFlowControl_None;	&#x2F;&#x2F;无硬件流控制
	USART_InitStructure.USART_Mode &#x3D; USART_Mode_Rx | USART_Mode_Tx;	&#x2F;&#x2F;接收&#x2F;发送
	
	&#x2F;* USART2 configuration *&#x2F;
	USART_Init(USART2, &amp;USART_InitStructure);
  
	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);&#x2F;&#x2F;开启接收中断
	USART_ITConfig(USART2, USART_IT_IDLE, ENABLE);&#x2F;&#x2F;开启空闲总线中断
	
	&#x2F;* Enable USART2 *&#x2F;
	USART_Cmd(USART2, ENABLE);
	
	USART_ClearFlag(USART2, USART_FLAG_TC);	&#x2F;&#x2F;清除发送完成标志位
&#125;



&#x2F;&#x2F;USART2发送多个字节
void Uart2_send_data(unsigned char *dat, unsigned short len)
&#123;
	uart2_race_init();
	
	while(len--)
	&#123;
		while(USART_GetFlagStatus(USART2, USART_FLAG_TC) &#x3D;&#x3D; RESET);&#x2F;&#x2F;传输完成
		USART2-&gt;DR &#x3D; (*dat &amp; (uint16_t)0x01FF);
		dat++;
	&#125;
&#125;




&#x2F;&#x2F;USART2串口中断服务函数
void USART2_IRQHandler(void)
&#123;
	u8 Res;
	u8 temp;
	
	temp &#x3D; temp;
	
	if(USART_GetITStatus(USART2, USART_IT_RXNE) !&#x3D; RESET)  &#x2F;&#x2F;接收中断
	&#123;
		Res &#x3D; USART_ReceiveData(USART2);&#x2F;&#x2F;(UART4-&gt;DR);	&#x2F;&#x2F;读取接收到的数据
		
		usart2_race_buf[usart2_race_count] &#x3D; Res;	&#x2F;&#x2F;将接收的数据保存到数组
		usart2_race_count++;
		if(usart2_race_count&#x3D;&#x3D;UART2_RACE_MUN)	&#x2F;&#x2F;如果接收的数量超过定义的最大大小则为0
		&#123;
			usart2_race_count &#x3D; 0;
		&#125;
	&#125;
	if(USART_GetITStatus(USART2, USART_IT_IDLE) !&#x3D; RESET)  &#x2F;&#x2F;空闲中断
	&#123;
		&#x2F;&#x2F;清除标志位
		temp &#x3D; USART2-&gt;SR;	&#x2F;&#x2F;先读USART_SR，然后写入USART_DR
		temp &#x3D; USART2-&gt;DR;	
		
		usart2_race_over_bit &#x3D; 1;
	&#125;
&#125;


&#x2F;&#x2F;串口2接收标志位&#x2F;数组索引清零
void uart2_race_init(void)
&#123;
	usart2_race_over_bit &#x3D; 0;
	usart2_race_count &#x3D; 0;
&#125;
&#x2F;&#x2F;串口2 接收数据数组+接收标志位&#x2F;数组索引 清零
void uart2_buf_init(void)
&#123;
	u8 i;
	
	for(i&#x3D;0;i&lt;UART2_RACE_MUN;i++)
	&#123;
		usart2_race_buf[i] &#x3D; 0;
	&#125;
	
	usart2_race_over_bit &#x3D; 0;
	usart2_race_count &#x3D; 0;
&#125;
&#x2F;&#x2F;拷贝串口2的数据到命令数组
void uart2_copy_data(void)
&#123;
	u8 i;
	
	for(i&#x3D;0;i&lt;usart2_race_count;i++)
	&#123;
		uart2_cmd_buf[i] &#x3D; usart2_race_buf[i+3];
	&#125;
	
	uart2_cmd_count &#x3D; usart2_race_count;	&#x2F;&#x2F;命令数组的索引等于接收数组的索引
	
	uart2_buf_init();	&#x2F;&#x2F;接收数组初始化
&#125;
&#x2F;&#x2F;处理小车发来的命令
void uart2_race_explan(void)
&#123;
	&#x2F;&#x2F;后期补充
	if(usart2_race_buf[0]&#x3D;&#x3D;0x01)	&#x2F;&#x2F;判断数组第一个元素是不是自己的ID 1:转盘
	&#123;
		if(usart2_race_buf[1]&#x3D;&#x3D;0xff)	&#x2F;&#x2F;判断数组第二个元素是不是 0xff;这个在小车的代码里有写 0xff表示已完成任务
		&#123;
			car_busy_bit &#x3D; 0;&#x2F;&#x2F;小车忙标志清除
		&#125;
	&#125;
&#125;
&#x2F;*
轮盘ID:01
托盘编号 	1234
集中站标号	1234
*&#x2F;
&#x2F;&#x2F;发送命令给小车(当托盘上有物品时才会通知小车)
void send_to_car_cmd(u8 tuopan,u8 jizhongzhan)
&#123;
	u8 cmd_buf[5];
	
	cmd_buf[0] &#x3D; 2;&#x2F;&#x2F;发送小车的ID
	cmd_buf[1] &#x3D; 0x01;	&#x2F;&#x2F;第二个字节是需要小车干嘛(暂时定义了:0x01---轮盘-&gt;集中站;后期可以添加:0x02---轮盘-&gt;垃圾桶等等)
	cmd_buf[2] &#x3D; tuopan;	&#x2F;&#x2F;几号托盘
	cmd_buf[3] &#x3D; jizhongzhan;	&#x2F;&#x2F;到哪个集中站
	
	Uart2_send_data(cmd_buf,4);&#x2F;&#x2F;发送函数
	
	bell_fun(1);	&#x2F;&#x2F;蜂鸣器响
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************task.c*************************&#x2F;
u32 coder_mun_buf[4] &#x3D; &#123;DIS_MUN1,DIS_MUN2,DIS_MUN3,DIS_MUN4&#125;;	&#x2F;&#x2F;存储走到4个舵机位置脉冲的计数值

&#x2F;&#x2F;检查小车是否在运送还是在起点
void check_car_fun(void)
&#123;
	u8 i;
	
	if(car_busy_bit&#x3D;&#x3D;0)	&#x2F;&#x2F;当小车处于闲的状态
	&#123;
		for(i&#x3D;0;i&lt;TASK_MUN;i++)
		&#123;
			if(task_buf[i][GARBAGE_STATE]&#x3D;&#x3D;ARRIVE_OK)&#x2F;&#x2F;物品在托盘位置上
			&#123;
				send_to_car_cmd(task_buf[i][GARBAGE_TYPE],task_buf[i][GARBAGE_TYPE]);&#x2F;&#x2F;发送命令给小车 第一个参数是托盘  第二个参数是集中站
				car_busy_bit &#x3D; 1;&#x2F;&#x2F;小车忙标志位置1
				task_buf[i][GARBAGE_STATE] &#x3D; SEND_OUT;	&#x2F;&#x2F;已经发送命令给小车
				
				if(task_buf[i][GARBAGE_TYPE]&#x3D;&#x3D;0)
					LCD_ShowString_fun(&quot;6:send_car 0,0&quot;);&#x2F;&#x2F;屏上显示(即第一个托盘-&gt;到第一个集中箱)
				if(task_buf[i][GARBAGE_TYPE]&#x3D;&#x3D;1)
					LCD_ShowString_fun(&quot;6:send_car 1,1&quot;);&#x2F;&#x2F;屏上显示(即第二个托盘-&gt;到第二个集中箱)
				if(task_buf[i][GARBAGE_TYPE]&#x3D;&#x3D;2)
					LCD_ShowString_fun(&quot;6:send_car 2,2&quot;);&#x2F;&#x2F;屏上显示(即第三个托盘-&gt;到第三个集中箱)
				if(task_buf[i][GARBAGE_TYPE]&#x3D;&#x3D;3)
					LCD_ShowString_fun(&quot;6:send_car 3,3&quot;);&#x2F;&#x2F;屏上显示(即第四个托盘-&gt;到第四个集中箱)

				break;
			&#125;
		&#125;
	&#125;
&#125;

&#x2F;&#x2F;检查物品是否已经走到对应的舵机前(如果是则推)
void coder_count_chack_fun(void)
&#123;
	u8 i;
	u8 type;
	
	for(i&#x3D;0;i&lt;TASK_MUN;i++)
	&#123;
		if(task_buf[i][GARBAGE_STATE]&#x3D;&#x3D;WAIT_ENGINE)	&#x2F;&#x2F;判断状态是不是等待舵机推
		&#123;
			type &#x3D; (u8)task_buf[i][GARBAGE_TYPE];	&#x2F;&#x2F;读取物品类型然后对应的舵机推(0就第一个舵机,1是第二个舵机,以此类推)
			if(task_buf[i][TURNTABLE_COUNT] &gt;&#x3D; coder_mun_buf[type])	&#x2F;&#x2F;判断脉冲值是不是&gt;&#x3D;规定脉冲
			&#123;
				&#x2F;&#x2F;printf_fun();
				task_buf[i][GARBAGE_STATE] &#x3D; PUSH;	&#x2F;&#x2F;垃圾状态为推的过程中
				switch(type)
				&#123;
					case 0:
						LCD_ShowString_fun(&quot;4:tui0&quot;);&#x2F;&#x2F;屏上显示
						steering_engine_1_push();&#x2F;&#x2F;舵机1推
						delay_ms(500);
						steering_engine_1_shrink();&#x2F;&#x2F;舵机1收
						break;
					case 1:
						LCD_ShowString_fun(&quot;4:tui1&quot;);&#x2F;&#x2F;屏上显示
						steering_engine_2_push();&#x2F;&#x2F;舵机2推
						delay_ms(500);
						steering_engine_2_shrink();&#x2F;&#x2F;舵机1收
						break;
					case 2:
						LCD_ShowString_fun(&quot;4:tui2&quot;);&#x2F;&#x2F;屏上显示
						steering_engine_3_push();&#x2F;&#x2F;舵机3推
						delay_ms(500);
						steering_engine_3_shrink();&#x2F;&#x2F;舵机1收
						break;
					case 3:
						LCD_ShowString_fun(&quot;4:tui3&quot;);&#x2F;&#x2F;屏上显示
						steering_engine_4_push();&#x2F;&#x2F;舵机4推
						delay_ms(500);
						steering_engine_4_shrink();&#x2F;&#x2F;舵机1收
						break;
				&#125;
			&#125;
		&#125;
	&#125;
&#125;</code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*************************main.c*************************&#x2F;
&#x2F;&#x2F;转盘推杆位置(计数值)
# define DIS_MUN1	29500&#x2F;&#x2F;33046	&#x2F;&#x2F;走到舵机1位置所需脉冲
# define DIS_MUN2	36500&#x2F;&#x2F;39132	&#x2F;&#x2F;走到舵机2位置所需脉冲
# define DIS_MUN3	44000&#x2F;&#x2F;46091	&#x2F;&#x2F;走到舵机3位置所需脉冲
# define DIS_MUN4	50500&#x2F;&#x2F;52348	&#x2F;&#x2F;走到舵机4位置所需脉冲</code></pre>
<h3 id="转盘注意问题">转盘注意问题</h3>
<ul>
<li>STM32F40x_Timer_eval.c 定时器5计算20ms定时步骤</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221112114548.jpg" alt=" "></p>
<ul>
<li>这个数组是代码的主要部分</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/QQ%E6%88%AA%E5%9B%BE20221115073853.jpg" alt=""></p>
<ul>
<li>注意转盘有时候会接收不了MQTT发送回来的数据，初步怀疑可能服务器不稳定，重启然后等待10秒左右再放物品(需要没有收到心跳时才可以，如果上电后一直收到心跳则继续重启直到没收到心跳再滴卡)，如果不行还得顺便把Nano主机那个识别垃圾程序重启一下(反正两个东西多重启即可)</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/num103.webp" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87"><span class="toc-number">2.</span> <span class="toc-text">图片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%B0%8F%E8%BD%A6%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text">智能硬件小车总体流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">需要安装的软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%BD%A6%E4%BF%A1%E6%81%AF-JC-SC"><span class="toc-number">5.</span> <span class="toc-text">小车信息(JC-SC)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E5%8F%A3%E8%A2%8B%E6%9C%BA%E4%BF%A1%E6%81%AF-JC-SPZII"><span class="toc-number">6.</span> <span class="toc-text">STM32口袋机信息(JC-SPZII)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%88%86%E6%8B%A3%E7%BA%BF%E4%BF%A1%E6%81%AF-JC-IGSP"><span class="toc-number">7.</span> <span class="toc-text">智能分拣线信息(JC-IGSP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E7%AB%99%E4%BF%A1%E6%81%AF-JC-ICS"><span class="toc-number">8.</span> <span class="toc-text">集中站信息(JC-ICS)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE%E6%A1%B6%E4%BF%A1%E6%81%AF-JC-SRD"><span class="toc-number">9.</span> <span class="toc-text">智能回收垃圾桶信息(JC-SRD)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%B5%9B%E9%A1%BB%E7%9F%A5-%E6%9D%A5%E8%87%AA%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C"><span class="toc-number">10.</span> <span class="toc-text">比赛须知(来自官方手册)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%B5%9B%E6%AD%A5%E9%AA%A4"><span class="toc-number">11.</span> <span class="toc-text">比赛步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32F407ZG%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.</span> <span class="toc-text">STM32F407ZG介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A3%E8%A2%8B%E6%9C%BA%E9%83%A8%E5%88%86"><span class="toc-number">13.</span> <span class="toc-text">口袋机部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A3%E8%A2%8B%E6%9C%BA%E8%B0%83%E8%AF%95"><span class="toc-number">13.1.</span> <span class="toc-text">口袋机调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A3%E8%A2%8B%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0"><span class="toc-number">13.2.</span> <span class="toc-text">口袋机基础模块学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.1.</span> <span class="toc-text">延时函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%B6%E9%92%9F%E6%BA%90"><span class="toc-number">13.2.2.</span> <span class="toc-text">查看时钟源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E9%98%B5"><span class="toc-number">13.2.3.</span> <span class="toc-text">点阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">13.2.3.1.</span> <span class="toc-text">程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WIFI"><span class="toc-number">13.2.4.</span> <span class="toc-text">WIFI</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-2"><span class="toc-number">13.2.4.1.</span> <span class="toc-text">程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB"><span class="toc-number">13.2.5.</span> <span class="toc-text">语音识别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-3"><span class="toc-number">13.2.5.1.</span> <span class="toc-text">程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%84%E5%83%8F%E5%A4%B4"><span class="toc-number">13.2.6.</span> <span class="toc-text">摄像头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D"><span class="toc-number">13.2.7.</span> <span class="toc-text">超声波测距</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">14.</span> <span class="toc-text">提供的函数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A3%E8%A2%8B%E6%9C%BA%E7%AB%AF%E5%8F%A3"><span class="toc-number">14.1.</span> <span class="toc-text">口袋机端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98"><span class="toc-number">15.</span> <span class="toc-text">其他注意问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text">硬件注意问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98-%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8%E7%9A%84"><span class="toc-number">17.</span> <span class="toc-text">函数问题(第一次用的)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E8%AE%BE%E5%A4%87%E9%80%9A%E4%BF%A1%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89"><span class="toc-number">18.</span> <span class="toc-text">各设备通信全局定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%9B%98%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB"><span class="toc-number">19.</span> <span class="toc-text">沙盘存在的问题汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B0%8F%E8%BD%A6%E9%83%A8%E5%88%86"><span class="toc-number">20.</span> <span class="toc-text">&lt;1&gt;小车部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81"><span class="toc-number">20.1.</span> <span class="toc-text">小车代码详解(主要代码)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TIM5-%E8%BD%A6%E8%BD%AE%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">20.1.1.</span> <span class="toc-text">TIM5&#x2F;车轮编码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E6%9D%A1%E4%BC%A0%E6%84%9F%E5%99%A8-%E8%B5%B0-%E5%A4%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">20.1.2.</span> <span class="toc-text">磁条传感器&#x2F;走+夹过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E6%A2%B0%E8%87%82-%E8%88%B5%E6%9C%BA"><span class="toc-number">20.1.3.</span> <span class="toc-text">机械臂&#x2F;舵机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">20.1.4.</span> <span class="toc-text">蜂鸣器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E5%85%89%E6%B5%8B%E8%B7%9D"><span class="toc-number">20.1.5.</span> <span class="toc-text">激光测距</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A32%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1"><span class="toc-number">20.1.6.</span> <span class="toc-text">串口2无线通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95"><span class="toc-number">20.2.</span> <span class="toc-text">代码修改&#x2F;添加记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-15"><span class="toc-number">20.2.1.</span> <span class="toc-text">11&#x2F;15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-16"><span class="toc-number">20.2.2.</span> <span class="toc-text">11&#x2F;16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-17"><span class="toc-number">20.2.3.</span> <span class="toc-text">11&#x2F;17</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-number">20.2.4.</span> <span class="toc-text">串口测试函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9B%86%E4%B8%AD%E7%AB%99"><span class="toc-number">21.</span> <span class="toc-text">&lt;2&gt;集中站</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95-2"><span class="toc-number">21.1.</span> <span class="toc-text">代码修改&#x2F;添加记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E7%AB%99%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-%E4%B8%BB%E8%A6%81%E9%83%A8%E5%88%86"><span class="toc-number">21.2.</span> <span class="toc-text">集中站代码详解(主要部分)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%88%B5%E6%9C%BA"><span class="toc-number">21.3.</span> <span class="toc-text">舵机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A32%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1-2"><span class="toc-number">21.4.</span> <span class="toc-text">串口2无线通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%AF%E6%9D%A1"><span class="toc-number">21.5.</span> <span class="toc-text">灯条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E9%98%B5-2"><span class="toc-number">21.6.</span> <span class="toc-text">点阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A32%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1-3"><span class="toc-number">21.7.</span> <span class="toc-text">串口2无线通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BD%AC%E7%9B%98"><span class="toc-number">22.</span> <span class="toc-text">&lt;3&gt;转盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%BD%AC%E7%9B%98%E6%AD%A5%E9%AA%A4"><span class="toc-number">22.1.</span> <span class="toc-text">启动转盘步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95-3"><span class="toc-number">22.2.</span> <span class="toc-text">代码修改&#x2F;添加记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-12"><span class="toc-number">22.2.1.</span> <span class="toc-text">11&#x2F;12</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-15-2"><span class="toc-number">22.2.2.</span> <span class="toc-text">11&#x2F;15</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E7%9B%98%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-%E4%B8%BB%E8%A6%81%E9%83%A8%E5%88%86"><span class="toc-number">22.3.</span> <span class="toc-text">轮盘代码详解(主要部分)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E5%8F%A3-TCP-MQTT%E9%83%A8%E5%88%86"><span class="toc-number">22.3.1.</span> <span class="toc-text">网口&#x2F;TCP&#x2F;MQTT部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%9B%98%E7%94%B5%E6%9C%BA"><span class="toc-number">22.3.2.</span> <span class="toc-text">转盘电机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%88%B5%E6%9C%BA-2"><span class="toc-number">22.3.3.</span> <span class="toc-text">舵机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8-2"><span class="toc-number">22.3.4.</span> <span class="toc-text">蜂鸣器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%94%B5%E7%AE%A1"><span class="toc-number">22.3.5.</span> <span class="toc-text">光电管</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RFID"><span class="toc-number">22.3.6.</span> <span class="toc-text">RFID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A32%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1-4"><span class="toc-number">22.4.</span> <span class="toc-text">串口2无线通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%9B%98%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98"><span class="toc-number">22.5.</span> <span class="toc-text">转盘注意问题</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Luckys-Yang</div><div class="footer_custom_text"><div class="github-badge"><a href="http://beian.miit.gov.cn/" target="_blank" title="粤ICP备 2022026282号-1" ), pointer;"><span class="badge-subject">粤ICP备</span><span class="badge-value bg-green">2022026282号-1</span></a></div><div class="github-badge"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44070502000559" title="44070502000559号"><span class="badge-subject"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bed.attainment.cn/img/40.png" style="float:left;" />粤公网安备</span><span class="badge-value bg-green">44070502000559号</span></a></div><div><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Frame-Hexo-blue.svg" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Theme-Butterfly-6513df.svg" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/Hosted-Vercel-brightgreen.svg" title="本站采用多线部署，次线路托管于Vercel" alt="HEXO"></a></div></div><div id="running-time" style="color: #5c5c5c;"><script>setInterval(()=>{let create_time=Math.round(new Date('3/10/2022 08:00:00').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已苟活了 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><meting-js id="8183137343" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-paw"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="https://yang5201314.cn/"><i class="fa fa-home"></i><span>主页</span></a><a class="rightMenu-item" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a><a class="rightMenu-item" href="/archives/"><i class="fa-solid fa-folder-open"></i><span>文章归档</span></a><a class="rightMenu-item" href="https://www.foreverblog.cn/go.html" target="_blank"><i class="fa fa-certificate"></i><span>虫洞</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script defer src="/js/tw_cn.js"></script><script defer src="https://cdn.staticfile.org/fancyapps-ui/4.0.27/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script defer src="https://jsd.onmicrosoft.cn/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script defer src="https://jsd.onmicrosoft.cn/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia.js"></script><div class="js-pjax"></div><script src="https://jsd.onmicrosoft.cn/npm/prismjs/prism.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async type="text/javascript" src="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/js/iziToast.min.js"></script><script>
    document.body.oncopy = function () {
        iziToast.info({
            timeout: 4000, // 关闭弹窗的时间
          // icon: 'Fontawesome', // 图标类别
            closeOnEscape: 'true', // 允许使用Esc键关闭弹窗
            transitionIn: 'bounceInLeft', // 弹窗打开动画
            transitionOut: 'fadeOutRight', // 弹窗关闭动画
            displayMode: 'replace', // 替换已经打开的弹窗
            layout: '2', // Medium模式
            position: 'topRight', // 弹窗位置
            //icon: 'fad fa-copy', // 图标类名
            iconUrl:'https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/1122star.svg',
            backgroundColor: 'rgb(179, 182, 180)', // 弹窗背景色
            title: '复制成功', // 通知标题
            message: '键盘敲烂 月薪过万' // 通知消息内容
        });
    }
</script>
<script defer type="text/javascript" src="/js/rightmenu.js"></script><script  type="text/javascript" src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script defer type="text/javascript" src="/js/IPdw.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer data-pjax src="/js/newYear.js"></script><script defer src="/js/my_aplayer.js"></script><script defer src="/js/meting.js"></script><script id="click-heart" src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '250ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>