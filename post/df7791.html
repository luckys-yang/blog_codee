<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>STM32入门(11-20) | Luckys-Yangの小栈</title><meta name="author" content="Luckys-Yang"><meta name="copyright" content="Luckys-Yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="USART 驱动程序 平时除了使用它进行程序下载还可以用来与电脑端进行串口通信  发送程序 本节用到的固件库函数   RCC_APB2PeriphClockCmd（手册 15.2.22） USART_GetITStatus（手册 21.2.24） USART_ReceiveData（手册 21.2.13） USART_GetFlagStatus（手册 21.2.22） RCC_APB1Periph">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32入门(11-20)">
<meta property="og:url" content="https://mdcm.yang5201314.cn/post/df7791.html">
<meta property="og:site_name" content="Luckys-Yangの小栈">
<meta property="og:description" content="USART 驱动程序 平时除了使用它进行程序下载还可以用来与电脑端进行串口通信  发送程序 本节用到的固件库函数   RCC_APB2PeriphClockCmd（手册 15.2.22） USART_GetITStatus（手册 21.2.24） USART_ReceiveData（手册 21.2.13） USART_GetFlagStatus（手册 21.2.22） RCC_APB1Periph">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mdcm.yang5201314.cn/img/num51.webp">
<meta property="article:published_time" content="2022-04-10T13:10:00.000Z">
<meta property="article:modified_time" content="2022-10-15T13:37:45.000Z">
<meta property="article:author" content="Luckys-Yang">
<meta property="article:tag" content="I2C">
<meta property="article:tag" content="步进电机">
<meta property="article:tag" content="数码管">
<meta property="article:tag" content="入门100步">
<meta property="article:tag" content="STM32F1">
<meta property="article:tag" content="USART">
<meta property="article:tag" content="RTC">
<meta property="article:tag" content="触摸按键">
<meta property="article:tag" content="旋转编码器">
<meta property="article:tag" content="OLED">
<meta property="article:tag" content="继电器">
<meta property="article:tag" content="RS232">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mdcm.yang5201314.cn/img/num51.webp"><link rel="shortcut icon" href="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp"><link rel="canonical" href="https://mdcm.yang5201314.cn/post/df7791.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"MSZRRKNRKT","apiKey":"71e2a5ac35435ee76602cd55d727e5ff","indexName":"aaa","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32入门(11-20)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-15 21:37:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/rightmenu.css" media="all" onload="this.media='all'"><link rel="preconnect" href="https://s1.hdslb.com/" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/regular.css" media="all" onload="this.media='all'" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css" media="all" onload="this.media='all'" /><link rel="shortcut icon" href="#"><link href="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/css/all.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/my.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css" ><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/css/iziToast.min.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/aplayer.css" media="all" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><style>css-doodle {--color: @p(#51eaea, #fffde1, #ff9d76, #FB3569);--rule: (:doodle {@grid: 30x1 / 18vmin;--deg: @p(-180deg, 180deg);}:container {perspective: 30vmin;}:after, :before {content: '';background: var(--color); @place-cell: @r(100%) @r(100%); @size: @r(6px); @shape: heart;} @place-cell: center; @size: 100%;box-shadow: @m2(0 0 50px var(--color));background: @m100(radial-gradient(var(--color) 50%, transparent 0)@r(-20%, 120%) @r(-20%, 100%) / 1px 1px no-repeat); will-change: transform, opacity; animation: scale-up 12s linear infinite; animation-delay: calc(-12s / @I * @i); @keyframes scale-up { 0%, 95.01%, 100% {transform: translateZ(0) rotate(0);opacity: 0;}10% {opacity: 1;}95% {transform: translateZ(35vmin) rotateZ(@var(--deg));}})}</style><css-doodle use="var(--rule)"></css-doodle><script async="async" src="https://cdn.bootcdn.net/ajax/libs/css-doodle/0.32.2/css-doodle.min.js"></script></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/93801118587.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">136</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-list-alt"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/bookmarking/"><i class="fa-fw fas fa-star"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-pen"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info-circle"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav class="fixed" id="nav"><span id="blog-info"><a href="/" title="Luckys-Yangの小栈"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/light.png"/></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-list-alt"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/bookmarking/"><i class="fa-fw fas fa-star"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-pen"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-info-circle"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">STM32入门(11-20)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-10T13:10:00.000Z" title="发表于 2022-04-10 21:10:00">2022-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-15T13:37:45.000Z" title="更新于 2022-10-15 21:37:45">2022-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/32%E7%B3%BB%E5%88%97/">32系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">33.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>153分钟</span></span></div></div></div><article class="post-content" id="article-container"><h2 id="USART-驱动程序">USART 驱动程序</h2>
<p>平时除了使用它进行程序下载还可以用来与电脑端进行串口通信</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204141249831.jpg" alt=""></p>
<h3 id="发送程序">发送程序</h3>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>本节用到的固件库函数</p>
</div>
<ul>
<li>RCC_APB2PeriphClockCmd（<font color='orange'>手册 15.2.22</font>）</li>
<li>USART_GetITStatus（<font color='orange'>手册 21.2.24</font>）</li>
<li>USART_ReceiveData（<font color='orange'>手册 21.2.13</font>）</li>
<li>USART_GetFlagStatus（<font color='orange'>手册 21.2.22</font>）</li>
<li>RCC_APB1PeriphClockCmd（<font color='orange'>手册 15.2.23</font>）</li>
<li>NVIC_Init（<font color='orange'>手册 13.2.4</font>）</li>
<li>NVIC_PriorityGroupConfig（<font color='orange'>手册 13.2.3</font>）</li>
<li>USART_Init（<font color='orange'>手册 21.2.2</font>）</li>
<li>USART_Cmd（<font color='orange'>手册 21.2.4</font>）</li>
<li>USART_ITConfig（<font color='orange'>手册 21.2.5</font>）</li>
<li>USART_SendData（<font color='orange'>手册 21.2.12</font>）</li>
</ul>
<div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>注意</p>
</div>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；只需增加 <font color='green'>usart.h，usart.c </font>文件（<font color='cornflowerblue'>Lib 文件</font>记得添加 <font color='green'>stm32f10x_usart.c</font>）</p>
<p>usart.h</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204141854068.jpg" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __USART_H
# define __USART_H
# include &lt;stdarg.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;string.h&gt;
# include &quot;stdio.h&quot;	
# include &quot;sys.h&quot; 


# define USART_n		USART1  &#x2F;&#x2F;定义使用printf函数的串口，其他串口要使用USART_printf专用函数发送

# define USART1_REC_LEN  			200  	&#x2F;&#x2F;定义USART1最大接收字节数
# define USART2_REC_LEN  			200  	&#x2F;&#x2F;定义USART2最大接收字节数
# define USART3_REC_LEN  			200  	&#x2F;&#x2F;定义USART3最大接收字节数

&#x2F;&#x2F;不使用某个串口时要禁止此串口，以减少编译量
# define EN_USART1 			1		&#x2F;&#x2F;使能（1）&#x2F;禁止（0）串口1
# define EN_USART2 			0		&#x2F;&#x2F;使能（1）&#x2F;禁止（0）串口2
# define EN_USART3 			0		&#x2F;&#x2F;使能（1）&#x2F;禁止（0）串口3
	  	
extern u8  USART1_RX_BUF[USART1_REC_LEN]; &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 
extern u8  USART2_RX_BUF[USART2_REC_LEN]; &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.末字节为换行符
extern u8  USART3_RX_BUF[USART3_REC_LEN]; &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.末字节为换行符
 
extern u16 USART1_RX_STA;         		&#x2F;&#x2F;接收状态标记	
extern u16 USART2_RX_STA;         		&#x2F;&#x2F;接收状态标记	
extern u16 USART3_RX_STA;         		&#x2F;&#x2F;接收状态标记	

&#x2F;&#x2F;函数声明
void USART1_Init(u32 bound);&#x2F;&#x2F;串口1初始化并启动
void USART2_Init(u32 bound);&#x2F;&#x2F;串口2初始化并启动
void USART3_Init(u32 bound);&#x2F;&#x2F;串口3初始化并启动
void USART1_printf(char* fmt,...); &#x2F;&#x2F;串口1的专用printf函数
void USART2_printf(char* fmt,...); &#x2F;&#x2F;串口2的专用printf函数
void USART3_printf(char* fmt,...); &#x2F;&#x2F;串口3的专用printf函数

# endif</code></pre>
<p>usart.c</p>
<ul>
<li>本次程序只用到 <font color='orange'>EN_USART1</font>，其他2,3的函数和1都是差不多的，只需改一下端口（注意对应的端口组）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204242043996.jpg" alt=""></p>
<ul>
<li>从<font color='orange'> if 起 到 endif </font>中 保证 “<font color='cornflowerblue'>不使用/不输入/不调用 semihosting</font>“</li>
<li>USART_RX_STA：是个接收状态标记，它既指<font color='orange'>接收状态又表明接收到数据的位数</font></li>
<li>USART_RX_STA&amp;0x8000：<font color='orange'>判断是否已经接收到了0x0a</font>，0x0a 是LF(line feed)换行的意思,光标到达下一行，也是<font color='orange'>判断数据接收结束的标志。</font></li>
<li>中断中是以<font color='orange'>是否接收到0x0d 0x0a这两个数据，判断数据是否发送结束的</font></li>
<li>0x0d和0x0a 代表：回车+换行</li>
<li>如果设置了接收中断，当检测到RXNE 标志位时会执行中断服务函数。读取接收数据寄存器（RDR）中的数据可以<font color='orange'>自动清除RXNE 标志位</font>。RXNE 标志位在下一字符接收前也可以手动清除，避免溢出错误。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204242002793.jpg" alt=""></p>
<p>配置步骤：（<font color='orange'>可以查看 ARM嵌入式编程与实战应用手册 5.3.1</font>）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204241333859.jpg" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;sys.h&quot;
# include &quot;usart.h&quot;

&#x2F;&#x2F;使UASRT串口可用printf函数发送
&#x2F;&#x2F;在usart.h文件里可更换使用printf函数的串口号
# if 1
# pragma import(__use_no_semihosting)
&#x2F;&#x2F;标准库需要的支持函数
struct __FILE
&#123;
    int handle;
&#125;;
FILE __stdout;
&#x2F;&#x2F;定义_sys_exit()以避免使用半主机模式
_sys_exit(int x)
&#123;
    x &#x3D; x;
&#125;
&#x2F;&#x2F;重定义fputc函数
int fputc(int ch, FILE *f)
&#123;
    while((USART_n-&gt;SR &amp; 0X40) &#x3D;&#x3D; 0); &#x2F;&#x2F;循环发送,直到发送完毕
    USART_n-&gt;DR &#x3D; (u8) ch;
    return ch;
&#125;
# endif


&#x2F;*
USART1串口相关程序
*&#x2F;

# if EN_USART1   &#x2F;&#x2F;USART1使用与屏蔽选择
u8 USART1_RX_BUF[USART1_REC_LEN];     &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.
&#x2F;&#x2F;接收状态
&#x2F;&#x2F;bit15，	接收完成标志
&#x2F;&#x2F;bit14，	接收到0x0d
&#x2F;&#x2F;bit13~0，	接收到的有效字节数目
u16 USART1_RX_STA &#x3D; 0;     &#x2F;&#x2F;接收状态标记

&#x2F;*
USART1专用的printf函数
当同时开启2个以上串口时，printf函数只能用于其中之一，其他串口要自创独立的printf函数
调用方法：USART1_printf(&quot;123&quot;); &#x2F;&#x2F;向USART2发送字符123
*&#x2F;
void USART1_printf (char *fmt, ...)
&#123;
    char buffer[USART1_REC_LEN + 1]; &#x2F;&#x2F; 数据长度
    u8 i &#x3D; 0;
    va_list arg_ptr;
    va_start(arg_ptr, fmt);
    vsnprintf(buffer, USART1_REC_LEN + 1, fmt, arg_ptr);
    while ((i &lt; USART1_REC_LEN) &amp;&amp; (i &lt; strlen(buffer)))
    &#123;
        USART_SendData(USART1, (u8) buffer[i++]);
        while (USART_GetFlagStatus(USART1, USART_FLAG_TC) &#x3D;&#x3D; RESET);
    &#125;
    va_end(arg_ptr);
&#125;

void USART1_Init(u32 bound)  &#x2F;&#x2F;串口1初始化并启动
&#123;
    &#x2F;&#x2F;GPIO端口设置
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);	&#x2F;&#x2F;使能USART1，GPIOA时钟
    &#x2F;&#x2F;USART1_TX   PA.9（发送）
    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_9; &#x2F;&#x2F;PA.9
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF_PP;	&#x2F;&#x2F;复用推挽输出
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    &#x2F;&#x2F;USART1_RX	  PA.10（接收）
    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IN_FLOATING;&#x2F;&#x2F;浮空输入
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
    &#x2F;&#x2F;Usart1 NVIC 配置
    NVIC_InitStructure.NVIC_IRQChannel &#x3D; USART1_IRQn;&#x2F;&#x2F;选择 USART1 中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 3 ; &#x2F;&#x2F;抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 3;		&#x2F;&#x2F;子优先级3
    NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;			&#x2F;&#x2F;IRQ通道使能
    NVIC_Init(&amp;NVIC_InitStructure);	&#x2F;&#x2F;根据指定的参数初始化VIC寄存器
    &#x2F;&#x2F;USART 初始化设置
    USART_InitStructure.USART_BaudRate &#x3D; bound;&#x2F;&#x2F;一般设置为9600;
    USART_InitStructure.USART_WordLength &#x3D; USART_WordLength_8b;&#x2F;&#x2F;字长为8位数据格式
    USART_InitStructure.USART_StopBits &#x3D; USART_StopBits_1;&#x2F;&#x2F;一个停止位
    USART_InitStructure.USART_Parity &#x3D; USART_Parity_No;&#x2F;&#x2F;无奇偶校验位
    USART_InitStructure.USART_HardwareFlowControl &#x3D; USART_HardwareFlowControl_None;&#x2F;&#x2F;无硬件数据流控制
    USART_InitStructure.USART_Mode &#x3D; USART_Mode_Rx | USART_Mode_Tx;	&#x2F;&#x2F;收发模式
    USART_Init(USART1, &amp;USART_InitStructure); &#x2F;&#x2F;初始化串口
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);&#x2F;&#x2F;开启ENABLE&#x2F;关闭DISABLE中断
    USART_Cmd(USART1, ENABLE);                    &#x2F;&#x2F;使能串口
&#125;

void USART1_IRQHandler(void)  &#x2F;&#x2F;串口1中断服务程序（固定的函数名不能修改）
&#123;
    u8 Res;&#x2F;&#x2F;中间变量，读取的数据进行保存
    &#x2F;&#x2F;以下是字符串接收到USART1_RX_BUF[]的程序，(USART1_RX_STA&amp;0x3FFF)是数据的长度（不包括回车）
    &#x2F;&#x2F;当(USART1_RX_STA&amp;0xC000)为真时表示数据接收完成，即超级终端里按下回车键。
    &#x2F;&#x2F;在主函数里写判断if(USART1_RX_STA&amp;0xC000)，然后读USART1_RX_BUF[]数组，读到0x0d 0x0a即是结束。
    &#x2F;&#x2F;注意在主函数处理完串口数据后，要将USART1_RX_STA清0

    if(USART_GetITStatus(USART1, USART_IT_RXNE) !&#x3D; RESET)   &#x2F;&#x2F;接收中断(接收到的数据必须是0x0d 0x0a结尾)查看RXNE寄存器是否为空，以此判断是否有数据发送过来
    &#123;
        Res &#x3D; USART_ReceiveData(USART1); &#x2F;&#x2F;(USART1-&gt;DR);	&#x2F;&#x2F;读取接收到的数据
        printf(&quot;%c&quot;, Res); &#x2F;&#x2F;把收到的数据以 a符号变量 发送回电脑
        if((USART1_RX_STA &amp; 0x8000) &#x3D;&#x3D; 0) &#x2F;&#x2F;判断接收是否未完成这里判断接收完的依据就是收到了0x0a
        &#123;
            if(USART1_RX_STA &amp; 0x4000) &#x2F;&#x2F;接收到了0x0d	如果接收到了0x0d，那么再进一步执行是否接收到0x0a的判断
            &#123;
                if(Res !&#x3D; 0x0a)USART1_RX_STA &#x3D; 0; &#x2F;&#x2F;没有接收到0x0a那么说明，数据未正确传输或者接收错误,重新开始判断；但是这里没有将接收到的数据进行清空，也没有退出接收中断，此程序只是从头开始执行接收判断
                else USART1_RX_STA |&#x3D; 0x8000;	&#x2F;&#x2F;接收完成了，收到了0x0a那么标志位USART_RX_STA最高位置1其他位不变，将不再进行数据检测与存储
            &#125;
            else   &#x2F;&#x2F;还没收到0X0D
            &#123;
                if(Res &#x3D;&#x3D; 0x0d)USART1_RX_STA |&#x3D; 0x4000; &#x2F;&#x2F;收到了数据0x0d，标志位USART_RX_STA 次高位置1其他位不变
                else &#x2F;&#x2F;如果没有接收到数据0x0d，执行判断是否存储数组已满，已满则重新开始接收
                &#123;
                    USART1_RX_BUF[USART1_RX_STA &amp; 0X3FFF] &#x3D; Res ; &#x2F;&#x2F;将收到的数据放入数组
                    USART1_RX_STA++;	&#x2F;&#x2F;数组地址加一，向后排
                    if(USART1_RX_STA &gt; (USART1_REC_LEN - 1))USART1_RX_STA &#x3D; 0; &#x2F;&#x2F;接收数据错误,超出数组大小，重新开始接收
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
# endif

&#x2F;*
USART2串口相关程序
*&#x2F;
# if EN_USART2   &#x2F;&#x2F;USART2使用与屏蔽选择
u8 USART2_RX_BUF[USART2_REC_LEN];     &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.
&#x2F;&#x2F;接收状态
&#x2F;&#x2F;bit15，	接收完成标志
&#x2F;&#x2F;bit14，	接收到0x0d
&#x2F;&#x2F;bit13~0，	接收到的有效字节数目
u16 USART2_RX_STA &#x3D; 0;     &#x2F;&#x2F;接收状态标记

&#x2F;*
USART2专用的printf函数
当同时开启2个以上串口时，printf函数只能用于其中之一，其他串口要自创独立的printf函数
调用方法：USART2_printf(&quot;123&quot;); &#x2F;&#x2F;向USART2发送字符123
*&#x2F;
void USART2_printf (char *fmt, ...)
&#123;
    char buffer[USART2_REC_LEN + 1]; &#x2F;&#x2F; 数据长度
    u8 i &#x3D; 0;
    va_list arg_ptr;
    va_start(arg_ptr, fmt);
    vsnprintf(buffer, USART2_REC_LEN + 1, fmt, arg_ptr);
    while ((i &lt; USART2_REC_LEN) &amp;&amp; (i &lt; strlen(buffer)))
    &#123;
        USART_SendData(USART2, (u8) buffer[i++]);
        while (USART_GetFlagStatus(USART2, USART_FLAG_TC) &#x3D;&#x3D; RESET);
    &#125;
    va_end(arg_ptr);
&#125;


void USART2_Init(u32 bound)  &#x2F;&#x2F;串口1初始化并启动
&#123;
    &#x2F;&#x2F;GPIO端口设置
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE); &#x2F;&#x2F;使能UART2所在GPIOA的时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); &#x2F;&#x2F;使能串口的RCC时钟

    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_3; &#x2F;&#x2F;设置USART2的RX接口是PA3
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IN_FLOATING;&#x2F;&#x2F;浮空输入
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_2; &#x2F;&#x2F;设置USART2的TX接口是PA2
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF_PP;	&#x2F;&#x2F;复用推挽输出
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);

    &#x2F;&#x2F;USART2 初始化设置
    USART_InitStructure.USART_BaudRate &#x3D; bound;&#x2F;&#x2F;一般设置为9600;
    USART_InitStructure.USART_WordLength &#x3D; USART_WordLength_8b;&#x2F;&#x2F;字长为8位数据格式
    USART_InitStructure.USART_StopBits &#x3D; USART_StopBits_1;&#x2F;&#x2F;一个停止位
    USART_InitStructure.USART_Parity &#x3D; USART_Parity_No;&#x2F;&#x2F;无奇偶校验位
    USART_InitStructure.USART_HardwareFlowControl &#x3D; USART_HardwareFlowControl_None;&#x2F;&#x2F;无硬件数据流控制
    USART_InitStructure.USART_Mode &#x3D; USART_Mode_Rx | USART_Mode_Tx;	&#x2F;&#x2F;收发模式
    USART_Init(USART2, &amp;USART_InitStructure); &#x2F;&#x2F;初始化串口
    USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);&#x2F;&#x2F;开启ENABLE&#x2F;关闭DISABLE中断
    USART_Cmd(USART2, ENABLE);                    &#x2F;&#x2F;使能串口
    &#x2F;&#x2F;Usart2 NVIC 配置
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    NVIC_InitStructure.NVIC_IRQChannel &#x3D; USART2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority &#x3D; 3 ; &#x2F;&#x2F;抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 3;		&#x2F;&#x2F;优先级3
    NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;			&#x2F;&#x2F;IRQ通道使能
    NVIC_Init(&amp;NVIC_InitStructure);	&#x2F;&#x2F;根据指定的参数初始化VIC寄存器
&#125;

void USART2_IRQHandler(void)  &#x2F;&#x2F;串口2中断服务程序（固定的函数名不能修改）
&#123;
    u8 Res;
    &#x2F;&#x2F;以下是字符串接收到USART2_RX_BUF[]的程序，(USART2_RX_STA&amp;0x3FFF)是数据的长度（不包括回车）
    &#x2F;&#x2F;当(USART2_RX_STA&amp;0xC000)为真时表示数据接收完成，即超级终端里按下回车键。
    &#x2F;&#x2F;在主函数里写判断if(USART2_RX_STA&amp;0xC000)，然后读USART2_RX_BUF[]数组，读到0x0d 0x0a即是结束。
    &#x2F;&#x2F;注意在主函数处理完串口数据后，要将USART2_RX_STA清0
    if(USART_GetITStatus(USART2, USART_IT_RXNE) !&#x3D; RESET)   &#x2F;&#x2F;接收中断(接收到的数据必须是0x0d 0x0a结尾)
    &#123;
        Res &#x3D; USART_ReceiveData(USART2); &#x2F;&#x2F;(USART1-&gt;DR);	&#x2F;&#x2F;读取接收到的数据
        printf(&quot;%c&quot;, Res); &#x2F;&#x2F;把收到的数据以 a符号变量 发送回电脑
        if((USART2_RX_STA &amp; 0x8000) &#x3D;&#x3D; 0) &#x2F;&#x2F;接收未完成
        &#123;
            if(USART2_RX_STA &amp; 0x4000) &#x2F;&#x2F;接收到了0x0d
            &#123;
                if(Res !&#x3D; 0x0a)USART2_RX_STA &#x3D; 0; &#x2F;&#x2F;接收错误,重新开始
                else USART2_RX_STA |&#x3D; 0x8000;	&#x2F;&#x2F;接收完成了
            &#125;
            else   &#x2F;&#x2F;还没收到0X0D
            &#123;
                if(Res &#x3D;&#x3D; 0x0d)USART2_RX_STA |&#x3D; 0x4000;
                else
                &#123;
                    USART2_RX_BUF[USART2_RX_STA &amp; 0X3FFF] &#x3D; Res ; &#x2F;&#x2F;将收到的数据放入数组
                    USART2_RX_STA++;	&#x2F;&#x2F;数据长度计数加1
                    if(USART2_RX_STA &gt; (USART2_REC_LEN - 1))USART2_RX_STA &#x3D; 0; &#x2F;&#x2F;接收数据错误,重新开始接收
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
# endif


# if EN_USART3   &#x2F;&#x2F;如果使能了接收
u8 USART3_RX_BUF[USART3_REC_LEN];     &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.
&#x2F;&#x2F;接收状态
&#x2F;&#x2F;bit15，	接收完成标志
&#x2F;&#x2F;bit14，	接收到0x0d
&#x2F;&#x2F;bit13~0，	接收到的有效字节数目
u16 USART3_RX_STA &#x3D; 0;     &#x2F;&#x2F;接收状态标记

&#x2F;*
USART3专用的printf函数
当同时开启2个以上串口时，printf函数只能用于其中之一，其他串口要自创独立的printf函数
调用方法：USART3_printf(&quot;123&quot;); &#x2F;&#x2F;向USART3发送字符123
*&#x2F;
void USART3_printf (char *fmt, ...)
&#123;
    char buffer[USART3_REC_LEN + 1]; &#x2F;&#x2F; 数据长度
    u8 i &#x3D; 0;
    va_list arg_ptr;
    va_start(arg_ptr, fmt);
    vsnprintf(buffer, USART3_REC_LEN + 1, fmt, arg_ptr);
    while ((i &lt; USART3_REC_LEN) &amp;&amp; (i &lt; strlen(buffer)))
    &#123;
        USART_SendData(USART3, (u8) buffer[i++]);
        while (USART_GetFlagStatus(USART3, USART_FLAG_TC) &#x3D;&#x3D; RESET);
    &#125;
    va_end(arg_ptr);
&#125;

void USART3_Init(u32 BaudRate)  &#x2F;&#x2F;USART3初始化并启动
&#123;
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE); &#x2F;&#x2F;使能UART3所在GPIOB的时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE); &#x2F;&#x2F;使能串口的RCC时钟

    &#x2F;&#x2F;串口使用的GPIO口配置
    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_11;&#x2F;&#x2F;设置USART3的RX接口是PB11
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IN_FLOATING;&#x2F;&#x2F;接口模式 浮空输入
    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_10;&#x2F;&#x2F;设置USART3的TX接口是PB10
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz;&#x2F;&#x2F;输出速度50MHz
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF_PP;&#x2F;&#x2F;接口模式 复用推挽输出
    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

    &#x2F;&#x2F;配置串口
    USART_InitStructure.USART_BaudRate &#x3D; BaudRate;
    USART_InitStructure.USART_WordLength &#x3D; USART_WordLength_8b;&#x2F;&#x2F;字长为8位数据格式
    USART_InitStructure.USART_StopBits &#x3D; USART_StopBits_1;&#x2F;&#x2F;一个停止位
    USART_InitStructure.USART_Parity &#x3D; USART_Parity_No;&#x2F;&#x2F;无奇偶校验位
    USART_InitStructure.USART_HardwareFlowControl &#x3D; USART_HardwareFlowControl_None;&#x2F;&#x2F;无硬件数据流控制
    USART_InitStructure.USART_Mode &#x3D; USART_Mode_Rx | USART_Mode_Tx;	&#x2F;&#x2F;收发模式

    USART_Init(USART3, &amp;USART_InitStructure);&#x2F;&#x2F;配置串口3
    USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);&#x2F;&#x2F;使能串口接收中断
    &#x2F;&#x2F;USART_ITConfig(USART3, USART_IT_TXE, ENABLE);&#x2F;&#x2F;串口发送中断在发送数据时开启
    USART_Cmd(USART3, ENABLE);&#x2F;&#x2F;使能串口3

    &#x2F;&#x2F;串口中断配置
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    NVIC_InitStructure.NVIC_IRQChannel &#x3D; USART3_IRQn;&#x2F;&#x2F;允许USART3中断
    NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0;&#x2F;&#x2F;中断等级
    NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;
    NVIC_Init(&amp;NVIC_InitStructure);
&#125;

&#x2F;&#x2F;串口3中断服务程序（固定的函数名不能修改）
&#x2F;&#x2F;调用方法：if(USART3_RX_STA&amp;0xC000)&#123; 加入数据处理程序 &#125;&#x2F;&#x2F;标志位是0xC000表示收到数据串完成。
void USART3_IRQHandler(void)
&#123;
    u8 Res;
    if(USART_GetITStatus(USART3, USART_IT_RXNE) !&#x3D; RESET)   &#x2F;&#x2F;接收中断
    &#123;
        Res &#x3D; USART_ReceiveData(USART3); &#x2F;&#x2F;读取接收到的数据
        if(Res &#x3D;&#x3D; &#39;S&#39;) &#x2F;&#x2F;判断数据是否是STOP（省略读取S）
        &#123;
            USART3_RX_STA &#x3D; 1; &#x2F;&#x2F;如果是STOP则标志位为1
        &#125;
        else if(Res &#x3D;&#x3D; &#39;K&#39;) &#x2F;&#x2F;判断数据是否是OK（省略读取K）
        &#123;
            USART3_RX_STA &#x3D; 2; &#x2F;&#x2F;如果是OK则标志位为2
        &#125;
    &#125;
&#125;
# endif</code></pre>
<p>main.c</p>
<ul>
<li>
<p>while(USART_GetFlagStatus(USART1, USART_FLAG_TC)==RESET);</p>
<p><font color='cornflowerblue'>表示：</font>防止前一个数据还没结束就结束发送程序，采用一个<font color='orange'> while</font> 循环，如果<font color='orange'>中断标志为0那么表示发送完毕了</font></p>
</li>
<li>
<p>串口只能<font color='orange'>以16进制显示</font>，所以想发送字符需要查表或者把要发送的字符用 <font color='orange'>’  '</font> 括起来也可以</p>
</li>
<li>
<p>也可以用C语言的 <font color='orange'>printf </font>函数发送数据（这个需要在设置那打钩）；但是 printf 函数只能<font color='orange'>用在一个串口上</font>，所以如果多个串口发送则需要自己写一个 printf 函数</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	USART串口发送程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;

# include &quot;usart.h&quot;


int main (void)&#123;&#x2F;&#x2F;主程序
	u8 a&#x3D;7,b&#x3D;8;
	&#x2F;&#x2F;初始化程序
	RCC_Configuration(); &#x2F;&#x2F;时钟设置

	USART1_Init(115200); &#x2F;&#x2F;串口初始化（参数是波特率）

	&#x2F;&#x2F;主循环
	while(1)&#123;

		&#x2F;* 发送方法1 *&#x2F;
        &#x2F;&#x2F;参数1：向哪个端口发送数据 参数2：发送16进制数据，必须8位
		USART_SendData(USART1 , 0x55); &#x2F;&#x2F;发送单个数值
		while(USART_GetFlagStatus(USART1, USART_FLAG_TC)&#x3D;&#x3D;RESET); &#x2F;&#x2F;检查发送中断标志位

		&#x2F;* 发送方法2 *&#x2F;
&#x2F;&#x2F;		printf(&quot;STM32F103 &quot;); &#x2F;&#x2F;纯字符串发送数据到串口

&#x2F;&#x2F;		printf(&quot;STM32 %d %d &quot;,a,b); &#x2F;&#x2F;纯字符串和变量发送数据到串口,a符号变量
		 
		&#x2F;* 发送方法3 *&#x2F;
&#x2F;&#x2F;		USART1_printf(&quot;STM32 %d %d &quot;,a,b);

        delay_ms(1000); &#x2F;&#x2F;延时，如果不延时串口助手上发送会很快！
	&#125;
&#125;</code></pre>
<p><font color='red'>注：</font>如果编译错误，则需要设置那打勾！！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204141947173.png" alt=""></p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204242113703.jpg" alt=""></p>
<h3 id="接收程序">接收程序</h3>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样； <font color='green'>usart.h，usart.c </font>文件也和 <font color='orange'>11.1</font> 差不多只需改几个函数即可（<font color='cornflowerblue'>Lib 文件</font>记得添加 <font color='green'>stm32f10x_usart.c</font>）</p>
<p>usart.h 需要改的地方：</p>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">&#x2F;&#x2F;把这个函数所有内容
void USART1_IRQHandler(void)&#x2F;&#x2F;串口1中断服务程序（固定的函数名不能修改）	
&#123; 
    ...
&#125;

&#x2F;&#x2F;替换成

+ void USART1_IRQHandler(void)&#x2F;&#x2F;串口1中断服务程序（固定的函数名不能修改）	
+ &#123; 
+ 	u8 a;
+ 	if(USART_GetITStatus(USART1,USART_IT_RXNE)!&#x3D; RESET)&#x2F;&#x2F;接收中断(接收到的数据必须是0x0d 0x0a结尾)
+     &#123;  		
+ 		a &#x3D;USART_ReceiveData(USART1);&#x2F;&#x2F;读取接收到的数据
+ 		printf(&quot;%c&quot;,a); &#x2F;&#x2F;把收到的数据发送回电脑		  
+ 	&#125; 
+ &#125;</code></pre>
<pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">&#x2F;&#x2F;把 USART1_Init 函数里的
USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);&#x2F;&#x2F;开启ENABLE&#x2F;关闭DISABLE中断

&#x2F;&#x2F;替换成

+ USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);&#x2F;&#x2F;开启ENABLE&#x2F;关闭DISABLE中断
</code></pre>
<p>main.c</p>
<p><font color='cornflowerblue'>查询方式</font>：失去实时性，因为这部分串口数据的查询只是循环函数当中的一部分，如果主函数要等待查询的数据，可能时间已经过去了很久，<font color='orange'>于是最好采用中断方式</font>（<font color='red'>中断的方法则需要把 while 里面的代码注释掉，并且把上面的</font><font color='cornflowerblue'>USART1_Init</font> 函数里把中断打开）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204151744834.png" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  					
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;

# include &quot;usart.h&quot;


int main (void)&#123;&#x2F;&#x2F;主程序
	u8 a;&#x2F;&#x2F;串口每次接收的数据都是8位的十六进制数
	&#x2F;&#x2F;初始化程序
	RCC_Configuration(); &#x2F;&#x2F;时钟设置

	USART1_Init(115200); &#x2F;&#x2F;串口初始化（参数是波特率）

	&#x2F;&#x2F;主循环
	while(1)&#123;

		&#x2F;&#x2F;查询方式接收
		if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE) !&#x3D; RESET)&#123;  &#x2F;&#x2F;查询串口待处理标志位，标志位等于1代表有数据
			a &#x3D;USART_ReceiveData(USART1);&#x2F;&#x2F;读取接收到的数据
			printf(&quot;%c&quot;,a); &#x2F;&#x2F;把收到的数据发送回电脑		  
		&#125;
		 

&#x2F;&#x2F;      delay_ms(1000); &#x2F;&#x2F;延时
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204242113433.jpg" style="zoom:50%;" />
<h3 id="USART-控制程序">USART 控制程序</h3>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>led.c，led.h，key.c，key.h</font> 和 <font color='orange'>8 </font>相同，<font color='green'>buzzer.c，buzzer.h</font> 和 <font color='orange'>10.1</font> 相同；<font color='green'>usart.c，usart.h</font>和 <font color='orange'>11.2 </font>相同（用的是查询模式注意关闭中断）</p>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	USART串口控制程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  							
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;led.h&quot;
# include &quot;key.h&quot;
# include &quot;buzzer.h&quot;
# include &quot;usart.h&quot;


int main (void)&#123;&#x2F;&#x2F;主程序
	u8 a;
	&#x2F;&#x2F;初始化程序
	RCC_Configuration(); &#x2F;&#x2F;时钟设置
	LED_Init();&#x2F;&#x2F;LED初始化
	KEY_Init();&#x2F;&#x2F;按键初始化
	BUZZER_Init();&#x2F;&#x2F;蜂鸣器初始化
	USART1_Init(115200); &#x2F;&#x2F;串口初始化（参数是波特率）

	&#x2F;&#x2F;主循环
	while(1)&#123;

		&#x2F;&#x2F;查询方式接收
		if(USART_GetFlagStatus(USART1,USART_FLAG_RXNE) !&#x3D; RESET)&#123;  &#x2F;&#x2F;查询串口待处理标志位
			a &#x3D;USART_ReceiveData(USART1);&#x2F;&#x2F;读取接收到的数据
			switch (a)&#123;
				case &#39;0&#39;:
					GPIO_WriteBit(LEDPORT,LED1,(BitAction)(0)); &#x2F;&#x2F;LED控制
					printf(&quot;%c:LED1 OFF &quot;,a); &#x2F;&#x2F;
					break;
				case &#39;1&#39;:
					GPIO_WriteBit(LEDPORT,LED1,(BitAction)(1)); &#x2F;&#x2F;LED控制
					printf(&quot;%c:LED1 ON &quot;,a); &#x2F;&#x2F;
					break;
				case &#39;2&#39;:
					BUZZER_BEEP1(); &#x2F;&#x2F;蜂鸣一声
					printf(&quot;%c:BUZZER &quot;,a); &#x2F;&#x2F;把收到的数据发送回电脑
					break;
				default:
					break;
			&#125;		  
		&#125;

		&#x2F;&#x2F;按键控制
		if(!GPIO_ReadInputDataBit(KEYPORT,KEY1))&#123; &#x2F;&#x2F;读按键接口的电平
			delay_ms(20); &#x2F;&#x2F;延时20ms去抖动
			if(!GPIO_ReadInputDataBit(KEYPORT,KEY1))&#123; &#x2F;&#x2F;读按键接口的电平
				while(!GPIO_ReadInputDataBit(KEYPORT,KEY1)); &#x2F;&#x2F;等待按键松开 
				printf(&quot;KEY1 &quot;); &#x2F;&#x2F;
			&#125;
		&#125;		 
		if(!GPIO_ReadInputDataBit(KEYPORT,KEY2))&#123; &#x2F;&#x2F;读按键接口的电平
			delay_ms(20); &#x2F;&#x2F;延时20ms去抖动
			if(!GPIO_ReadInputDataBit(KEYPORT,KEY2))&#123; &#x2F;&#x2F;读按键接口的电平
				while(!GPIO_ReadInputDataBit(KEYPORT,KEY2)); &#x2F;&#x2F;等待按键松开 
				printf(&quot;KEY2 &quot;); &#x2F;&#x2F;
			&#125;
		&#125;		 

&#x2F;&#x2F;      delay_ms(1000); &#x2F;&#x2F;延时
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=553437407&bvid=BV1Fi4y1m7ES&cid=584172205&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
<h3 id="超级终端串口控制程序">超级终端串口控制程序</h3>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>led.c，led.h，key.c，key.h</font> 和 <font color='orange'>8 </font>相同，<font color='green'>buzzer.c，buzzer.h</font> 和 <font color='orange'>10.1</font> 相同；<font color='green'>usart.c，usart.h</font> 和 <font color='orange'>11.2 </font>相同（用的是查询模式注意打开中断）</p>
<p>main.c</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204152201068.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204152200536.jpg" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	超级终端串口控制程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;led.h&quot;
# include &quot;key.h&quot;
# include &quot;buzzer.h&quot;
# include &quot;usart.h&quot;


int main (void)&#123;&#x2F;&#x2F;主程序
	RCC_Configuration();
	LED_Init();&#x2F;&#x2F;LED初始化
	KEY_Init();&#x2F;&#x2F;按键初始化
	BUZZER_Init();&#x2F;&#x2F;蜂鸣器初始化
	USART1_Init(115200); &#x2F;&#x2F;串口初始化，参数中写波特率
	USART1_RX_STA&#x3D;0xC000; &#x2F;&#x2F;初始值设为有回车的状态，即显示一次欢迎词
	while(1)&#123;
		if(USART1_RX_STA&amp;0xC000)&#123; &#x2F;&#x2F;如果标志位是0xC000表示收到数据串完成，可以处理。
			if((USART1_RX_STA&amp;0x3FFF)&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;单独的回车键再显示一次欢迎词
				printf(&quot;\033[1;47;33m\r\n&quot;); &#x2F;&#x2F;设置颜色（参考超级终端使用）
				printf(&quot; 1y--开LED1灯      1n--关LED1灯 \r\n&quot;);
				printf(&quot; 2y--开LED2灯      2n--关LED2灯 \r\n&quot;);
				printf(&quot; 请输入控制指令，按回车键执行！ \033[0m\r\n&quot;);
			&#125;else if((USART1_RX_STA&amp;0x3FFF)&#x3D;&#x3D;2 &amp;&amp; USART1_RX_BUF[0]&#x3D;&#x3D;&#39;1&#39; &amp;&amp; USART1_RX_BUF[1]&#x3D;&#x3D;&#39;y&#39;)&#123; &#x2F;&#x2F;判断数据是不是2个，第一个数据是不是“1”，第二个是不是“y”
				GPIO_SetBits(LEDPORT,LED1); &#x2F;&#x2F;LED灯都为高电平（1）
				printf(&quot;1y -- LED1灯已经点亮！\r\n&quot;);
			&#125;else if((USART1_RX_STA&amp;0x3FFF)&#x3D;&#x3D;2 &amp;&amp; USART1_RX_BUF[0]&#x3D;&#x3D;&#39;1&#39; &amp;&amp; USART1_RX_BUF[1]&#x3D;&#x3D;&#39;n&#39;)&#123;
				GPIO_ResetBits(LEDPORT,LED1); &#x2F;&#x2F;&#x2F;&#x2F;LED灯都为低电平（0）
				printf(&quot;1n -- LED1灯已经熄灭！\r\n&quot;);
			&#125;else if((USART1_RX_STA&amp;0x3FFF)&#x3D;&#x3D;2 &amp;&amp; USART1_RX_BUF[0]&#x3D;&#x3D;&#39;2&#39; &amp;&amp; USART1_RX_BUF[1]&#x3D;&#x3D;&#39;y&#39;)&#123;
				GPIO_SetBits(LEDPORT,LED2); &#x2F;&#x2F;LED灯都为高电平（1）
				printf(&quot;2y -- LED2灯已经点亮！\r\n&quot;);
			&#125;else if((USART1_RX_STA&amp;0x3FFF)&#x3D;&#x3D;2 &amp;&amp; USART1_RX_BUF[0]&#x3D;&#x3D;&#39;2&#39; &amp;&amp; USART1_RX_BUF[1]&#x3D;&#x3D;&#39;n&#39;)&#123;
				GPIO_ResetBits(LEDPORT,LED2); &#x2F;&#x2F;&#x2F;&#x2F;LED灯都为低电平（0）
				printf(&quot;2n -- LED2灯已经熄灭！\r\n&quot;);
			&#125;else&#123; &#x2F;&#x2F;如果以上都不是，即是错误的指令。
				printf(&quot;指令错误！\r\n&quot;); 
			&#125;
			USART1_RX_STA&#x3D;0; &#x2F;&#x2F;将串口数据标志位清0
		&#125;
	&#125;
&#125;</code></pre>
<p>就算是按回车一次将数据发送，一串的数据也是按照排队一个个发过去的！！！</p>
<p>那么每次接收到一个比如0x55这样的以后，他就会中断处理一次！！！</p>
<p>要是收到0x55 0x55 0x55 0x55，他就会中断处理四次！！！每一次中断的函数都会执行！！！</p>
<p>也就是说！！！一个状态变量来判断我这个接收的一串的数据有没有结束！！！</p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<p>需要把超级终端编码改成【<font color='cornflowerblue'>GB2312</font>】，不然中文显示不了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204251316031.jpg" alt=""></p>
<h2 id="RTC原理与驱动程序">RTC原理与驱动程序</h2>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>本节用到的固件库函数</p>
</div>
<ul>
<li>
<p>PWR_BackupAccessCmd（<font color='orange'>手册 14.2.2</font>）</p>
</li>
<li>
<p>BKP_DeInit（<font color='orange'>手册 5.2.1</font>）</p>
</li>
<li>
<p>RCC_LSEConfig（<font color='orange'>手册 15.2.16</font>）</p>
</li>
<li>
<p>RCC_GetFlagStatus（<font color='orange'>手册 15.2.29</font>）</p>
</li>
<li>
<p>RCC_RTCCLKConfig（<font color='orange'>手册 15.2.18</font>）</p>
</li>
<li>
<p>RCC_RTCCLKCmd（<font color='orange'>手册 15.2.19</font>）</p>
</li>
<li>
<p>RTC_WaitForSynchro（<font color='orange'>手册 16.2.10</font>）</p>
</li>
<li>
<p>RTC_WaitForLastTask（<font color='orange'>手册 16.2.9</font>）</p>
</li>
<li>
<p>RTC_SetPrescaler（<font color='orange'>手册 16.2.6</font>）</p>
</li>
<li>
<p>RTC_ITConfig（<font color='orange'>手册 16.2.1</font>）</p>
</li>
<li>
<p>BKP_ReadBackupRegister（<font color='orange'>手册 5.2.8</font>）</p>
</li>
<li>
<p>BKP_WriteBackupRegister（<font color='orange'>手册 5.2.7</font>）</p>
</li>
<li>
<p>RCC_ClearFlag（<font color='orange'>手册 15.2.30</font>）</p>
</li>
<li>
<p>BKP_TamperPinCmd（<font color='orange'>手册 5.2.3</font>）</p>
</li>
<li>
<p>BKP_RTCOutputConfig（<font color='orange'>手册 5.2.5</font>）</p>
</li>
<li>
<p>RTC_ClearITPendingBit（<font color='orange'>手册 16.2.14</font>）</p>
</li>
<li>
<p>RTC_SetCounter（<font color='orange'>手册 16.2.5</font>）</p>
</li>
<li>
<p>RTC_GetCounter（<font color='orange'>手册 16.2.4</font>）</p>
</li>
</ul>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>RTC 介绍</p>
</div>
<p>RTC和后备寄存器不会被系统或电源复位源复位；当从待机模式唤醒时，也不会被复位。实时时钟具有一组连续运行的计数器，可以通过适当的软件提供日历时钟功能，还具有闹钟中断和阶段性中断功能；RTC具有一个32位的可编程计数器，使用比较寄存器可以进行长时间的测量。有一个20位的预分频器用于时基时钟，默认情况下时钟为32.768kHz时，<font color='orange'>它将产生一个1秒长的时间基准。</font></p>
<ul>
<li>STM32的RTC只用一个32位计数器来计时,而不是用年月日时分秒的分组寄存器（跟51的不一样）。</li>
<li>通过设置可以让这个计数器<font color='orange'>1秒加1</font>，从0-0XFFFFFFFF大约可计时136年。</li>
<li>时间起点一般设置为<font color='orange'>1970-01-01 00:00:00</font>(因现有函数如此定义)</li>
</ul>
<p>​     <font color='cornflowerblue'>如果要读当前的年月日时分秒，先读出32位RTC计数器值，然后以1970-01-01 00:00:00为起点，加上计数器中的秒数，再换算成年月日时分秒，即可得出当前时间。</font></p>
<p>其他文件不变，只需增加<font color='green'> rtc,c，rtc.h</font>（<font color='cornflowerblue'>Lib 文件</font>记得添加 stm32f10x_rtc.c）</p>
<p>rtc.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __RTC_H
# define __RTC_H	 
# include &quot;sys.h&quot; 


&#x2F;&#x2F;全局变量的声明，在rtc.c文件中定义
&#x2F;&#x2F;以下2条是使用extern语句声明全局变量
&#x2F;&#x2F;注意：这里不能给变量赋值
extern u16 ryear;
extern u8 rmon,rday,rhour,rmin,rsec,rweek;



u8 RTC_Get(void);&#x2F;&#x2F;读出当前时间值	
void RTC_First_Config(void);&#x2F;&#x2F;首次启用RTC的设置（如果备用电池断开过）
void RTC_Config(void);&#x2F;&#x2F;实时时钟初始化（备用电池没断开过）
u8 Is_Leap_Year(u16 year);&#x2F;&#x2F;判断是否是闰年函数                    
u8 RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec);&#x2F;&#x2F;写入当前时间
u8 RTC_Get_Week(u16 year,u8 month,u8 day);&#x2F;&#x2F;按年月日计算星期

# endif</code></pre>
<p>rtc.c</p>
<ul>
<li>配置步骤可以参考 <font color='orange'>ARM嵌入式编程与实战应用手册 8.3.2</font></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;* 
	&#x2F;&#x2F;时间读写与设置说明&#x2F;&#x2F;
1，在mani函数开头放入RTC_Config();就可以使能时钟了。
在RTC_Config();函数中自带判断是不是首次使用RTC
2，使用 RTC_Get();读出时间。读出的数据存放在：
年 ryear （16位）
月 rmon	 （以下都是8位）
日 rday
时 rhour
分 rmin
秒 rsec
周 rweek

3，使用 RTC_Set(4位年,2位月,2位日,2位时,2位分,2位秒); 写入时间。例如：RTC_Get(2017,08,06,21,34,00);

其他函数都是帮助如上3个函数的，不需要调用。 
注意要使用RTC_Get和RTC_Set的返回值，为0时表示读写正确。

*&#x2F;


# include &quot;sys.h&quot;
# include &quot;rtc.h&quot;


&#x2F;&#x2F;以下2条全局变量--用于RTC时间的读取
u16 ryear; &#x2F;&#x2F;4位年
u8 rmon,rday,rhour,rmin,rsec,rweek;&#x2F;&#x2F;2位月日时分秒周



void RTC_First_Config(void)
&#123; 
 &#x2F;&#x2F;&lt;1&gt; 当系统复位后，对后备寄存器和RTC 的访问将被禁止，这是为了防止对后备区域的意外写操作。因此在配置RTC 模块前应先设置寄存器RCC_APB1ENR 的PWREN 和BKPEN位，使能电源和后备接口时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);&#x2F;&#x2F;启用PWR和BKP的时钟（from APB1）
	&#x2F;&#x2F;使能后备区域时钟后还要使能电源的寄存器PWR_CR 的DBP 位来取消后备区域的写保护。
    PWR_BackupAccessCmd(ENABLE);&#x2F;&#x2F;后备域解锁
	
    BKP_DeInit();&#x2F;&#x2F;备份寄存器模块复位
	&#x2F;&#x2F;设置RTC 时钟源为LSE 之前要先等待LSE 时钟启动，保证LSE 时钟正常起振
    RCC_LSEConfig(RCC_LSE_ON);&#x2F;&#x2F;外部32.768KHZ晶振开启   
	
    while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) &#x3D;&#x3D; RESET);&#x2F;&#x2F;等待稳定,设置后需要等待启动
    
   &#x2F;&#x2F;&lt;2&gt; LSE 时钟起振成功后才可以设置RTC 时钟源为LSE 时钟并使能RTC，由于RTC 使用的时钟源与APB1 总线时钟并非同一时钟源，因此两者的时钟信号并不是同步的，需要等待RTC和APB1 时钟同步
    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);&#x2F;&#x2F;RTC时钟源配置成LSE（外部低速晶振32.768KHZ） 
	
    RCC_RTCCLKCmd(ENABLE);&#x2F;&#x2F;RTC开启  
	
    RTC_WaitForSynchro();&#x2F;&#x2F;等待同步,开启后需要等待APB1时钟与RTC时钟同步，才能读写寄存器 
	
    RTC_WaitForLastTask();&#x2F;&#x2F;等待更新结束,读写寄存器前，要确定上一个操作已经结束
	
    RTC_SetPrescaler(32767);&#x2F;&#x2F;设置RTC分频器，使RTC时钟为1Hz,RTC period &#x3D; RTCCLK&#x2F;RTC_PR &#x3D; (32.768 KHz)&#x2F;(32767+1)
	
    RTC_WaitForLastTask();&#x2F;&#x2F;等待寄存器写入完成
	
    &#x2F;&#x2F;当不使用RTC秒中断，可以屏蔽下面2条
&#x2F;&#x2F;    RTC_ITConfig(RTC_IT_SEC, ENABLE);&#x2F;&#x2F;使能秒中断   
&#x2F;&#x2F;    RTC_WaitForLastTask();&#x2F;&#x2F;等待写入完成
&#125;

void RTC_Config(void)
&#123; 
    &#x2F;&#x2F;在BKP的后备寄存器1中，存了一个特殊字符0xA5A5
    &#x2F;&#x2F;第一次上电或后备电源掉电后，该寄存器数据丢失，表明RTC数据丢失，需要重新配置
    if (BKP_ReadBackupRegister(BKP_DR1) !&#x3D; 0xA5A5)
	&#123;       
        RTC_First_Config();&#x2F;&#x2F;重新配置RTC        
        BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);&#x2F;&#x2F;配置完成后，向后备寄存器中写特殊字符0xA5A5（用户自己定义的0xa5a5用来判断是否数据丢失）
    &#125;
	else
	&#123;
		&#x2F;&#x2F;若后备寄存器没有掉电，则无需重新配置RTC
        &#x2F;&#x2F;这里我们可以利用RCC_GetFlagStatus()函数查看本次复位类型
        if (RCC_GetFlagStatus(RCC_FLAG_PORRST) !&#x3D; RESET)
		&#123;
            &#x2F;&#x2F;这是上电复位
        &#125;
        else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) !&#x3D; RESET)
		&#123;
            &#x2F;&#x2F;这是外部RST管脚复位
        &#125;       
        RCC_ClearFlag();&#x2F;&#x2F;清除RCC中复位标志

        &#x2F;&#x2F;虽然RTC模块不需要重新配置，且掉电后依靠后备电池依然运行
        &#x2F;&#x2F;但是每次上电后，还是要使能RTCCLK
        RCC_RTCCLKCmd(ENABLE);&#x2F;&#x2F;使能RTCCLK        
        RTC_WaitForSynchro();&#x2F;&#x2F;等待RTC时钟与APB1时钟同步

        &#x2F;&#x2F;当不使用RTC秒中断，可以屏蔽下面2条
&#x2F;&#x2F;        RTC_ITConfig(RTC_IT_SEC, ENABLE);&#x2F;&#x2F;使能秒中断        
&#x2F;&#x2F;        RTC_WaitForLastTask();&#x2F;&#x2F;等待操作完成
    &#125;
	# ifdef RTCClockOutput_Enable   
	    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
	    PWR_BackupAccessCmd(ENABLE);   
	    BKP_TamperPinCmd(DISABLE);   
	    BKP_RTCOutputConfig(BKP_RTCOutputSource_CalibClock);
	# endif
&#125;

void RTC_IRQHandler(void)&#x2F;&#x2F;如果启动了中断就会执行（当前没开启中断）
&#123; 
	if(RTC_GetITStatus(RTC_IT_SEC) !&#x3D; RESET)
	&#123;

	&#125;
	RTC_ClearITPendingBit(RTC_IT_SEC); 
	RTC_WaitForLastTask();
&#125;

void RTCAlarm_IRQHandler(void)&#123;	&#x2F;&#x2F;闹钟中断处理（启用时必须调高其优先级）
	if(RTC_GetITStatus(RTC_IT_ALR) !&#x3D; RESET)
	&#123;
	
	&#125;
	RTC_ClearITPendingBit(RTC_IT_ALR);
	RTC_WaitForLastTask();
&#125;

&#x2F;&#x2F;判断是否是闰年函数
&#x2F;&#x2F;月份   1  2  3  4  5  6  7  8  9  10 11 12
&#x2F;&#x2F;闰年   31 29 31 30 31 30 31 31 30 31 30 31
&#x2F;&#x2F;非闰年 31 28 31 30 31 30 31 31 30 31 30 31
&#x2F;&#x2F;输入:年份
&#x2F;&#x2F;输出:该年份是不是闰年.1,是.0,不是
u8 Is_Leap_Year(u16 year)
&#123;                    
	if ((year % 4 &#x3D;&#x3D; 0&amp;&amp; year%100!&#x3D;0) || year % 400 &#x3D;&#x3D; 0)&#x2F;&#x2F;能被4整除并且不能被100整除 或者 能被400整除就是闰年
		return 1;
	else
		return 0;
&#125;                           
&#x2F;&#x2F;设置时钟
&#x2F;&#x2F;把输入的时钟转换为秒钟
&#x2F;&#x2F;以1970年1月1日为基准
&#x2F;&#x2F;1970~2099年为合法年份

&#x2F;&#x2F;月份数据表                                                                       
u8 const table_week[12]&#x3D;&#123;0,3,3,6,1,4,6,2,5,0,3,5&#125;; &#x2F;&#x2F;月修正数据表  
const u8 mon_table[12]&#x3D;&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;&#x2F;&#x2F;平年的月份日期表

&#x2F;&#x2F;写入时间
u8 RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)&#x2F;&#x2F;写入当前时间（1970~2099年有效），
&#123; 
	u16 t;
	u32 seccount&#x3D;0;
	if(syear&lt;2000||syear&gt;2099)&#x2F;&#x2F;syear范围1970-2099，此处设置范围为2000-2099
		return 1;       
	for(t&#x3D;1970;t&lt;syear;t++)
	&#123; 
		if(Is_Leap_Year(t))
			seccount+&#x3D;31622400;&#x2F;&#x2F;闰年的秒总数
		else 
			seccount+&#x3D;31536000;&#x2F;&#x2F;平年的秒总数
	&#125;
	smon-&#x3D;1;
	for(t&#x3D;0;t&lt;smon;t++)&#x2F;&#x2F;把前面月份的秒钟数相加
	&#123;         
		seccount+&#x3D;(u32)mon_table[t]*86400;&#x2F;&#x2F;月份秒钟数相加
		if(Is_Leap_Year(syear)&amp;&amp;t&#x3D;&#x3D;1)
			seccount+&#x3D;86400;&#x2F;&#x2F;闰年2月份增加一天的秒钟数        
	&#125;
	seccount+&#x3D;(u32)(sday-1)*86400;&#x2F;&#x2F;把前面日期的秒钟数相加
	seccount+&#x3D;(u32)hour*3600;&#x2F;&#x2F;小时秒钟数
	seccount+&#x3D;(u32)min*60;      &#x2F;&#x2F;分钟秒钟数
	seccount+&#x3D;sec;&#x2F;&#x2F;最后的秒钟加上去
	
	RTC_First_Config(); &#x2F;&#x2F;重新初始化时钟
	BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);&#x2F;&#x2F;配置完成后，向后备寄存器中写特殊字符0xA5A5
	RTC_SetCounter(seccount);&#x2F;&#x2F;把换算好的计数器值写入
	RTC_WaitForLastTask(); &#x2F;&#x2F;等待写入完成
	return 0; &#x2F;&#x2F;返回值:0,成功;其他:错误代码.    
&#125;

&#x2F;&#x2F;读出时间
u8 RTC_Get(void)&#x2F;&#x2F;读出当前时间值 &#x2F;&#x2F;返回值:0,成功;其他:错误代码.
&#123;
	static u16 daycnt&#x3D;0;
	u32 timecount&#x3D;0;
	u32 temp&#x3D;0;
	u16 temp1&#x3D;0;
	timecount&#x3D;RTC_GetCounter();		
	temp&#x3D;timecount&#x2F;86400;   &#x2F;&#x2F;得到天数(秒钟数对应的)
	if(daycnt!&#x3D;temp)&#x2F;&#x2F;超过一天了
	&#123;
		daycnt&#x3D;temp;
		temp1&#x3D;1970;  &#x2F;&#x2F;从1970年开始
		while(temp&gt;&#x3D;365)
		&#123;
		     if(Is_Leap_Year(temp1))&#x2F;&#x2F;是闰年
			 &#123;
			     if(temp&gt;&#x3D;366)
					 temp-&#x3D;366;&#x2F;&#x2F;闰年的秒钟数
			     else 
				&#123;
					temp1++;break;
				&#125; 
		     &#125;
		     else 
				 temp-&#x3D;365;       &#x2F;&#x2F;平年
			 
		     temp1++; 
		&#125;  
		ryear&#x3D;temp1;&#x2F;&#x2F;得到年份
		temp1&#x3D;0;
		while(temp&gt;&#x3D;28)&#x2F;&#x2F;超过了一个月
		&#123;
			if(Is_Leap_Year(ryear)&amp;&amp;temp1&#x3D;&#x3D;1)&#x2F;&#x2F;当年是不是闰年&#x2F;2月份
			&#123;
				if(temp&gt;&#x3D;29)
					temp-&#x3D;29;&#x2F;&#x2F;闰年的秒钟数
				else 
					break;
			&#125;
			else
			&#123;
	            if(temp&gt;&#x3D;mon_table[temp1])
					temp-&#x3D;mon_table[temp1];&#x2F;&#x2F;平年
	            else 
					break;
			&#125;
			
			temp1++; 
		&#125;
		rmon&#x3D;temp1+1;&#x2F;&#x2F;得到月份
		rday&#x3D;temp+1;  &#x2F;&#x2F;得到日期
	&#125;
	temp&#x3D;timecount%86400;     &#x2F;&#x2F;得到秒钟数      
	rhour&#x3D;temp&#x2F;3600;     &#x2F;&#x2F;小时
	rmin&#x3D;(temp%3600)&#x2F;60; &#x2F;&#x2F;分钟     
	rsec&#x3D;(temp%3600)%60; &#x2F;&#x2F;秒钟
	rweek&#x3D;RTC_Get_Week(ryear,rmon,rday);&#x2F;&#x2F;获取星期  
	return 0;
&#125;    

u8 RTC_Get_Week(u16 year,u8 month,u8 day) &#x2F;&#x2F;按年月日计算星期(只允许1901-2099年)&#x2F;&#x2F;已由RTC_Get调用 
&#123;   
	u16 temp2;
	u8 yearH,yearL;
	yearH&#x3D;year&#x2F;100;     
	yearL&#x3D;year%100;
	
	&#x2F;&#x2F; 如果为21世纪,年份数加100 
	if (yearH&gt;19)yearL+&#x3D;100;
	&#x2F;&#x2F; 所过闰年数只算1900年之后的 
	temp2&#x3D;yearL+yearL&#x2F;4;
	temp2&#x3D;temp2%7;
	temp2&#x3D;temp2+day+table_week[month-1];
	if (yearL%4&#x3D;&#x3D;0&amp;&amp;month&lt;3)temp2--;
	return(temp2%7); &#x2F;&#x2F;返回星期值（0~6）
&#125;</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	LED灯显示RTC走时程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。
*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;led.h&quot;
# include &quot;key.h&quot;
# include &quot;buzzer.h&quot;
# include &quot;usart.h&quot;

# include &quot;rtc.h&quot;

int main (void)&#123;&#x2F;&#x2F;主程序
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化

	RTC_Config(); &#x2F;&#x2F;实时时钟初始化

	LED_Init();&#x2F;&#x2F;LED初始化
	KEY_Init();&#x2F;&#x2F;按键初始化
	BUZZER_Init();&#x2F;&#x2F;蜂鸣器初始化
	USART1_Init(115200); &#x2F;&#x2F;串口初始化，参数中写波特率
	USART1_RX_STA&#x3D;0xC000; &#x2F;&#x2F;初始值设为有回车的状态，即显示一次欢迎词
	while(1)&#123;

		if(RTC_Get()&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;读出时间值，同时判断返回值是不是0，非0时读取的值是错误的。	
			GPIO_WriteBit(LEDPORT,LED1,(BitAction)(rsec%2)); &#x2F;&#x2F;LED1接口
			GPIO_WriteBit(LEDPORT,LED2,(BitAction)(rmin%2)); &#x2F;&#x2F;LED2接口
		&#125;
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<p><font color='orange'>当秒数是偶数时 LED1亮，当分钟数是偶数时 LED2亮</font>（可能有误差）</p>
<h3 id="超级终端显示日历程序">超级终端显示日历程序</h3>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>led.c，led.h，key.c，key.h</font> 和 <font color='orange'>8 </font>相同，<font color='green'>buzzer.c，buzzer.h</font> 和 <font color='orange'>10.1</font> 相同；<font color='green'>usart.c，usart.h</font> 和 <font color='orange'>11.1 </font>相同，<font color='green'>rtc.c，rtc.h</font> 和 <font color='orange'>12</font> 相同</p>
<p>main.c</p>
<p>时间如果想要实现<font color='pink'> 00:00:00</font> 则<font color='orange'>需要把一位拆开两位显示</font>，则</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">printf(&quot; 现在实时时间：%d-%d-%d %d:%d%d:%d%d  &quot;,ryear,rmon,rday,rhour,rmin&#x2F;10,rmin%10,rsec&#x2F;10,rsec%10);&#x2F;&#x2F;显示日期时间</code></pre>
<p>或者直接用 <font color='cornflowerblue'>%02d</font> 也可以</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204161737424.jpg" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	超级终端显示日历程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  							
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;led.h&quot;
# include &quot;key.h&quot;
# include &quot;buzzer.h&quot;
# include &quot;usart.h&quot;
# include &quot;rtc.h&quot;

int main (void)&#123;&#x2F;&#x2F;主程序
	u8 bya;
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化
	RTC_Config(); &#x2F;&#x2F;实时时钟初始化
	LED_Init();&#x2F;&#x2F;LED初始化
	KEY_Init();&#x2F;&#x2F;按键初始化
	BUZZER_Init();&#x2F;&#x2F;蜂鸣器初始化
	USART1_Init(115200); &#x2F;&#x2F;串口初始化，参数中写波特率
	USART1_RX_STA&#x3D;0xC000; &#x2F;&#x2F;初始值设为有回车的状态，即显示一次欢迎词
	
	while(1)&#123;

		if(USART1_RX_STA&amp;0xC000)&#x2F;&#x2F;如果标志位是0xC000表示收到数据串完成，可以处理。
		&#123; 
			if((USART1_RX_STA&amp;0x3FFF)&#x3D;&#x3D;0)
			&#123; 
				if(RTC_Get()&#x3D;&#x3D;0)
				&#123; 
					printf(&quot; STM32实时时钟测试程序   \r\n&quot;);
					printf(&quot; 现在实时时间：%d-%d-%d %02d:%02d:%02d  &quot;,ryear,rmon,rday,rhour,rmin,rsec);&#x2F;&#x2F;显示日期时间
					if(rweek&#x3D;&#x3D;0)printf(&quot;星期日   \r\n&quot;);&#x2F;&#x2F;rweek值为0时表示星期日
					if(rweek&#x3D;&#x3D;1)printf(&quot;星期一   \r\n&quot;);
					if(rweek&#x3D;&#x3D;2)printf(&quot;星期二   \r\n&quot;);
					if(rweek&#x3D;&#x3D;3)printf(&quot;星期三   \r\n&quot;);
					if(rweek&#x3D;&#x3D;4)printf(&quot;星期四   \r\n&quot;);
					if(rweek&#x3D;&#x3D;5)printf(&quot;星期五   \r\n&quot;);
					if(rweek&#x3D;&#x3D;6)printf(&quot;星期六   \r\n&quot;);
					printf(&quot; 单按回车键更新时间。输入字母C初始化时钟 \r\n&quot;);
					printf(&quot; 请输入设置时间，格式20220425190000，按回车键确定！ \r\n&quot;);
				&#125;
				else
				&#123;
					printf(&quot;读取失败！\r\n&quot;);
				&#125;
			&#125;
			else if((USART1_RX_STA&amp;0x3FFF)&#x3D;&#x3D;1)
			&#123; 
				if(USART1_RX_BUF[0]&#x3D;&#x3D;&#39;c&#39; || USART1_RX_BUF[0]&#x3D;&#x3D;&#39;C&#39;)
				&#123;
					RTC_First_Config(); &#x2F;&#x2F;键盘输入c或C，初始化时钟
					BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);&#x2F;&#x2F;配置完成后，向后备寄存器中写特殊字符0xA5A5
					printf(&quot;初始化成功！      \r\n&quot;);&#x2F;&#x2F;显示初始化成功
				&#125;
				else
				&#123;
					printf(&quot;指令错误！          \r\n&quot;); &#x2F;&#x2F;显示指令错误！
				&#125; 
			&#125;
			else if((USART1_RX_STA&amp;0x3FFF)&#x3D;&#x3D;14)
			&#123; 
				&#x2F;&#x2F;将超级终端发过来的数据换算并写入RTC
				ryear &#x3D; (USART1_RX_BUF[0]-0x30)*1000+(USART1_RX_BUF[1]-0x30)*100+(USART1_RX_BUF[2]-0x30)*10+USART1_RX_BUF[3]-0x30;
				rmon &#x3D; (USART1_RX_BUF[4]-0x30)*10+USART1_RX_BUF[5]-0x30;&#x2F;&#x2F;串口发来的是字符，减0x30后才能得到十进制0~9的数据
				rday &#x3D; (USART1_RX_BUF[6]-0x30)*10+USART1_RX_BUF[7]-0x30;
				rhour &#x3D; (USART1_RX_BUF[8]-0x30)*10+USART1_RX_BUF[9]-0x30;
				rmin &#x3D; (USART1_RX_BUF[10]-0x30)*10+USART1_RX_BUF[11]-0x30;
				rsec &#x3D; (USART1_RX_BUF[12]-0x30)*10+USART1_RX_BUF[13]-0x30;
				bya&#x3D;RTC_Set(ryear,rmon,rday,rhour,rmin,rsec); &#x2F;&#x2F;将数据写入RTC计算器的程序
				if(bya&#x3D;&#x3D;0)
					printf(&quot;写入成功！      \r\n&quot;);&#x2F;&#x2F;显示写入成功 
				else 
					printf(&quot;写入失败！       \r\n&quot;); &#x2F;&#x2F;显示写入失败
			&#125;
			else
			&#123; 
				printf(&quot;指令错误！          \r\n&quot;); &#x2F;&#x2F;如果不是以上正确的操作，显示指令错误！
			&#125;
			
			USART1_RX_STA&#x3D;0; &#x2F;&#x2F;将串口数据标志位清0
		&#125;
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204251858012.jpg" alt=""></p>
<h2 id="触摸按键的原理与驱动">触摸按键的原理与驱动</h2>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>led.c，led.h</font> 和<font color='orange'> 7 </font>相同；只需添加<font color='green'> touch_key.c </font>和 <font color='green'>touch_key.h</font> 即可</p>
<ul>
<li><font color='red'>需要把跳帽短接</font></li>
<li><font color='red'>注意单片机上电的时候不要把手或者其他物品放在触摸按键上</font>（因为上电后会把触摸按键状态作为按键没有按下的初始状态）</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204161814345.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204161805400.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204161807133.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204161808563.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204161809871.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204161811467.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204161813484.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<p>touch_key.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __TOUCH_KEY_H
# define __TOUCH_KEY_H	 
# include &quot;sys.h&quot;

# define TOUCH_KEYPORT	GPIOA	&#x2F;&#x2F;定义IO接口组
# define TOUCH_KEY_A		GPIO_Pin_0	&#x2F;&#x2F;定义IO接口
# define TOUCH_KEY_B		GPIO_Pin_1	&#x2F;&#x2F;定义IO接口
# define TOUCH_KEY_C		GPIO_Pin_2	&#x2F;&#x2F;定义IO接口
# define TOUCH_KEY_D		GPIO_Pin_3	&#x2F;&#x2F;定义IO接口


void TOUCH_KEY_Init(void);&#x2F;&#x2F;初始化

		 				    
# endif</code></pre>
<p>touch_key.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;touch_key.h&quot;

void TOUCH_KEY_Init(void)&#x2F;&#x2F;微动开关的接口初始化
&#123; 
	GPIO_InitTypeDef  GPIO_InitStructure; &#x2F;&#x2F;定义GPIO的初始化枚举结构	
    GPIO_InitStructure.GPIO_Pin &#x3D; TOUCH_KEY_A | TOUCH_KEY_B | TOUCH_KEY_C | TOUCH_KEY_D; &#x2F;&#x2F;选择端口                       
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IPU; &#x2F;&#x2F;选择IO接口工作方式 &#x2F;&#x2F;上拉电阻（低电平有效）       
	GPIO_Init(TOUCH_KEYPORT,&amp;GPIO_InitStructure);			
&#125;</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	触摸按键驱动程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　					
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;led.h&quot;
# include &quot;touch_key.h&quot;

int main (void)&#123;&#x2F;&#x2F;主程序
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	LED_Init();&#x2F;&#x2F;LED初始化
	TOUCH_KEY_Init();&#x2F;&#x2F;按键初始化
	while(1)
    &#123;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&#x2F;&#x2F;读触摸按键的电平（0代表按下，取反就是1）
        &#123; 
			GPIO_WriteBit(LEDPORT,LED1,(BitAction)(1));&#x2F;&#x2F;LED控制	
            &#x2F;&#x2F;GPIO_SetBits(LEDPORT,LED1);&#x2F;&#x2F;也可以用这种，我比较喜欢这种
		&#125;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))&#x2F;&#x2F;读触摸按键的电平
        &#123; 
			GPIO_WriteBit(LEDPORT,LED2,(BitAction)(1));&#x2F;&#x2F;LED控制	
		&#125;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))&#x2F;&#x2F;读触摸按键的电平
        &#123; 
			GPIO_WriteBit(LEDPORT,LED1|LED2,(BitAction)(0));&#x2F;&#x2F;LED控制
            &#x2F;&#x2F;GPIO_ResetBits(LEDPORT,LED1|LED2);&#x2F;&#x2F;也可以用这种
		&#125;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))&#x2F;&#x2F;读触摸按键的电平
        &#123; 
			GPIO_WriteBit(LEDPORT,LED1|LED2,(BitAction)(1));&#x2F;&#x2F;LED控制	
		&#125;
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=511039279&bvid=BV1mu411k7wj&cid=584920156&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
<h3 id="按键双击和长按">按键双击和长按</h3>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h，led.c，led.h，touch_key.c，touvh_key.h</font> 和<font color='orange'>13</font> 相同</p>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204162323011.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204162329030.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204162329136.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<p>main.c</p>
<p>加延时消抖是因为触摸按键跟普通按键的 I/O口是相通的，为了兼容普通按键所以加了消抖这个对触摸按键没有影响</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204162339658.jpg" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	按键双击和长按程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;led.h&quot;
# include &quot;touch_key.h&quot;

# define KEYA_SPEED1	100	  &#x2F;&#x2F;长按的时间长度（单位10mS）
# define KEYA_SPEED2	10	  &#x2F;&#x2F;双击的时间长度（单位20mS）


int main (void)&#123;&#x2F;&#x2F;主程序
	u8 a&#x3D;0,b,c&#x3D;0;
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	LED_Init();&#x2F;&#x2F;LED初始化
	TOUCH_KEY_Init();&#x2F;&#x2F;按键初始化
	while(1)
	&#123;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))
		&#123; &#x2F;&#x2F;检测按键是否按下
			delay_ms(20); &#x2F;&#x2F;延时去抖动
			if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&#x2F;&#x2F;判断长短键
			&#123;
				while((!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&amp;&amp;c&lt;KEYA_SPEED1)&#x2F;&#x2F;循环判断长按，到时跳转
				&#123; 
					c++;delay_ms(10); &#x2F;&#x2F;长按判断的计时
				&#125;
				if(c&gt;&#x3D;KEYA_SPEED1)&#x2F;&#x2F;长键处理
				&#123; 
					&#x2F;&#x2F;长按后执行的程序放到此处
					GPIO_WriteBit(LEDPORT,LED1,(BitAction)(1));&#x2F;&#x2F;LED控制
					while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A));
				&#125;
				else&#x2F;&#x2F;单击处理
				&#123; 
					for(b&#x3D;0;b&lt;KEYA_SPEED2;b++)&#x2F;&#x2F;检测双击
					&#123;
						delay_ms(20);
						if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))
						&#123;
							a&#x3D;1;
							&#x2F;&#x2F;双击后执行的程序放到此处
							GPIO_WriteBit(LEDPORT,LED2,(BitAction)(1));&#x2F;&#x2F;LED控制

							while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A));&#x2F;&#x2F;等待按键放开
						&#125;
					&#125;
					if(a&#x3D;&#x3D;0)&#x2F;&#x2F;判断单击
					&#123; 
						&#x2F;&#x2F;单击后执行的程序放到此处
						GPIO_WriteBit(LEDPORT,LED1|LED2,(BitAction)(0));&#x2F;&#x2F;LED控制
					&#125;
				&#125;
				
				a&#x3D;0;c&#x3D;0; &#x2F;&#x2F;参数清0
			&#125;
		&#125; &#x2F;&#x2F;按键判断在此结束
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=468541562&bvid=BV1a541117b2&cid=585314262&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
<h3 id="触摸按键滑动程序">触摸按键滑动程序</h3>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h，led.c，led.h，touch_key.c，touvh_key.h</font> 和<font color='orange'>13</font> 相同；<font color='green'>usart.c，usart.h </font>和 <font color='orange'>11.1</font> 相同</p>
<ul>
<li>区分单击或者滑动：<font color='orange'>只需判断按下时和松开时是不是同一个按键即可</font>，<font color='cornflowerblue'>假如按下是 A 松开是 B 就可以说是从 A -&gt; B 滑动</font></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204162352794.jpg" alt=""></p>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	触摸按键滑动,单击,双击,长按程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;led.h&quot;
# include &quot;touch_key.h&quot;
# include &quot;usart.h&quot;

# define KEYA_SPEED1	100	  &#x2F;&#x2F;长按的时间长度（单位10mS）
# define KEYA_SPEED2	10	  &#x2F;&#x2F;双击的时间长度（单位20mS）



int main (void)&#123;&#x2F;&#x2F;主程序
	u16 k&#x3D;1000;	&#x2F;&#x2F;用于滑动加减计数
	u8 a&#x3D;0,b,c&#x3D;0;
	u8 s&#x3D;0; &#x2F;&#x2F;刚刚结束滑动标志
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	USART1_Init(115200); &#x2F;&#x2F;串口初始化，参数中写波特率
	LED_Init();&#x2F;&#x2F;LED初始化
	TOUCH_KEY_Init();&#x2F;&#x2F;按键初始化
	while(1)&#123;
&#x2F;&#x2F;A
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&#123; &#x2F;&#x2F;检测按键是否按下
			delay_ms(20); &#x2F;&#x2F;延时去抖动
			if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&#123;&#x2F;&#x2F;判断长短键
				while((!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&amp;&amp;c&lt;KEYA_SPEED1)&#123; &#x2F;&#x2F;循环判断长按，到时跳转
					c++;delay_ms(10); &#x2F;&#x2F;长按判断的计时
				&#125;
				if(c&gt;&#x3D;KEYA_SPEED1)&#123; &#x2F;&#x2F;长键处理
					&#x2F;&#x2F;长按后执行的程序放到此处
					GPIO_WriteBit(LEDPORT,LED1,(BitAction)(1));&#x2F;&#x2F;LED控制
					printf(&quot;A键长按 \r\n&quot;);
					while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A));
				&#125;else&#123; &#x2F;&#x2F;单击处理
					if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))&#123;
						k++; &#x2F;&#x2F;用于显示的计数值
						printf(&quot;A键右滑 %d \r\n&quot;,k); 
						a&#x3D;1;s&#x3D;1; &#x2F;&#x2F;a是单双击判断标志，s是刚刚结束滑动标志
					&#125;
					if(a&#x3D;&#x3D;0)&#123;
						for(b&#x3D;0;b&lt;KEYA_SPEED2;b++)&#123;&#x2F;&#x2F;检测双击
							delay_ms(20);
							if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&#123;
								a&#x3D;1;
								&#x2F;&#x2F;双击后执行的程序放到此处
								GPIO_WriteBit(LEDPORT,LED2,(BitAction)(1));&#x2F;&#x2F;LED控制
								printf(&quot;A键双击 \r\n&quot;);
								while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A));
							&#125;
						&#125;
						if(a&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;判断单击
							if(s&#x3D;&#x3D;1)&#123; &#x2F;&#x2F;判断是不是刚执行完滑动操作
								s&#x3D;0; &#x2F;&#x2F;如果是则本次不执行单击处理（因为是滑动的放开操作）
							&#125;else&#123;	 &#x2F;&#x2F;如果不是，则正常执行单击处理
								&#x2F;&#x2F;单击后执行的程序放到此处
								GPIO_WriteBit(LEDPORT,LED1|LED2,(BitAction)(0));&#x2F;&#x2F;LED控制
								printf(&quot;A键单击 \r\n&quot;);
							&#125;
						&#125;
					&#125;
				&#125;
				a&#x3D;0;c&#x3D;0; &#x2F;&#x2F;参数清0
			&#125;
		&#125; &#x2F;&#x2F;按键判断在此结束
&#x2F;&#x2F;B
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))&#123; &#x2F;&#x2F;检测按键是否按下
			delay_ms(20); &#x2F;&#x2F;延时去抖动
			if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))&#123;&#x2F;&#x2F;判断长短键
				while((!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))&amp;&amp;c&lt;KEYA_SPEED1)&#123; &#x2F;&#x2F;循环判断长按，到时跳转
					c++;delay_ms(10); &#x2F;&#x2F;长按判断的计时
				&#125;
				if(c&gt;&#x3D;KEYA_SPEED1)&#123; &#x2F;&#x2F;长键处理
					&#x2F;&#x2F;长按后执行的程序放到此处
					GPIO_WriteBit(LEDPORT,LED1,(BitAction)(1));&#x2F;&#x2F;LED控制
					printf(&quot;B键长按 \r\n&quot;);
					while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B));
				&#125;else&#123; &#x2F;&#x2F;单击处理
					if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))&#123;
						k++;
						printf(&quot;B键右滑 %d \r\n&quot;,k); 
						a&#x3D;1;s&#x3D;1; &#x2F;&#x2F;a是单双击判断标志，s是刚刚结束滑动标志
					&#125;
					if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&#123;
						k--;
						printf(&quot;B键左滑 %d \r\n&quot;,k); 
						a&#x3D;1;s&#x3D;1; &#x2F;&#x2F;a是单双击判断标志，s是刚刚结束滑动标志
					&#125;
					if(a&#x3D;&#x3D;0)&#123;
						for(b&#x3D;0;b&lt;KEYA_SPEED2;b++)&#123;&#x2F;&#x2F;检测双击
							delay_ms(20);
							if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))&#123;
								a&#x3D;1;
								&#x2F;&#x2F;双击后执行的程序放到此处
								GPIO_WriteBit(LEDPORT,LED2,(BitAction)(1));&#x2F;&#x2F;LED控制
								printf(&quot;B键双击 \r\n&quot;);
								while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B));
							&#125;
						&#125;
						if(a&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;判断单击
							if(s&#x3D;&#x3D;1)&#123; &#x2F;&#x2F;判断是不是刚执行完滑动操作
								s&#x3D;0; &#x2F;&#x2F;如果是则本次不执行单击处理（因为是滑动的放开操作）
							&#125;else&#123;	 &#x2F;&#x2F;如果不是，则正常执行单击处理
								&#x2F;&#x2F;单击后执行的程序放到此处
								GPIO_WriteBit(LEDPORT,LED1|LED2,(BitAction)(0));&#x2F;&#x2F;LED控制
								printf(&quot;B键单击 \r\n&quot;);
							&#125;
						&#125;
					&#125;
				&#125;
				a&#x3D;0;c&#x3D;0; &#x2F;&#x2F;参数清0
			&#125;
		&#125; &#x2F;&#x2F;按键判断在此结束
&#x2F;&#x2F;C
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))&#123; &#x2F;&#x2F;检测按键是否按下
			delay_ms(20); &#x2F;&#x2F;延时去抖动
			if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))&#123;&#x2F;&#x2F;判断长短键
				while((!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))&amp;&amp;c&lt;KEYA_SPEED1)&#123; &#x2F;&#x2F;循环判断长按，到时跳转
					c++;delay_ms(10); &#x2F;&#x2F;长按判断的计时
				&#125;
				if(c&gt;&#x3D;KEYA_SPEED1)&#123; &#x2F;&#x2F;长键处理
					&#x2F;&#x2F;长按后执行的程序放到此处
					GPIO_WriteBit(LEDPORT,LED1,(BitAction)(1));&#x2F;&#x2F;LED控制
					printf(&quot;C键长按 \r\n&quot;);
					while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C));
				&#125;else&#123; &#x2F;&#x2F;单击处理
					if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))&#123;
						k++;
						printf(&quot;C键右滑 %d \r\n&quot;,k); 
						a&#x3D;1;s&#x3D;1; &#x2F;&#x2F;a是单双击判断标志，s是刚刚结束滑动标志
					&#125;
					if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))&#123;
						k--;
						printf(&quot;C键左滑 %d \r\n&quot;,k); 
						a&#x3D;1;s&#x3D;1; &#x2F;&#x2F;a是单双击判断标志，s是刚刚结束滑动标志
					&#125;
					if(a&#x3D;&#x3D;0)&#123;
						for(b&#x3D;0;b&lt;KEYA_SPEED2;b++)&#123;&#x2F;&#x2F;检测双击
							delay_ms(20);
							if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))&#123;
								a&#x3D;1;
								&#x2F;&#x2F;双击后执行的程序放到此处
								GPIO_WriteBit(LEDPORT,LED2,(BitAction)(1));&#x2F;&#x2F;LED控制
								printf(&quot;C键双击 \r\n&quot;);
								while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C));
							&#125;
						&#125;
						if(a&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;判断单击
							if(s&#x3D;&#x3D;1)&#123; &#x2F;&#x2F;判断是不是刚执行完滑动操作
								s&#x3D;0; &#x2F;&#x2F;如果是则本次不执行单击处理（因为是滑动的放开操作）
							&#125;else&#123;	 &#x2F;&#x2F;如果不是，则正常执行单击处理
								&#x2F;&#x2F;单击后执行的程序放到此处
								GPIO_WriteBit(LEDPORT,LED1|LED2,(BitAction)(0));&#x2F;&#x2F;LED控制
								printf(&quot;C键单击 \r\n&quot;);
							&#125;
						&#125;
					&#125;
				&#125;
				a&#x3D;0;c&#x3D;0; &#x2F;&#x2F;参数清0
			&#125;
		&#125; &#x2F;&#x2F;按键判断在此结束
&#x2F;&#x2F;D
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))&#123; &#x2F;&#x2F;检测按键是否按下
			delay_ms(20); &#x2F;&#x2F;延时去抖动
			if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))&#123;&#x2F;&#x2F;判断长短键
				while((!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))&amp;&amp;c&lt;KEYA_SPEED1)&#123; &#x2F;&#x2F;循环判断长按，到时跳转
					c++;delay_ms(10); &#x2F;&#x2F;长按判断的计时
				&#125;
				if(c&gt;&#x3D;KEYA_SPEED1)&#123; &#x2F;&#x2F;长键处理
					&#x2F;&#x2F;长按后执行的程序放到此处
					GPIO_WriteBit(LEDPORT,LED1,(BitAction)(1));&#x2F;&#x2F;LED控制
					printf(&quot;D键长按 \r\n&quot;);
					while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D));
				&#125;else&#123; &#x2F;&#x2F;单击处理
					if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))&#123;
						k--;
						printf(&quot;D键左滑 %d \r\n&quot;,k); 
						a&#x3D;1;s&#x3D;1; &#x2F;&#x2F;a是单双击判断标志，s是刚刚结束滑动标志
					&#125;
					if(a&#x3D;&#x3D;0)&#123;
						for(b&#x3D;0;b&lt;KEYA_SPEED2;b++)&#123;&#x2F;&#x2F;检测双击
							delay_ms(20);
							if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))&#123;
								a&#x3D;1;
								&#x2F;&#x2F;双击后执行的程序放到此处
								GPIO_WriteBit(LEDPORT,LED2,(BitAction)(1));&#x2F;&#x2F;LED控制
								printf(&quot;D键双击 \r\n&quot;);
								while(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D));
							&#125;
						&#125;
						if(a&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;判断单击
							if(s&#x3D;&#x3D;1)&#123; &#x2F;&#x2F;判断是不是刚执行完滑动操作
								s&#x3D;0; &#x2F;&#x2F;如果是则本次不执行单击处理（因为是滑动的放开操作）
							&#125;else&#123;	 &#x2F;&#x2F;如果不是，则正常执行单击处理
								&#x2F;&#x2F;单击后执行的程序放到此处
								GPIO_WriteBit(LEDPORT,LED1|LED2,(BitAction)(0));&#x2F;&#x2F;LED控制
								printf(&quot;D键单击 \r\n&quot;);
							&#125;
						&#125;
					&#125;
				&#125;
				a&#x3D;0;c&#x3D;0; &#x2F;&#x2F;参数清0
			&#125;
		&#125; &#x2F;&#x2F;按键判断在此结束

	&#125;
&#125;
</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204261331288.jpg" alt=""></p>
<h2 id="数码管原理与驱动程序">数码管原理与驱动程序</h2>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>rtc.c，rtc.h</font> 和<font color='orange'> 12</font>相同；只需添加<font color='green'> TM1640.c </font>和 <font color='green'>TM1640.h</font> 即可</p>
<p>首先把跳帽按下面图片接好</p>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171203284.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171203063.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171203330.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<p>​		<font color='orange'>TM1640</font>是一种LED(发光二极管显示器）驱动控制专用电路，内部集成有MCU数字接口、数据锁存器、LED 驱动等电路。本产品性能优良，质量可靠。主要应用于电子产品LED显示屏驱动。采用<font color='orange'>SOP28</font>的封装形式。</p>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171211768.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171211752.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202205022202764.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171211798.png","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<ul>
<li>数码管对照</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202205022158149.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202205022158591.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202205022158207.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<p>TM1640.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __TM1640_H
# define __TM1640_H	 
# include &quot;sys.h&quot;

# define TM1640_GPIOPORT	GPIOA	&#x2F;&#x2F;定义IO接口
# define TM1640_DIN	GPIO_Pin_12	&#x2F;&#x2F;定义IO接口
# define TM1640_SCLK	GPIO_Pin_11	&#x2F;&#x2F;定义IO接口

# define TM1640_LEDPORT	0xC8	&#x2F;&#x2F;定义IO接口


void TM1640_Init(void);&#x2F;&#x2F;初始化
void TM1640_led(u8 date);&#x2F;&#x2F;
void TM1640_display(u8 address,u8 date);&#x2F;&#x2F;
void TM1640_display_add(u8 address,u8 date);&#x2F;&#x2F;

		 				    
# endif</code></pre>
<p>TM1640.c</p>
<ul>
<li><font color='pink'>TM1640_start（）</font>和 <font color='pink'>TM1640_stop（）</font>看这个时序图</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204262013858.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204262234341.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204262234965.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204262234709.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171255975.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;TM1640.h&quot;
# include &quot;delay.h&quot;

# define DEL  1   &#x2F;&#x2F;宏定义 通信速率（默认为1，如不能通信或者数码管数据经常丢失可加大数值）

&#x2F;&#x2F;地址模式的设置
&#x2F;&#x2F;# define TM1640MEDO_ADD  0x40   &#x2F;&#x2F;宏定义	自动加一模式
# define TM1640MEDO_ADD  0x44   &#x2F;&#x2F;宏定义 固定地址模式（推荐）

&#x2F;&#x2F;显示亮度的设置
&#x2F;&#x2F;# define TM1640MEDO_DISPLAY  0x88   &#x2F;&#x2F;宏定义 亮度  最小
&#x2F;&#x2F;# define TM1640MEDO_DISPLAY  0x89   &#x2F;&#x2F;宏定义 亮度
&#x2F;&#x2F;# define TM1640MEDO_DISPLAY  0x8a   &#x2F;&#x2F;宏定义 亮度
&#x2F;&#x2F;# define TM1640MEDO_DISPLAY  0x8b   &#x2F;&#x2F;宏定义 亮度
# define TM1640MEDO_DISPLAY  0x8c   &#x2F;&#x2F;宏定义 亮度（推荐）
&#x2F;&#x2F;# define TM1640MEDO_DISPLAY  0x8d   &#x2F;&#x2F;宏定义 亮度
&#x2F;&#x2F;# define TM1640MEDO_DISPLAY  0x8f   &#x2F;&#x2F;宏定义 亮度 最大

# define TM1640MEDO_DISPLAY_OFF  0x80   &#x2F;&#x2F;宏定义 亮度 关



void TM1640_start()  &#x2F;&#x2F;通信时序 启始（基础GPIO操作）（低层）
&#123;
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
    delay_us(DEL);
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    delay_us(DEL);
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    delay_us(DEL);
&#125;
void TM1640_stop()  &#x2F;&#x2F;通信时序 结束（基础GPIO操作）（低层）
&#123;
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
    delay_us(DEL);
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
    delay_us(DEL);
&#125;
void TM1640_write(u8 date) 	&#x2F;&#x2F;写数据（低层）
&#123;
    u8 i;
    u8 aa;
    aa &#x3D; date;
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    for(i &#x3D; 0; i &lt; 8; i++)
    &#123;
        GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(0)); &#x2F;&#x2F;接口输出0
        delay_us(DEL);

        if(aa &amp; 0x01)
        &#123;
            GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
            delay_us(DEL);
        &#125;
        else
        &#123;
            GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(0)); &#x2F;&#x2F;接口输出0
            delay_us(DEL);
        &#125;
        GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
        delay_us(DEL);
        aa &#x3D; aa &gt;&gt; 1;
    &#125;
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(0)); &#x2F;&#x2F;接口输出0
&#125;

void TM1640_Init(void)  &#x2F;&#x2F;TM1640接口初始化
&#123;
    GPIO_InitTypeDef  GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE);
    GPIO_InitStructure.GPIO_Pin &#x3D; TM1640_DIN | TM1640_SCLK; &#x2F;&#x2F;选择端口号（0~15或all）
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_Out_PP; &#x2F;&#x2F;选择IO接口工作方式
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz; &#x2F;&#x2F;设置IO接口速度（2&#x2F;10&#x2F;50MHz）
    GPIO_Init(TM1640_GPIOPORT, &amp;GPIO_InitStructure);

    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
    TM1640_start();
    TM1640_write(TM1640MEDO_ADD); &#x2F;&#x2F;设置数据，0x40,0x44分别对应地址自动加一和固定地址模式
    TM1640_stop();
    TM1640_start();
    TM1640_write(TM1640MEDO_DISPLAY); &#x2F;&#x2F;控制显示，开显示，0x88,  0x89,  0x8a,  0x8b,  0x8c,  0x8d,  0x8e,  0x8f分别对应脉冲宽度为:
    &#x2F;&#x2F;------------------1&#x2F;16,  2&#x2F;16,  4&#x2F;16,  10&#x2F;16, 11&#x2F;16, 12&#x2F;16, 13&#x2F;16, 14&#x2F;16	 &#x2F;&#x2F;0x80关显示
    TM1640_stop();

&#125;
void TM1640_led(u8 date)  &#x2F;&#x2F;固定地址模式的显示输出8个LED控制
&#123;
    TM1640_start();
    TM1640_write(TM1640_LEDPORT);	&#x2F;&#x2F;传显示数据对应的地址
    TM1640_write(date);	&#x2F;&#x2F;传1BYTE显示数据
    TM1640_stop();
&#125;
void TM1640_display(u8 address, u8 date) &#x2F;&#x2F;固定地址模式的显示输出
&#123;
    const u8 buff[21] &#x3D; &#123;0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0xbf, 0x86, 0xdb, 0xcf, 0xe6, 0xed, 0xfd, 0x87, 0xff, 0xef, 0x00&#125;; &#x2F;&#x2F;数字0~9及0~9加点显示段码表
    &#x2F;&#x2F;---------------   0    1    2    3    4    5    6    7    8    9    0.   1.   2.   3.   4.   5.   6.   7.   8.   9.   无
    TM1640_start();
    TM1640_write(0xC0 + address);	       &#x2F;&#x2F;传显示数据对应的地址
    TM1640_write(buff[date]);				 &#x2F;&#x2F;传1BYTE显示数据
    TM1640_stop();
&#125;
void TM1640_display_add(u8 address, u8 date) 	&#x2F;&#x2F;地址自动加一模式的显示输出
&#123;
    u8 i;
    const u8 buff[21] &#x3D; &#123;0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0xbf, 0x86, 0xdb, 0xcf, 0xe6, 0xed, 0xfd, 0x87, 0xff, 0xef, 0x00&#125;; &#x2F;&#x2F;数字0~9及0~9加点显示段码表
    &#x2F;&#x2F;---------------   0    1    2    3    4    5    6    7    8    9    0.   1.   2.   3.   4.   5.   6.   7.   8.   9.   无
    TM1640_start();
    TM1640_write(0xC0 + address);	       &#x2F;&#x2F;设置起始地址
    for(i &#x3D; 0; i &lt; 16; i++)
    &#123;
        TM1640_write(buff[date]);
    &#125;
    TM1640_stop();
&#125;</code></pre>
<p>上面代码中的 <font color='pink'>TM1640_write(u8 date) </font>函数可以写成下面这种：</p>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void TM1640_write(u8 date)
&#123;
    u8 mask;
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    for(mask&#x3D;0x01;mask!&#x3D;0;mask&lt;&lt;&#x3D;1)&#x2F;&#x2F;将0x01当做偏移量，date不用动每次判断date与mask的值
    &#123;
        if((date &amp; mask)!&#x3D;0)
        &#123;
             GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
            delay_us(DEL);
        &#125;
        else
        &#123;
             GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(0)); &#x2F;&#x2F;接口输出高电平1
            delay_us(DEL);
        &#125;
        delay_us(DEL);
         GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(1)); &#x2F;&#x2F;接口输出高电平1
        delay_us(DEL);
        GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    &#125;
     GPIO_WriteBit(TM1640_GPIOPORT, TM1640_DIN, (BitAction)(0)); &#x2F;&#x2F;接口输出0
    GPIO_WriteBit(TM1640_GPIOPORT, TM1640_SCLK, (BitAction)(0)); &#x2F;&#x2F;接口输出0
&#125;</code></pre>
<p>main.c</p>
<ul>
<li><font color='pink'>TM1640_led©;</font> ：参数是16进制想要led1点亮也就是 0000 0001 转换16进制就是 <font color='orange'>0x01</font></li>
<li>数码管那 <font color='cornflowerblue'>+10</font> 表示<font color='orange'>点亮小数点</font></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	数码管RTC显示程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;rtc.h&quot;
# include &quot;TM1640.h&quot;



int main (void)&#123;&#x2F;&#x2F;主程序
	u8 c&#x3D;0x01;
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	RTC_Config();  &#x2F;&#x2F;RTC初始化
	TM1640_Init(); &#x2F;&#x2F;TM1640初始化
	while(1)&#123;
		if(RTC_Get()&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;读出RTC时间
			TM1640_display(0,rday&#x2F;10);	&#x2F;&#x2F;天
			TM1640_display(1,rday%10+10);
			TM1640_display(2,rhour&#x2F;10); &#x2F;&#x2F;时
			TM1640_display(3,rhour%10+10);
			TM1640_display(4,rmin&#x2F;10);	&#x2F;&#x2F;分
			TM1640_display(5,rmin%10+10);
			TM1640_display(6,rsec&#x2F;10); &#x2F;&#x2F;秒
			TM1640_display(7,rsec%10);
            &#x2F;&#x2F;TM1640_display(7,20);&#x2F;&#x2F;灯熄灭

			TM1640_led(c); &#x2F;&#x2F;与TM1640连接的8个LED全亮
			c&lt;&lt;&#x3D;1; &#x2F;&#x2F;数据左移 流水灯
			if(c&#x3D;&#x3D;0x00)c&#x3D;0x01; &#x2F;&#x2F;8个灯显示完后重新开始
			delay_ms(125); &#x2F;&#x2F;延时
		&#125;
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=468512375&bvid=BV1n541117fQ&cid=585821136&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
<h2 id="旋转编码器原理与驱动">旋转编码器原理与驱动</h2>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>rtc.c，rtc.h</font> 和<font color='orange'> 12</font>相同；<font color='green'>TM1640.c </font>和<font color='green'> TM1640.h</font> 与<font color='orange'>14</font> 相同；只需添加 <font color='green'>encoder.c，encoder.h</font></p>
<p>首先把跳帽按下面图片接好</p>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171305255.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171305364.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171315560.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171315707.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171321359.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171323708.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<p>encoder.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __ENCODER_H
# define __ENCODER_H	 
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;

# define ENCODER_PORT_A	GPIOA		&#x2F;&#x2F;定义IO接口组
# define ENCODER_L	GPIO_Pin_6	&#x2F;&#x2F;定义IO接口（key2）
# define ENCODER_D	GPIO_Pin_7	&#x2F;&#x2F;定义IO接口（按键）

# define ENCODER_PORT_B	GPIOB		&#x2F;&#x2F;定义IO接口组
# define ENCODER_R	GPIO_Pin_2	&#x2F;&#x2F;定义IO接口（key3）


void ENCODER_Init(void);&#x2F;&#x2F;初始化
u8 ENCODER_READ(void);


		 				    
# endif</code></pre>
<p>encoder.c</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202205031105854.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204171501248.png" alt=""></p>
<ul>
<li>这里是用第二种方法判断左右转：<font color='orange'>循环判断 key2 是否触发，再判断 key3高电平还是低电平</font></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;encoder.h&quot;


u8 KUP;&#x2F;&#x2F;旋钮锁死标志（1为锁死）
u16 cou;

void ENCODER_Init(void)&#x2F;&#x2F;接口初始化
&#123;
    GPIO_InitTypeDef  GPIO_InitStructure; &#x2F;&#x2F;定义GPIO的初始化枚举结构
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE);
    GPIO_InitStructure.GPIO_Pin &#x3D; ENCODER_L | ENCODER_D; &#x2F;&#x2F;选择端口号
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IPU; &#x2F;&#x2F;选择IO接口工作方式 &#x2F;&#x2F;上拉电阻
    GPIO_Init(ENCODER_PORT_A, &amp;GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin &#x3D; ENCODER_R; &#x2F;&#x2F;选择端口号
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IPU; &#x2F;&#x2F;选择IO接口工作方式 &#x2F;&#x2F;上拉电阻
    GPIO_Init(ENCODER_PORT_B, &amp;GPIO_InitStructure);
&#125;

u8 ENCODER_READ(void)&#x2F;&#x2F;接口初始化
&#123;
    u8 a;&#x2F;&#x2F;存放按键的值
    u8 kt;
    a &#x3D; 0;
    if(GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_L))KUP &#x3D; 0;	&#x2F;&#x2F;判断旋钮（key2）是否解除锁死（高电平代表解除锁死）,如果是1则清零
    if(!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_L) &amp;&amp; KUP &#x3D;&#x3D; 0) &#x2F;&#x2F;判断是否旋转旋钮，同时判断是否有旋钮锁死（低电平有效）（单独判断key2是否触发）
    &#123;
        delay_us(100);
        kt &#x3D; GPIO_ReadInputDataBit(ENCODER_PORT_B, ENCODER_R);	&#x2F;&#x2F;把旋钮另一端电平状态记录
        delay_ms(3); &#x2F;&#x2F;延时
        if(!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_L)) &#x2F;&#x2F;去抖
        &#123;
            if(kt &#x3D;&#x3D; 0) &#x2F;&#x2F;用另一端判断左或右旋转
            &#123;
                a &#x3D; 1; &#x2F;&#x2F;右转（key3为低电平）
            &#125;
            else
            &#123;
                a &#x3D; 2; &#x2F;&#x2F;左转（key3为高电平）
            &#125;
            cou &#x3D; 0; &#x2F;&#x2F;初始锁死判断计数器
            while(!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_L) &amp;&amp; cou &lt; 60000) &#x2F;&#x2F;等待放开旋钮，同时累加判断锁死
            &#123;
                cou++;
                KUP &#x3D; 1;
                delay_us(20); 
            &#125;
        &#125;
    &#125;

    if(!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_D) &amp;&amp; KUP &#x3D;&#x3D; 0) &#x2F;&#x2F;判断旋钮是否按下
    &#123;
        delay_ms(20);
        if(!GPIO_ReadInputDataBit(ENCODER_PORT_A, ENCODER_D)) &#x2F;&#x2F;去抖动
        &#123;
            a &#x3D; 3; &#x2F;&#x2F;在按键按下时加上按键的状态值
            &#x2F;&#x2F;while(ENCODER_D&#x3D;&#x3D;0);	等等旋钮放开
        &#125;
    &#125;
    return a;
&#125;</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	旋转编码器数码管显示程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;rtc.h&quot;
# include &quot;TM1640.h&quot;

# include &quot;encoder.h&quot;


int main (void)&#123;&#x2F;&#x2F;主程序
	u8 a&#x3D;0,b&#x3D;0,c&#x3D;0x01;
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	RTC_Config();  &#x2F;&#x2F;RTC初始化

	ENCODER_Init(); &#x2F;&#x2F;旋转编码器初始化

	TM1640_Init(); &#x2F;&#x2F;TM1640初始化
	TM1640_display(0,a&#x2F;10); &#x2F;&#x2F;显示数值
	TM1640_display(1,a%10);
    &#x2F;&#x2F;其他数码管不用要关闭不然会显示乱码
	TM1640_display(2,20);
	TM1640_display(3,20);
	TM1640_display(4,20);
	TM1640_display(5,20);
	TM1640_display(6,20);
	TM1640_display(7,20);

    while(1)
    &#123;
        b &#x3D; ENCODER_READ();	&#x2F;&#x2F;读出旋转编码器值
        if(b &#x3D;&#x3D; 1)
        &#123;
            a++;    &#x2F;&#x2F;分析按键值，并加减计数器值。
            if(c!&#x3D;0x80)c&lt;&lt;&#x3D;1;&#x2F;&#x2F;灯右到左
            if(a &gt; 99)a &#x3D; 0;
        &#125;
        if(b &#x3D;&#x3D; 2)
        &#123;
            if(a &#x3D;&#x3D; 0)a &#x3D; 100;
            if(c!&#x3D;0x01)c&gt;&gt;&#x3D;1;&#x2F;&#x2F;灯左到右
            a--;
        &#125;
        if(b &#x3D;&#x3D; 3)
        &#123;
            a &#x3D; 0;
            c&#x3D;0x01;
        &#125;
        if(b !&#x3D; 0) &#x2F;&#x2F;如果有旋转器的操作
        &#123;
            TM1640_display(0, a &#x2F; 10); &#x2F;&#x2F;显示数值
            TM1640_display(1, a % 10);
            TM1640_led(c);
        &#125;
    &#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=768576113&bvid=BV1xr4y1n7pC&cid=586104099&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
<h2 id="I2C总线之读取温度值">I2C总线之读取温度值</h2>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>本节用到的固件库函数</p>
</div>
<ul>
<li>I2C_Init（<font color='orange'>手册 11.2.2</font>）//初始化外设I2Cx</li>
<li>I2C_Cmd（<font color='orange'>手册 11.2.4</font>）//使能或者失能I2C外设</li>
<li>I2C_GenerateSTART（<font color='orange'>手册 11.2.7</font>）//产生起止信号</li>
<li>I2C_CheckEvent（<font color='orange'>手册 11.2.28</font>）//检测EVx事件</li>
<li>I2C_Send7bitAddress（<font color='orange'>手册 11.2.16</font>）//发送设备地址</li>
<li>I2C_SendData（<font color='orange'>手册 11.2.14</font>）//发送数据</li>
<li>I2C_GenerateSTOP（<font color='orange'>手册 11.2.8</font>）//停止信号</li>
<li>I2C_AcknowledgeConfig（<font color='orange'>手册 11.2.9</font>）//开启或者关闭对应 I2C 应答功能</li>
<li>I2C_ReceiveData（<font color='orange'>手册 11.2.15</font>）//返回通过 I2Cx 最近接收的数据</li>
</ul>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>TM1640.c </font>和<font color='green'> TM1640.h</font> 与<font color='orange'>14</font> 相同；只需添加 <font color='green'>Lm75a.c，Lm75a.h，i2c.c，i2c.h</font>（需要在<font color='cornflowerblue'> Lib</font>文件添加 <font color='green'>stm32f10x_i2c.c</font>）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204171517462.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204171517304.jpg" alt=""></p>
<ul>
<li>电路连接:两线总线连接，1～10K上拉电阻，复用开漏模式。</li>
<li>器件地址:每个器件都有<font color='orange'>唯一地址</font>，最多127个器件地址。（最新版 I2C 规范中新增加了10位地址模式。最大器件地址数量可达1023个）</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171529588.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171539449.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171611184.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171611065.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171611161.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171708175.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171722478.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171724487.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204171736847.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<p>i2c.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __I2C_H
# define __I2C_H	 
# include &quot;sys.h&quot;

# define I2CPORT		GPIOB	&#x2F;&#x2F;定义IO接口
# define I2C_SCL		GPIO_Pin_6	&#x2F;&#x2F;定义IO接口
# define I2C_SDA		GPIO_Pin_7	&#x2F;&#x2F;定义IO接口

# define HostAddress	0xc0	&#x2F;&#x2F;总线主机的器件地址
# define BusSpeed	200000	&#x2F;&#x2F;总线速度（不高于400000）


void I2C_Configuration(void);
void I2C_SAND_BUFFER(u8 SlaveAddr, u8 WriteAddr, u8* pBuffer, u16 NumByteToWrite);
void I2C_SAND_BYTE(u8 SlaveAddr,u8 writeAddr,u8 pBuffer);
void I2C_READ_BUFFER(u8 SlaveAddr,u8 readAddr,u8* pBuffer,u16 NumByteToRead);
u8 I2C_READ_BYTE(u8 SlaveAddr,u8 readAddr);
		 				    
# endif
</code></pre>
<p>i2c.c</p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>I2C_InitTypeDef 结构体6个成员参数介绍</p>
</div>
<ul>
<li><font color='red'>I2C_ClockSpeed</font>：这个<font color='cornflowerblue'>主要是设置SCL的时钟频率</font>。我们知道I2C分为两种模式：<font color='orange'>标准和快速两种模式</font>。频率为100/400khz。因此在配置这个值的时候<font color='orange'>不能超过400000</font>。</li>
<li><font color='red'>I2C_Mode</font>：这个成员<font color='cornflowerblue'>主要是配置I2C的工作模式</font>。可选 <font color='orange'>I2C模式</font>和 <font color='orange'>SMBUS模式</font>。<font color='orange'>一般情况下我们多选I2C模式</font></li>
<li><font color='red'>I2C_DutyCycle</font>：这个成员<font color='cornflowerblue'>设置的是I2C的SCL线时钟的占空比</font>。主要有两种模式，但其实选哪种都没有多大的影响</li>
<li><font color='red'>I2C_OwnAddress1</font>：这个成员<font color='cornflowerblue'>主要设置的是I2C设备的地址</font>。地址可设置为<font color='orange'>7位或10位</font></li>
<li><font color='red'>I2C_Ack</font>：这个成员<font color='cornflowerblue'>主要是配置I2C的应答位</font>。分为<font color='orange'>应答</font>和<font color='orange'>非应答</font>，<font color='orange'>一般大多情况下设置为应答</font></li>
<li><font color='red'>I2C_AcknowledgeAddress</font>：这个成员<font color='cornflowerblue'>配置选择I2C的寻址模式是7位还是10位地址</font>。这需要根据实际连接到I2C总线上设备的地址进行选择，<font color='orange'>这个成员的配置也影响到</font> <font color='red'>I2C_OwnAddress1</font><font color='orange'>成员，只有这里设置成 10 位模式时，</font> <font color='red'>I2C_OwnAddress1</font> <font color='orange'>才支持10位地址</font></li>
</ul>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>主发送流程</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204281445604.jpg" alt=""></p>
<p>​将I2C_CR1寄存器的START位<font color='orange'>置1</font>，就会<font color='orange'>产生起始条件</font>，如果正常产生了一个起始信号，就会产生一个 <font color='cornflowerblue'>EV5</font> 事件，这时I2C_SR1寄存器的SB位就会变为<font color='orange'>1</font>，所以可以通过读取状态寄存器（I2C_SR1）的SB位来判断起始条件是否产生。<br>
​       主发送器发送地址后，如果从设备产生了应答信号，就会产生 <font color='cornflowerblue'>EV6</font> 和 <font color='cornflowerblue'>EV8</font> 事件，<font color='cornflowerblue'>EV6</font> 事件 I2C_SR1寄存器的ADD=1，这表示地址发送结束，<font color='cornflowerblue'>EV8</font> 事件是TxE=1，也就是数据寄存器为空，数据寄存器为空就可以继续写入新的数据，这就是判断这些EVx事件的意义（即检测这些状态位的意义就是等待I2C将要发送的数据成功发送，然后才能进行下一步工作）。当产生<font color='cornflowerblue'> EV8_2</font> 事件时，TxE=1，BTF=1,BTF=1表示数据移位寄存器为空，这样就表示所有数据都被发送出去了，然后就可以<font color='orange'>产生停止位</font>，即将I2C_CR1寄存器的STOP位<font color='orange'>置1</font>，结束这次通信。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204281453330.jpg" alt=""></p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>主接收流程</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204281502024.jpg" alt=""></p>
<p>​<font color='orange'>起始信号发送完成后</font>就会产生一个 <font color='cornflowerblue'>EV5 </font>事件，然后<font color='orange'>发送从机地址</font>，从机产生应答信号，产生<font color='cornflowerblue'> EV6</font> 事件，和主发送器不一样的是，当主机读取从机的数据后，产生的应答是主机产生的，不是从机产生的，这个应答信号的产生是将I2C_CR1寄存器的ACK位<font color='orange'>置1</font>，然后会产生一个 <font color='cornflowerblue'>EV7</font> 事件，<font color='cornflowerblue'>EV7</font> 事件 RxNE=1，表示数据寄存器非空，即数据寄存器有数据了，这时候内核就可以将数据寄存器里的值送到内存变量中以供使用。ACk应答信号为1的时候就会继续从从机中读取数据，然后再产生ACK应答，循环往复，当不在接收数据时，就会产生一个 <font color='cornflowerblue'>EV7_1</font> 事件，这个事件是RxNE=1，并设置ACK=0和STOP位（将其置1），<font color='orange'>结束数据的发送</font>，最后产生一个 <font color='cornflowerblue'>EV7</font> 事件，<font color='orange'>表示最后一个数据读取完成</font>。</p>
<p><font color='red'>还有要注意的就是，以上那些状态位读取后都要将其清除，每个位的清除方法都不一样，具体方法可见上面EVx事件后面的描述</font></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204291531712.jpg" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;i2c.h&quot;


void I2C_GPIO_Init(void)&#123; &#x2F;&#x2F;I2C接口初始化
	GPIO_InitTypeDef  GPIO_InitStructure; 	
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC,ENABLE);       
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); &#x2F;&#x2F;启动I2C功能 
    GPIO_InitStructure.GPIO_Pin &#x3D; I2C_SCL | I2C_SDA; &#x2F;&#x2F;选择端口号                      
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF_OD; &#x2F;&#x2F;选择IO接口工作方式（复用开漏输出）       
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz; &#x2F;&#x2F;设置IO接口速度（2&#x2F;10&#x2F;50MHz）    
	GPIO_Init(I2CPORT, &amp;GPIO_InitStructure);
&#125;

void I2C_Configuration(void)&#123; &#x2F;&#x2F;I2C初始化
	I2C_InitTypeDef  I2C_InitStructure;
	I2C_GPIO_Init(); &#x2F;&#x2F;先设置GPIO接口的状态
	I2C_InitStructure.I2C_Mode &#x3D; I2C_Mode_I2C;&#x2F;&#x2F;设置为I2C模式
	I2C_InitStructure.I2C_DutyCycle &#x3D; I2C_DutyCycle_2;
	I2C_InitStructure.I2C_OwnAddress1 &#x3D; HostAddress; &#x2F;&#x2F;主机地址（从机不得用此地址）
	I2C_InitStructure.I2C_Ack &#x3D; I2C_Ack_Enable;&#x2F;&#x2F;允许应答
	I2C_InitStructure.I2C_AcknowledgedAddress &#x3D; I2C_AcknowledgedAddress_7bit; &#x2F;&#x2F;7位地址模式
	I2C_InitStructure.I2C_ClockSpeed &#x3D; BusSpeed; &#x2F;&#x2F;总线速度设置 	
	I2C_Init(I2C1,&amp;I2C_InitStructure);
	I2C_Cmd(I2C1,ENABLE);&#x2F;&#x2F;开启I2C					
&#125;

void I2C_SAND_BUFFER(u8 SlaveAddr,u8 WriteAddr,u8* pBuffer,u16 NumByteToWrite)&#123; &#x2F;&#x2F;I2C发送数据串（器件地址，寄存器，内部地址，数量）
	I2C_GenerateSTART(I2C1,ENABLE);&#x2F;&#x2F;产生起始位
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)); &#x2F;&#x2F;清除EV5（返回值success：1 error:0）
	I2C_Send7bitAddress(I2C1,SlaveAddr,I2C_Direction_Transmitter);&#x2F;&#x2F;发送器件地址，选择为发送模式还是接收模式
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));&#x2F;&#x2F;清除EV6
	I2C_SendData(I2C1,WriteAddr); &#x2F;&#x2F;内部功能地址
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED));&#x2F;&#x2F;移位寄存器非空，数据寄存器已空，产生EV8，发送数据到DR既清除该事件
	while(NumByteToWrite--)&#123; &#x2F;&#x2F;循环发送数据	
		I2C_SendData(I2C1,*pBuffer); &#x2F;&#x2F;发送数据
		pBuffer++; &#x2F;&#x2F;数据指针移位
		while (!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED));&#x2F;&#x2F;清除EV8
	&#125;
	I2C_GenerateSTOP(I2C1,ENABLE);&#x2F;&#x2F;产生停止信号
&#125;
void I2C_SAND_BYTE(u8 SlaveAddr,u8 writeAddr,u8 pBuffer)&#123; &#x2F;&#x2F;I2C发送一个字节（从地址，内部地址，内容）
	I2C_GenerateSTART(I2C1,ENABLE); &#x2F;&#x2F;发送开始信号
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)); &#x2F;&#x2F;等待完成（清除EV5）	
	I2C_Send7bitAddress(I2C1,SlaveAddr, I2C_Direction_Transmitter); &#x2F;&#x2F;发送从器件地址及状态（写入）
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); &#x2F;&#x2F;等待完成	(清除EV6)
	I2C_SendData(I2C1,writeAddr); &#x2F;&#x2F;发送从器件内部寄存器地址
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)); &#x2F;&#x2F;等待完成（移位寄存器非空，数据寄存器已空，产生EV8，发送数据到DR既清除该事件）	
	I2C_SendData(I2C1,pBuffer); &#x2F;&#x2F;发送要写入的内容
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)); &#x2F;&#x2F;等待完成（清除EV8）	
	I2C_GenerateSTOP(I2C1,ENABLE); &#x2F;&#x2F;发送结束信号
&#125;
void I2C_READ_BUFFER(u8 SlaveAddr,u8 readAddr,u8* pBuffer,u16 NumByteToRead)&#123; &#x2F;&#x2F;I2C读取数据串（器件地址，寄存器，内部地址，数量）
	while(I2C_GetFlagStatus(I2C1,I2C_FLAG_BUSY));
	I2C_GenerateSTART(I2C1,ENABLE);&#x2F;&#x2F;开启信号
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT));	&#x2F;&#x2F;清除 EV5
	I2C_Send7bitAddress(I2C1,SlaveAddr, I2C_Direction_Transmitter); &#x2F;&#x2F;写入器件地址
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));&#x2F;&#x2F;清除 EV6
	I2C_Cmd(I2C1,ENABLE);
	I2C_SendData(I2C1,readAddr); &#x2F;&#x2F;发送读的地址
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)); &#x2F;&#x2F;清除 EV8
	I2C_GenerateSTART(I2C1,ENABLE); &#x2F;&#x2F;开启信号
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)); &#x2F;&#x2F;清除 EV5
	I2C_Send7bitAddress(I2C1,SlaveAddr,I2C_Direction_Receiver); &#x2F;&#x2F;将器件地址传出，主机为读
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)); &#x2F;&#x2F;清除EV6
	while(NumByteToRead)&#123;
		if(NumByteToRead &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;NumByteToRead&#x3D;1，表示已经接收到最后一个数据了
			I2C_AcknowledgeConfig(I2C1,DISABLE); &#x2F;&#x2F;最后有一个数据时关闭应答位
			I2C_GenerateSTOP(I2C1,ENABLE);	&#x2F;&#x2F;最后一个数据时使能停止位
		&#125;
		if(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED))&#123; &#x2F;&#x2F;读取数据
			*pBuffer &#x3D; I2C_ReceiveData(I2C1);&#x2F;&#x2F;调用库函数将数据取出到 pBuffer
			pBuffer++; &#x2F;&#x2F;指针移位
			NumByteToRead--; &#x2F;&#x2F;字节数减 1 
		&#125;
	&#125;
	I2C_AcknowledgeConfig(I2C1,ENABLE);&#x2F;&#x2F;打开应答，方便下一次I2C传输
&#125;
u8 I2C_READ_BYTE(u8 SlaveAddr,u8 readAddr)&#123; &#x2F;&#x2F;I2C读取一个字节
	u8 a;
	while(I2C_GetFlagStatus(I2C1,I2C_FLAG_BUSY));
	I2C_GenerateSTART(I2C1,ENABLE);
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT));
	I2C_Send7bitAddress(I2C1,SlaveAddr, I2C_Direction_Transmitter); 
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
	I2C_Cmd(I2C1,ENABLE);
	I2C_SendData(I2C1,readAddr);
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED));
	I2C_GenerateSTART(I2C1,ENABLE);
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT));
	I2C_Send7bitAddress(I2C1,SlaveAddr, I2C_Direction_Receiver);
	while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
	I2C_AcknowledgeConfig(I2C1,DISABLE); &#x2F;&#x2F;最后有一个数据时关闭应答位
	I2C_GenerateSTOP(I2C1,ENABLE);	&#x2F;&#x2F;最后一个数据时使能停止位
	a &#x3D; I2C_ReceiveData(I2C1);
	return a;
&#125;</code></pre>
<p>Lm75a.h</p>
<ul>
<li>器件地址通过下面可以知道：</li>
</ul>
<p>下面图片可以知道 <font color='orange'>A0 A1 A2</font> 都已经接<font color='red'> 3V</font> 了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204291646101.jpg" alt=""></p>
<p>地址的<font color='orange'>高4位</font>预先设置为 <font color='cornflowerblue'>‘1001’</font>；<font color='orange'>I2C</font>器件一共有<font color='orange'>七</font>位地址码，还有一位是<font color='cornflowerblue'>读/写(R/W)</font>操作位,<font color='orange'>0代表读，1代表写</font></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204291649085.jpg" alt=""></p>
<p>由于 A0 A1 A2 接的是<font color='red'>3V</font>，并且最后一位是读，所以器件地址是：1 0 0 1 1 1 1 0（0x9E）</p>
<p>如果 A0 A1 A2 接的是<font color='red'>地线</font>，并且最后一位是读，则器件地址是：1 0 0 1 0 0 0 0（0x90）</p>
<ul>
<li>子地址（寄存器地址）：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204291712026.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204291722998.jpg" alt=""></p>
<ul>
<li>温度值计算</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204291729049.jpg" alt=""></p>
<ul>
<li>字节数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204291725329.jpg" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __LM75A_H
# define __LM75A_H	 
# include &quot;sys.h&quot;
# include &quot;i2c.h&quot;


# define LM75A_ADD	0x9E	&#x2F;&#x2F;器件地址



void LM75A_GetTemp(u8 *Tempbuffer);&#x2F;&#x2F;读温度
void LM75A_POWERDOWN(void); &#x2F;&#x2F;掉电模式
		 				    
# endif</code></pre>
<p>Lm75a.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;Lm75a.h&quot;



&#x2F;&#x2F;读出LM75A的温度值（-55~125摄氏度）
&#x2F;&#x2F;温度正负号（0正1负），温度整数，温度小数（点后2位）依次放入*Tempbuffer（十进制）
void LM75A_GetTemp(u8 *Tempbuffer)&#123;   
    u8 buf[2]; &#x2F;&#x2F;温度值储存   
    u8 t&#x3D;0,a&#x3D;0;   
    I2C_READ_BUFFER(LM75A_ADD,0x00,buf,2); &#x2F;&#x2F;读出温度值（器件地址，子地址，数据储存器，字节数）
	t &#x3D; buf[0]; &#x2F;&#x2F;处理温度整数部分，0~125度
	*Tempbuffer &#x3D; 0; &#x2F;&#x2F;温度值为正值
	if(t &amp; 0x80)&#123; &#x2F;&#x2F;判断温度是否是负（MSB表示温度符号）（1 0 0 0  0 0 0 0）
		*Tempbuffer &#x3D; 1; &#x2F;&#x2F;温度值为负值
		t &#x3D; ~t; t++; &#x2F;&#x2F;计算补码（原码取反后加1）注：如果不行可以把小数也取反加1试试
	&#125;
	if(t &amp; 0x01)&#123; a&#x3D;a+1; &#125; &#x2F;&#x2F;从高到低按位加入温度积加值（0~125）
	if(t &amp; 0x02)&#123; a&#x3D;a+2; &#125;
	if(t &amp; 0x04)&#123; a&#x3D;a+4; &#125;
	if(t &amp; 0x08)&#123; a&#x3D;a+8; &#125;
	if(t &amp; 0x10)&#123; a&#x3D;a+16; &#125;
	if(t &amp; 0x20)&#123; a&#x3D;a+32; &#125;
	if(t &amp; 0x40)&#123; a&#x3D;a+64; &#125;
	Tempbuffer++;
	*Tempbuffer &#x3D; a;
	a &#x3D; 0;
	t &#x3D; buf[1]; &#x2F;&#x2F;处理小数部分，取0.125精度的前2位（12、25、37、50、62、75、87）
	if(t &amp; 0x20)&#123; a&#x3D;a+12; &#125;
	if(t &amp; 0x40)&#123; a&#x3D;a+25; &#125;
	if(t &amp; 0x80)&#123; a&#x3D;a+50; &#125;
	Tempbuffer++;
	*Tempbuffer &#x3D; a;   
&#125;

&#x2F;&#x2F;LM75进入掉电模式，再次调用LM75A_GetTemp();即可正常工作
&#x2F;&#x2F;建议只在需要低功耗情况下使用
void LM75A_POWERDOWN(void)&#123;&#x2F;&#x2F; 
    I2C_SAND_BYTE(LM75A_ADD,0x01,1); &#x2F;&#x2F;1就是看配置寄存器表
&#125;
</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	温度传感器数码管显示程序
编写时间：	2018年2月10日
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;TM1640.h&quot;

# include &quot;Lm75a.h&quot;

int main (void)&#123;&#x2F;&#x2F;主程序
	u8 buffer[3];
	u8 c&#x3D;0x01;
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 

	I2C_Configuration();&#x2F;&#x2F;I2C初始化

	TM1640_Init(); &#x2F;&#x2F;TM1640初始化
	TM1640_display(0,20); &#x2F;&#x2F;初始显示内容
	TM1640_display(1,20);
	TM1640_display(2,20);
	TM1640_display(3,20);
	TM1640_display(4,20);
	TM1640_display(5,20);
	TM1640_display(6,20);
	TM1640_display(7,20);

	while(1)&#123;
		LM75A_GetTemp(buffer); &#x2F;&#x2F;读取LM75A的温度数据
			
		TM1640_display(0,buffer[1]&#x2F;10); &#x2F;&#x2F;显示数值（十位）
		TM1640_display(1,buffer[1]%10+10);&#x2F;&#x2F;显示数值（个位+小数点）
		TM1640_display(2,buffer[2]&#x2F;10);&#x2F;&#x2F;小数点后的十位
		TM1640_display(3,buffer[2]%10);&#x2F;&#x2F;小数点后的个位

		TM1640_led(c); &#x2F;&#x2F;与TM1640连接的8个LED全亮
		c&lt;&lt;&#x3D;1; &#x2F;&#x2F;数据左移 流水灯
		if(c&#x3D;&#x3D;0x00)c&#x3D;0x01; &#x2F;&#x2F;8个灯显示完后重新开始
		delay_ms(150); &#x2F;&#x2F;延时
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=341118873&bvid=BV1aR4y1P7XM&cid=587938287&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
<h3 id="软件模拟I2C">软件模拟I2C</h3>
<p>​<font color='orange'>软件i2c</font>是程序员使用程序控制 <font color='orange'>SCL,SDA</font> 线输出高低电平，模拟i2c协议的时序。<font color='cornflowerblue'>一般较硬件i2c稳定，但是程序较为繁琐，但不难。</font>有些单片机的硬件i2c不太稳定，调试问题较多。</p>
<p>文件跟上面 <font color='orange'>16 </font>一样，只是把<font color='green'> i2c.c，i2c.h </font>替换成 <font color='green'>iic.c，iic.h</font> 然后把 <font color='green'>Lm75a.c</font> 改一下关于<font color='orange'> I2C </font>的代码即可</p>
<p>iic.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __IIC_H
# define __IIC_H
# include &quot;sys.h&quot;

# define IIC_PORT GPIOB
# define SCL_PIN GPIO_Pin_6&#x2F;&#x2F;控制线
# define SDA_PIN GPIO_Pin_7&#x2F;&#x2F;数据线

&#x2F;&#x2F;SCL&#x3D;1
# define SCL_1() 	GPIO_SetBits(IIC_PORT,SCL_PIN)
&#x2F;&#x2F;SCL&#x3D;0
# define SCL_0() 	GPIO_ResetBits(IIC_PORT,SCL_PIN)
&#x2F;&#x2F;SDA&#x3D;1
# define SDA_1() 	GPIO_SetBits(IIC_PORT,SDA_PIN)
&#x2F;&#x2F;SDA&#x3D;0
# define SDA_0() 	GPIO_ResetBits(IIC_PORT,SDA_PIN)
&#x2F;&#x2F;读SDA当前状态
# define SDA_READ() 	GPIO_ReadInputDataBit(IIC_PORT,SDA_PIN)


void IIC_Init(void);&#x2F;&#x2F;初始化管脚
void IIC_Start(void);&#x2F;&#x2F;起始信号
void IIC_Stop(void);&#x2F;&#x2F;停止信号
u8 IIC_Write(u8 dat);&#x2F;&#x2F;写操作，返回值-从机应答位的值	
u8 IIC_Read(void);&#x2F;&#x2F;读操作，返回值-读到的字节
u8 IIC_Read_Nak(void);&#x2F;&#x2F;读操作，并且发送非应答信号，返回值-读到的字节
u8 IIC_Read_Ack(void);&#x2F;&#x2F;读操作，并且发送应答信号，返回值-读到的字节
u8 Read_Byte(u8 device_addr,u8 addr);&#x2F;&#x2F;向从机读取器件字节
void Write_Byte(u8 device_addr,u8 addr,u8 dat);&#x2F;&#x2F;向从机写入器件字节
void Read_Buffer(u8 device_addr,u8 addr,u8* buf,int len);&#x2F;&#x2F;连续读取函数
void Write_Buffer(u8 device_addr,u8 addr,u8* buf,int len);&#x2F;&#x2F;连续写入函数

# endif</code></pre>
<p>iic.c</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202205021940125.jpg" alt=""></p>
<ul>
<li>I ^2^ C 中也有<font color='cornflowerblue'>起始信号、数据传输和停止信号</font>；止信号。其中数据传输部分，可以一次通信过程传输很多个字节，<code>字节数是不受限制的</code>，而每个字节的数据最后也跟了一位，这一位叫做 <code>应答位</code>，通常用 <code>ACK</code>表示。</li>
<li>UART 通信虽然用了<code>TXD</code>和<code>RXD</code>两根线，但是实际一次通信中， 1条线就可以完成， 2条线是把发送和接收分开而已，而 I 2 C 每次通信，<code>不管是发送还是接收，必须 2条线都参与工作才能完成</code></li>
<li>I^2^C 通信流程解析</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202205021946917.jpg" alt=""></p>
<p><font color='red'>起始信号：</font></p>
<p>UART 通信是<code>从一直持续的高电平出现一个低电平</code><font color='cornflowerblue'>标志起始位</font>；而 I 2 C 通信的起始信号的定义是 <code>SCL 为高电平期间， SDA 由高电平向低电平变化产生一个下降沿</code>，<font color='cornflowerblue'>表示起始信号</font>，如图 14-3 中的 Start 部分所示。</p>
<p><font color='red'>数据传输：</font></p>
<p>首先，<code>UART 是低位在前，高位在后</code>；<code>而 I 2 C 通信是高位在前，低位在后</code>。其次，<code>UART 通信数据位是固定长度，波特率分之一，一位一位固定时间发送完毕就可以了</code>。<code>而 I 2 C 没有固定波特率，但是有时序的要求</code>，<code>要求当 SCL 在低电平的时 候， SDA 允许变化，也就是说，发送方必须先保持 SCL 是低电平，才可以改变数据线 SDA ，输出要发送的当前数据的一位；而当 SCL 在高电平的时候， SDA 绝对不可以变化，因为这个时候，接收方要来读取当前 SDA 的电平信号是 0 还是 1 ，因此要保证 SDA 的稳定，</code>如图 14-3 中的<code>每一位数据的变化，都是在 SCL 的低电平位置</code>。 <code>8 位数据位后边跟着的是一位应答位</code>。</p>
<p><font color='red'>停止信号：</font></p>
<p><font color='orange'>UART 通信的停止位是一位固定的高电平信号</font>；<font color='orange'>而 I 2 C 通信停止信号的定义是 SCL 为高电平期间， SDA 由低电平向高电平变化产生一个上升沿 ，表示结束信号</font>，如图14-3 中的 Stop 部分所示。</p>
<p><font color='red'>I ^2^ C 寻址模式：</font></p>
<p>上面介绍的是 I^2^C 每一位信号的时序流程，而 I^2^C 通信在字节级的传输中，也有固定的时序要求。<font color='orange'> I^2^C 通信的起始信号 (Start) 后，首先要发送一个从机的地址</font>，这个地址一共有<font color='cornflowerblue'> 7<br>
位</font>，紧跟着的<font color='orange'>第 8 位是数据方向位</font> (R/W)，<font color='gree'>“0” 表示接下来要发送数据（写）“1”表示接下来是请求数据（读）</font>。<font color='orange'>当我们发送完了这 7 位地址和 1 位方向后</font>，<font color='cornflowerblue'>如果发送的这个地址确实存在，那么这个地址的器件应该回应一个 ACK （拉低 SDA 即输出“ 0 ”）</font>，<font color='cornflowerblue'>如果不存在，就没“人”回应 ACK SDA将保持高电平即“ 1 ”）。</font></p>
<p>还有一点要提一下，I ^2^ C 通信分为 <font color='cornflowerblue'>低速模式 100kbit/s 、快速模式 400kbit/s 和高速模式3.4Mbit/s</font> 。因为所有的 I ^2^ C 器件<font color='orange'>都支持低速，但却未必支持另外两种速度</font>，所以作为通用的I ^2^ C 程序我们选择 100k 这个速率来实现，也就是说<font color='orange'>实际程序产生的时序必须小于等于 100k的时序参数</font>，很明显也就是 <font color='orange'>要求 SCL 的高低电平持续时间都不短于 5us</font></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;iic.h&quot;
# include &quot;delay.h&quot;
# include &quot;Lm75a.h&quot;


&#x2F;&#x2F;初始化引脚
void IIC_Init(void)
&#123;
	GPIO_InitTypeDef GPIO_InitStructure;&#x2F;&#x2F;定义结构体
	GPIO_SetBits(IIC_PORT,SCL_PIN|SDA_PIN);&#x2F;&#x2F;都初始化为高电平，避免毛刺
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);&#x2F;&#x2F;使能GPIOB时钟
	GPIO_InitStructure.GPIO_Pin&#x3D;SCL_PIN|SDA_PIN;&#x2F;&#x2F;选择SCL和SDA I&#x2F;O口
	GPIO_InitStructure.GPIO_Mode&#x3D;GPIO_Mode_Out_OD;&#x2F;&#x2F;开漏输出
	GPIO_InitStructure.GPIO_Speed&#x3D;GPIO_Speed_10MHz;&#x2F;&#x2F;输出速率50
	GPIO_Init(IIC_PORT,&amp;GPIO_InitStructure);
&#125;

&#x2F;&#x2F;产生总线起始信号
void IIC_Start(void)
&#123;
	SDA_1();&#x2F;&#x2F;首先确保SDA,SCL都是高电平
	SCL_1();
	delay_us(5);
	SDA_0();&#x2F;&#x2F;先拉低SDA
	delay_us(5);
	SCL_0();&#x2F;&#x2F;再拉低SCL
&#125;

&#x2F;&#x2F;产生总线停止信号
void IIC_Stop(void)
&#123;
	SCL_0();&#x2F;&#x2F;首先确保SDA,SCL都是低电平
	SDA_0();
	delay_us(5);
	SCL_1();&#x2F;&#x2F;先拉高SCL
	delay_us(5);
	SDA_1();&#x2F;&#x2F;再拉高SDA
	delay_us(5);
&#125;

&#x2F;&#x2F;写操作，dat-待写入的字节 返回值-从机应答位的值
u8 IIC_Write(u8 dat)
&#123;
	u8 mask;
	u8 ack;&#x2F;&#x2F;暂存应答位的值
	for(mask&#x3D;0x80;mask!&#x3D;0;mask&gt;&gt;&#x3D;1)&#x2F;&#x2F;从高位到低位依次进行
	&#123;
		if((mask&amp;dat)&#x3D;&#x3D;0)
			SDA_0();
		else
			SDA_1();
		delay_us(5);
		SCL_1();&#x2F;&#x2F;拉高SCL
		delay_us(5);
		SCL_0();&#x2F;&#x2F;再拉低SCL,完成一个位周期
	&#125;
	SDA_1();&#x2F;&#x2F;8位数据发送完成，主机释放SDA,以检测从机应答
	delay_us(5);
	SCL_1();&#x2F;&#x2F;拉高SCL
	ack&#x3D;SDA_READ();&#x2F;&#x2F;读取此时的SDA值，即为从机的应答值
	delay_us(5);
	SCL_0();&#x2F;&#x2F;再拉低SCL完成应答位，并保持住总线
	delay_us(5);
	return (!ack);&#x2F;&#x2F;返回0代表不存在或者写入失败，1表示成功
&#125;

&#x2F;&#x2F;读取8位数据，返回值-读到的字节
u8 IIC_Read(void)
&#123;
	u16 i;
	u8 dat&#x3D;0;&#x2F;&#x2F;数据接收变量赋值0
	SDA_1();&#x2F;&#x2F;释放总线
	for(i&#x3D;0;i&lt;8;i++)
	&#123;
		delay_us(5);
		SCL_1();&#x2F;&#x2F;拉高SCL
		dat&lt;&lt;&#x3D;1;&#x2F;&#x2F;左移将已读的位往高位移动，实现高位在前低位在后
		if(SDA_READ()!&#x3D;0)
		&#123;
			dat|&#x3D;0x01;&#x2F;&#x2F;SDA为1时设置dat最低位为1，SDA为0时无操作，即仍为初始值的0
		&#125;
		delay_us(5);
		SCL_0();&#x2F;&#x2F;拉低SCL,使从机发送下一位
	&#125;
	return dat;
&#125;

&#x2F;&#x2F;读操作，并且发送非应答信号，返回值-读到的字节
u8 IIC_Read_Nak(void)
&#123;
	u8 dat;
	dat&#x3D;IIC_Read();&#x2F;&#x2F;读取8位数据
	SDA_1();&#x2F;&#x2F;8位数据读取完后，拉高SDA，发送非应答信号
	delay_us(5);
	SCL_1();&#x2F;&#x2F;拉高SCL
	delay_us(5);
	SCL_0();&#x2F;&#x2F;再拉低SCL，完成非应答位，并保持总线
	delay_us(5);
	return dat;
&#125;

&#x2F;&#x2F;读操作，并且发送应答信号，返回值-读到的字节
u8 IIC_Read_Ack(void)
&#123;
	u8 dat;
	dat&#x3D;IIC_Read();&#x2F;&#x2F;读取8位数据
	SDA_0();&#x2F;&#x2F;8位数据读取完后，拉低SDA，发送应答信号
	delay_us(5);
	SCL_1();&#x2F;&#x2F;拉高SCL
	delay_us(5);
	SCL_0();&#x2F;&#x2F;拉低SCL
	delay_us(5);
	return dat;
&#125;

&#x2F;&#x2F;向从机读取器件字节 addr-字节地址  0:写 1：读
u8 Read_Byte(u8 device_addr,u8 addr)
&#123;
	u8 dat;&#x2F;&#x2F;保存读取的数据
	do&#123;&#x2F;&#x2F;用寻址操作查询当前是否可以进行读写
		IIC_Start();&#x2F;&#x2F;起始信号
		if(IIC_Write(device_addr))&#x2F;&#x2F;应答则跳出循环否则继续查询
		&#123;
			break;
		&#125;
		IIC_Stop();&#x2F;&#x2F;停止信号
	&#125;while(1);
	IIC_Write(addr);&#x2F;&#x2F;写入存储地址
	IIC_Start();&#x2F;&#x2F;发送重复起始信号
	IIC_Write(device_addr|0x01);&#x2F;&#x2F;寻址器件，为读操作（0x50|0x01&#x3D;0xA1）
	dat&#x3D;IIC_Read_Nak();&#x2F;&#x2F;读取一个字节数据
	IIC_Stop();&#x2F;&#x2F;停止信号
	
	return dat;&#x2F;&#x2F;返回数据
&#125;

&#x2F;&#x2F;向从机写入器件字节 addr-字节地址  0:写 1：读
void Write_Byte(u8 device_addr,u8 addr,u8 dat)
&#123;
	do&#123;&#x2F;&#x2F;用寻址操作查询当前是否可以进行读写
		IIC_Start();&#x2F;&#x2F;起始信号
		if(IIC_Write(device_addr))&#x2F;&#x2F;应答则跳出循环否则继续查询
		&#123;
			break;
		&#125;
		IIC_Stop();&#x2F;&#x2F;停止信号
	&#125;while(1);
	IIC_Write(addr);&#x2F;&#x2F;写入存储地址
	IIC_Write(dat);&#x2F;&#x2F;写入一个字节数据
	IIC_Stop();&#x2F;&#x2F;停止信号
&#125;

&#x2F;&#x2F;连续读取函数 addr-起始地址 buf-数据接收指针 len-读取长度
void Read_Buffer(u8 device_addr,u8 addr,u8* buf,int len)
&#123;
	do&#123;&#x2F;&#x2F;用寻址操作查询当前是否可以进行读写
		IIC_Start();&#x2F;&#x2F;起止信号
		if(IIC_Write(device_addr))&#x2F;&#x2F;应答则跳出循环否则继续查询
		&#123;
			break;
		&#125;
		IIC_Stop();&#x2F;&#x2F;停止信号
	&#125;while(1);
	IIC_Write(addr);&#x2F;&#x2F;写入起始地址
	IIC_Start();&#x2F;&#x2F;发送重复起始信号
	IIC_Write(device_addr|0x01);&#x2F;&#x2F;读操作
	while(len&gt;1)&#x2F;&#x2F;连续读取len-1个字节
	&#123;
		*buf++&#x3D;IIC_Read_Ack();&#x2F;&#x2F;最后字节之前为读取操作+应答
		len--;
	&#125;
	*buf&#x3D;IIC_Read_Nak();&#x2F;&#x2F;最后一个字节为读取操作+非应答
	IIC_Stop();&#x2F;&#x2F;停止信号
&#125;

&#x2F;&#x2F;连续写入函数 addr-起始地址 buf-数据源指针 len-读取长度
void Write_Buffer(u8 device_addr,u8 addr,u8* buf,int len)
&#123;
	while(len&gt;0)
	&#123;
		do&#123;&#x2F;&#x2F;用寻址操作查询当前是否可以进行读写
			IIC_Start();&#x2F;&#x2F;起始信号
			if(IIC_Write(device_addr))
			&#123;
				break;
			&#125;
			IIC_Stop();&#x2F;&#x2F;停止信号
		&#125;while(1);
		IIC_Write(addr);&#x2F;&#x2F;写入起始地址
		while(len&gt;0)
		&#123;
			IIC_Write(*buf++);&#x2F;&#x2F;写入一个字节数据
			len--;&#x2F;&#x2F;待写入长度计数减一
			&#x2F;&#x2F;下面注释是EEPROM的暂时没用到
&#x2F;&#x2F;			addr++;&#x2F;&#x2F;地址加一
&#x2F;&#x2F;			if((addr&amp;0x07)&#x3D;&#x3D;0)&#x2F;&#x2F;检查地址是否到达页边界，24c02每页8字节
&#x2F;&#x2F;			&#123;				  &#x2F;&#x2F;所以检测低3位是否为0即可
&#x2F;&#x2F;				break;        &#x2F;&#x2F;到达也边界时，跳出循环，结束本次写操作
&#x2F;&#x2F;			&#125;
		&#125;
		IIC_Stop();&#x2F;&#x2F;停止信号
	&#125;
&#125;</code></pre>
<h2 id="OLED屏原理与驱动程序">OLED屏原理与驱动程序</h2>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>Im75a.c，Im75a.h</font> 和 <font color='orange'>16</font> 相同；只需添加 <font color='green'>oled0561.c，oled0561.h</font> 即可（需要添加<font color='green'> ASCII_8x16.h</font>（字库））</p>
<p><font color='red'>主控芯片：SH1106</font></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204171945474.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204291947273.jpg" alt=""></p>
<ul>
<li><font color='red'>高位在下，低位在上</font>（数据每次写入我们采用 <font color='orange'>“从左到右，从上到下，纵向 8 点下高位”</font>）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204172025139.jpg" alt=""></p>
<ul>
<li>英文或者数字可以显示<font color='orange'>4行</font>每行<font color='orange'>16个</font>；汉字可以显示<font color='orange'>4行</font>每行<font color='orange'>8个</font></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204172027162.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204172027055.jpg" alt=""></p>
<p>ASCII_8x16.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">
# ifndef __ASCII_8x16_H
# define __ASCII_8x16_H	 


&#x2F;&#x2F; ------------------  ASCII字模的数据表 ------------------------ &#x2F;&#x2F;
&#x2F;&#x2F; 码表从0x20~0x7e                                                &#x2F;&#x2F;
&#x2F;&#x2F; 字库:  纵向取模下高位&#x2F;&#x2F; （调用时要减512）
&#x2F;&#x2F; -------------------------------------------------------------- &#x2F;&#x2F;
const u8 ASCII_8x16[] &#x3D;  &#123;            &#x2F;&#x2F; ASCII
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  &#x2F;&#x2F; - -
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x38,0xFC,0xFC,0x38,0x00,0x00,  &#x2F;&#x2F; -!-
	0x00,0x00,0x00,0x0D,0x0D,0x00,0x00,0x00,

	0x00,0x0E,0x1E,0x00,0x00,0x1E,0x0E,0x00,  &#x2F;&#x2F; -&quot;-
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x20,0xF8,0xF8,0x20,0xF8,0xF8,0x20,0x00,  &#x2F;&#x2F; -# -
	0x02,0x0F,0x0F,0x02,0x0F,0x0F,0x02,0x00,

	0x38,0x7C,0x44,0x47,0x47,0xCC,0x98,0x00,  &#x2F;&#x2F; -$-
	0x03,0x06,0x04,0x1C,0x1C,0x07,0x03,0x00,

	0x30,0x30,0x00,0x80,0xC0,0x60,0x30,0x00,  &#x2F;&#x2F; -%-
	0x0C,0x06,0x03,0x01,0x00,0x0C,0x0C,0x00,

	0x80,0xD8,0x7C,0xE4,0xBC,0xD8,0x40,0x00,  &#x2F;&#x2F; -&amp;-
	0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00,

	0x00,0x10,0x1E,0x0E,0x00,0x00,0x00,0x00,  &#x2F;&#x2F; -&#39;-
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0xF0,0xF8,0x0C,0x04,0x00,0x00,  &#x2F;&#x2F; -(-
	0x00,0x00,0x03,0x07,0x0C,0x08,0x00,0x00,

	0x00,0x00,0x04,0x0C,0xF8,0xF0,0x00,0x00,  &#x2F;&#x2F; -)-
	0x00,0x00,0x08,0x0C,0x07,0x03,0x00,0x00,

	0x80,0xA0,0xE0,0xC0,0xC0,0xE0,0xA0,0x80,  &#x2F;&#x2F; -*-
	0x00,0x02,0x03,0x01,0x01,0x03,0x02,0x00,

	0x00,0x80,0x80,0xE0,0xE0,0x80,0x80,0x00,  &#x2F;&#x2F; -+-
	0x00,0x00,0x00,0x03,0x03,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  &#x2F;&#x2F; -,-
	0x00,0x00,0x10,0x1E,0x0E,0x00,0x00,0x00,

	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,  &#x2F;&#x2F; ---
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  &#x2F;&#x2F; -.-
	0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00,

	0x00,0x00,0x00,0x80,0xC0,0x60,0x30,0x00,  &#x2F;&#x2F; -&#x2F;-
	0x0C,0x06,0x03,0x01,0x00,0x00,0x00,0x00,

	0xF8,0xFC,0x04,0xC4,0x24,0xFC,0xF8,0x00,  &#x2F;&#x2F; -0-
	0x07,0x0F,0x09,0x08,0x08,0x0F,0x07,0x00,

	0x00,0x10,0x18,0xFC,0xFC,0x00,0x00,0x00,  &#x2F;&#x2F; -1-
	0x00,0x08,0x08,0x0F,0x0F,0x08,0x08,0x00,

	0x08,0x0C,0x84,0xC4,0x64,0x3C,0x18,0x00,  &#x2F;&#x2F; -2-
	0x0E,0x0F,0x09,0x08,0x08,0x0C,0x0C,0x00,

	0x08,0x0C,0x44,0x44,0x44,0xFC,0xB8,0x00,  &#x2F;&#x2F; -3-
	0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00,

	0xC0,0xE0,0xB0,0x98,0xFC,0xFC,0x80,0x00,  &#x2F;&#x2F; -4-
	0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,

	0x7C,0x7C,0x44,0x44,0xC4,0xC4,0x84,0x00,  &#x2F;&#x2F; -5-
	0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00,

	0xF0,0xF8,0x4C,0x44,0x44,0xC0,0x80,0x00,  &#x2F;&#x2F; -6-
	0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00,

	0x0C,0x0C,0x04,0x84,0xC4,0x7C,0x3C,0x00,  &#x2F;&#x2F; -7-
	0x00,0x00,0x0F,0x0F,0x00,0x00,0x00,0x00,

	0xB8,0xFC,0x44,0x44,0x44,0xFC,0xB8,0x00,  &#x2F;&#x2F; -8-
	0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00,

	0x38,0x7C,0x44,0x44,0x44,0xFC,0xF8,0x00,  &#x2F;&#x2F; -9-
	0x00,0x08,0x08,0x08,0x0C,0x07,0x03,0x00,

	0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,  &#x2F;&#x2F; -:-
	0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00,

	0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,  &#x2F;&#x2F; -;-
	0x00,0x00,0x08,0x0E,0x06,0x00,0x00,0x00,

	0x00,0x80,0xC0,0x60,0x30,0x18,0x08,0x00,  &#x2F;&#x2F; -&lt;-
	0x00,0x00,0x01,0x03,0x06,0x0C,0x08,0x00,

	0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,  &#x2F;&#x2F; -&#x3D;-
	0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,

	0x00,0x08,0x18,0x30,0x60,0xC0,0x80,0x00,  &#x2F;&#x2F; -&gt;-
	0x00,0x08,0x0C,0x06,0x03,0x01,0x00,0x00,

	0x18,0x1C,0x04,0xC4,0xE4,0x3C,0x18,0x00,  &#x2F;&#x2F; -?-
	0x00,0x00,0x00,0x0D,0x0D,0x00,0x00,0x00,

	0xF0,0xF8,0x08,0xC8,0xC8,0xF8,0xF0,0x00,  &#x2F;&#x2F; -@-
	0x07,0x0F,0x08,0x0B,0x0B,0x0B,0x01,0x00,

	0xE0,0xF0,0x98,0x8C,0x98,0xF0,0xE0,0x00,  &#x2F;&#x2F; -A-
	0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00,

	0x04,0xFC,0xFC,0x44,0x44,0xFC,0xB8,0x00,  &#x2F;&#x2F; -B-
	0x08,0x0F,0x0F,0x08,0x08,0x0F,0x07,0x00,

	0xF0,0xF8,0x0C,0x04,0x04,0x0C,0x18,0x00,  &#x2F;&#x2F; -C-
	0x03,0x07,0x0C,0x08,0x08,0x0C,0x06,0x00,

	0x04,0xFC,0xFC,0x04,0x0C,0xF8,0xF0,0x00,  &#x2F;&#x2F; -D-
	0x08,0x0F,0x0F,0x08,0x0C,0x07,0x03,0x00,

	0x04,0xFC,0xFC,0x44,0xE4,0x0C,0x1C,0x00,  &#x2F;&#x2F; -E-
	0x08,0x0F,0x0F,0x08,0x08,0x0C,0x0E,0x00,

	0x04,0xFC,0xFC,0x44,0xE4,0x0C,0x1C,0x00,  &#x2F;&#x2F; -F-
	0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00,

	0xF0,0xF8,0x0C,0x84,0x84,0x8C,0x98,0x00,  &#x2F;&#x2F; -G-
	0x03,0x07,0x0C,0x08,0x08,0x07,0x0F,0x00,

	0xFC,0xFC,0x40,0x40,0x40,0xFC,0xFC,0x00,  &#x2F;&#x2F; -H-
	0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00,

	0x00,0x00,0x04,0xFC,0xFC,0x04,0x00,0x00,  &#x2F;&#x2F; -I-
	0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,

	0x00,0x00,0x00,0x04,0xFC,0xFC,0x04,0x00,  &#x2F;&#x2F; -J-
	0x07,0x0F,0x08,0x08,0x0F,0x07,0x00,0x00,

	0x04,0xFC,0xFC,0xC0,0xF0,0x3C,0x0C,0x00,  &#x2F;&#x2F; -K-
	0x08,0x0F,0x0F,0x00,0x01,0x0F,0x0E,0x00,

	0x04,0xFC,0xFC,0x04,0x00,0x00,0x00,0x00,  &#x2F;&#x2F; -L-
	0x08,0x0F,0x0F,0x08,0x08,0x0C,0x0E,0x00,

	0xFC,0xFC,0x38,0x70,0x38,0xFC,0xFC,0x00,  &#x2F;&#x2F; -M-
	0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00,

	0xFC,0xFC,0x38,0x70,0xE0,0xFC,0xFC,0x00,  &#x2F;&#x2F; -N-
	0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00,

	0xF0,0xF8,0x0C,0x04,0x0C,0xF8,0xF0,0x00,  &#x2F;&#x2F; -O-
	0x03,0x07,0x0C,0x08,0x0C,0x07,0x03,0x00,

	0x04,0xFC,0xFC,0x44,0x44,0x7C,0x38,0x00,  &#x2F;&#x2F; -P-
	0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00,

	0xF8,0xFC,0x04,0x04,0x04,0xFC,0xF8,0x00,  &#x2F;&#x2F; -Q-
	0x07,0x0F,0x08,0x0E,0x3C,0x3F,0x27,0x00,

	0x04,0xFC,0xFC,0x44,0xC4,0xFC,0x38,0x00,  &#x2F;&#x2F; -R-
	0x08,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00,

	0x18,0x3C,0x64,0x44,0xC4,0x9C,0x18,0x00,  &#x2F;&#x2F; -S-
	0x06,0x0E,0x08,0x08,0x08,0x0F,0x07,0x00,

	0x00,0x1C,0x0C,0xFC,0xFC,0x0C,0x1C,0x00,  &#x2F;&#x2F; -T-
	0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,

	0xFC,0xFC,0x00,0x00,0x00,0xFC,0xFC,0x00,  &#x2F;&#x2F; -U-
	0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00,

	0xFC,0xFC,0x00,0x00,0x00,0xFC,0xFC,0x00,  &#x2F;&#x2F; -V-
	0x01,0x03,0x06,0x0C,0x06,0x03,0x01,0x00,

	0xFC,0xFC,0x00,0x80,0x00,0xFC,0xFC,0x00,  &#x2F;&#x2F; -W-
	0x03,0x0F,0x0E,0x03,0x0E,0x0F,0x03,0x00,

	0x0C,0x3C,0xF0,0xC0,0xF0,0x3C,0x0C,0x00,  &#x2F;&#x2F; -X-
	0x0C,0x0F,0x03,0x00,0x03,0x0F,0x0C,0x00,

	0x00,0x3C,0x7C,0xC0,0xC0,0x7C,0x3C,0x00,  &#x2F;&#x2F; -Y-
	0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,

	0x1C,0x0C,0x84,0xC4,0x64,0x3C,0x1C,0x00,  &#x2F;&#x2F; -Z-
	0x0E,0x0F,0x09,0x08,0x08,0x0C,0x0E,0x00,

	0x00,0x00,0xFC,0xFC,0x04,0x04,0x00,0x00,  &#x2F;&#x2F; -[-
	0x00,0x00,0x0F,0x0F,0x08,0x08,0x00,0x00,

	0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,  &#x2F;&#x2F; -\-
	0x00,0x00,0x00,0x01,0x03,0x07,0x0E,0x00,

	0x00,0x00,0x04,0x04,0xFC,0xFC,0x00,0x00,  &#x2F;&#x2F; -]-
	0x00,0x00,0x08,0x08,0x0F,0x0F,0x00,0x00,

	0x08,0x0C,0x06,0x03,0x06,0x0C,0x08,0x00,  &#x2F;&#x2F; -^-
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  &#x2F;&#x2F; -_-
	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,

	0x00,0x00,0x03,0x07,0x04,0x00,0x00,0x00,  &#x2F;&#x2F; -&#96;-
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0xA0,0xA0,0xA0,0xE0,0xC0,0x00,0x00,  &#x2F;&#x2F; -a-
	0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00,

	0x04,0xFC,0xFC,0x20,0x60,0xC0,0x80,0x00,  &#x2F;&#x2F; -b-
	0x08,0x0F,0x07,0x08,0x08,0x0F,0x07,0x00,

	0xC0,0xE0,0x20,0x20,0x20,0x60,0x40,0x00,  &#x2F;&#x2F; -c-
	0x07,0x0F,0x08,0x08,0x08,0x0C,0x04,0x00,

	0x80,0xC0,0x60,0x24,0xFC,0xFC,0x00,0x00,  &#x2F;&#x2F; -d-
	0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00,

	0xC0,0xE0,0xA0,0xA0,0xA0,0xE0,0xC0,0x00,  &#x2F;&#x2F; -e-
	0x07,0x0F,0x08,0x08,0x08,0x0C,0x04,0x00,

	0x40,0xF8,0xFC,0x44,0x0C,0x18,0x00,0x00,  &#x2F;&#x2F; -f-
	0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00,

	0xC0,0xE0,0x20,0x20,0xC0,0xE0,0x20,0x00,  &#x2F;&#x2F; -g-
	0x27,0x6F,0x48,0x48,0x7F,0x3F,0x00,0x00,

	0x04,0xFC,0xFC,0x40,0x20,0xE0,0xC0,0x00,  &#x2F;&#x2F; -h-
	0x08,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00,

	0x00,0x00,0x20,0xEC,0xEC,0x00,0x00,0x00,  &#x2F;&#x2F; -i-
	0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,

	0x00,0x00,0x00,0x00,0x20,0xEC,0xEC,0x00,  &#x2F;&#x2F; -j-
	0x00,0x30,0x70,0x40,0x40,0x7F,0x3F,0x00,

	0x04,0xFC,0xFC,0x80,0xC0,0x60,0x20,0x00,  &#x2F;&#x2F; -k-
	0x08,0x0F,0x0F,0x01,0x03,0x0E,0x0C,0x00,

	0x00,0x00,0x04,0xFC,0xFC,0x00,0x00,0x00,  &#x2F;&#x2F; -l-
	0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,

	0xE0,0xE0,0x60,0xC0,0x60,0xE0,0xC0,0x00,  &#x2F;&#x2F; -m-
	0x0F,0x0F,0x00,0x0F,0x00,0x0F,0x0F,0x00,

	0x20,0xE0,0xC0,0x20,0x20,0xE0,0xC0,0x00,  &#x2F;&#x2F; -n-
	0x00,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00,

	0xC0,0xE0,0x20,0x20,0x20,0xE0,0xC0,0x00,  &#x2F;&#x2F; -o-
	0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00,

	0x20,0xE0,0xC0,0x20,0x20,0xE0,0xC0,0x00,  &#x2F;&#x2F; -p-
	0x40,0x7F,0x7F,0x48,0x08,0x0F,0x07,0x00,

	0xC0,0xE0,0x20,0x20,0xC0,0xE0,0x20,0x00,  &#x2F;&#x2F; -q-
	0x07,0x0F,0x08,0x48,0x7F,0x7F,0x40,0x00,

	0x20,0xE0,0xC0,0x60,0x20,0x60,0xC0,0x00,  &#x2F;&#x2F; -r-
	0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00,

	0x40,0xE0,0xA0,0x20,0x20,0x60,0x40,0x00,  &#x2F;&#x2F; -s-
	0x04,0x0C,0x09,0x09,0x0B,0x0E,0x04,0x00,

	0x20,0x20,0xF8,0xFC,0x20,0x20,0x00,0x00,  &#x2F;&#x2F; -t-
	0x00,0x00,0x07,0x0F,0x08,0x0C,0x04,0x00,

	0xE0,0xE0,0x00,0x00,0xE0,0xE0,0x00,0x00,  &#x2F;&#x2F; -u-
	0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00,

	0x00,0xE0,0xE0,0x00,0x00,0xE0,0xE0,0x00,  &#x2F;&#x2F; -v-
	0x00,0x03,0x07,0x0C,0x0C,0x07,0x03,0x00,

	0xE0,0xE0,0x00,0x00,0x00,0xE0,0xE0,0x00,  &#x2F;&#x2F; -w-
	0x07,0x0F,0x0C,0x07,0x0C,0x0F,0x07,0x00,

	0x20,0x60,0xC0,0x80,0xC0,0x60,0x20,0x00,  &#x2F;&#x2F; -x-
	0x08,0x0C,0x07,0x03,0x07,0x0C,0x08,0x00,

	0xE0,0xE0,0x00,0x00,0x00,0xE0,0xE0,0x00,  &#x2F;&#x2F; -y-
	0x47,0x4F,0x48,0x48,0x68,0x3F,0x1F,0x00,

	0x60,0x60,0x20,0xA0,0xE0,0x60,0x20,0x00,  &#x2F;&#x2F; -z-
	0x0C,0x0E,0x0B,0x09,0x08,0x0C,0x0C,0x00,

	0x00,0x40,0x40,0xF8,0xBC,0x04,0x04,0x00,  &#x2F;&#x2F; -&#123;-
	0x00,0x00,0x00,0x07,0x0F,0x08,0x08,0x00,

	0x00,0x00,0x00,0xBC,0xBC,0x00,0x00,0x00,  &#x2F;&#x2F; -|-
	0x00,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00,

	0x00,0x04,0x04,0xBC,0xF8,0x40,0x40,0x00,  &#x2F;&#x2F; -&#125;-
	0x00,0x08,0x08,0x0F,0x07,0x00,0x00,0x00,

	0x08,0x0C,0x04,0x0C,0x08,0x0C,0x04,0x00,  &#x2F;&#x2F; -~-
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x80,0xC0,0x60,0x30,0x60,0xC0,0x80,0x00,  &#x2F;&#x2F; --
	0x07,0x07,0x04,0x04,0x04,0x07,0x07,0x00,
&#125;;

# endif</code></pre>
<p>oled0561.c</p>
<ul>
<li>清屏</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204172202562.jpg" alt=""></p>
<ul>
<li><font color='pink'>OLED_DISPLAY_8x16( 6, 7*8, ‘-’ )</font> ：<font color='orange'>参数1</font>：显示在哪一行（也就是一个字符占了2行）	<font color='orange'>参数2</font>：显示在哪一列（7x8代表）	<font color='orange'>参数3</font>：要显示的内容（只能是一个字符）</li>
<li>所以想另一行显示需要每次跳过<font color='orange'>2行</font>因为一个字符占了<font color='cornflowerblue'>B0~B1</font></li>
<li>还有写入字符串需要<font color='orange'>空格+显示内容</font>一定一定是<font color='red'>16个字符</font>（不能多不能少，不显示的区域用空格代替，<font color='cornflowerblue'>空格占2个字符</font>）</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;oled0561.h&quot;
# include &quot;ASCII_8x16.h&quot; &#x2F;&#x2F;引入字体 ASCII


void OLED0561_Init (void) &#x2F;&#x2F;OLED屏开显示初始化
&#123;
    OLED_DISPLAY_OFF(); &#x2F;&#x2F;OLED关显示（因为一上电后屏幕显示寄存器处于混乱状态，数据也是混乱的显示内容也是混乱的）
    OLED_DISPLAY_CLEAR(); &#x2F;&#x2F;清空屏幕内容（把写入寄存器全部为0）
    OLED_DISPLAY_ON(); &#x2F;&#x2F;OLED屏初始值设置并开显示

&#125;

void OLED_DISPLAY_ON (void) &#x2F;&#x2F;OLED屏初始值设置并开显示
&#123;
    u8 buf[28] &#x3D;
    &#123;
        0xae,&#x2F;&#x2F;0xae:关显示，0xaf:开显示
        0x00, 0x10, &#x2F;&#x2F;开始地址（双字节）
        0xd5, 0x80, &#x2F;&#x2F;设置显示时钟分频比&#x2F;振荡器频率
        0xa8, 0x3f, &#x2F;&#x2F;设置多路复用率
        0xd3, 0x00, &#x2F;&#x2F;显示偏移
        0XB0,&#x2F;&#x2F;写入页位置（0xB0~7）
        0x40,&#x2F;&#x2F;设置显示起始行
        0x8d, 0x14, &#x2F;&#x2F;VCC电源
        0xa1,&#x2F;&#x2F;设置段重新映射
        0xc8,&#x2F;&#x2F;设置COM输出扫描方向
        0xda, 0x12, &#x2F;&#x2F;设置COM引脚硬件配置
        0x81, 0xff, &#x2F;&#x2F;对比度，指令：0x81，数据：0~255（255最高）
        0xd9, 0xf1, &#x2F;&#x2F;充电周期？
        0xdb, 0x30, &#x2F;&#x2F;VCC电压输出
        0x20, 0x00, &#x2F;&#x2F;水平寻址设置
        0xa4,&#x2F;&#x2F;0xa4:正常显示，0xa5:整体点亮
        0xa6,&#x2F;&#x2F;0xa6:正常显示，0xa7:反色显示
        0xaf&#x2F;&#x2F;0xae:关显示，0xaf:开显示
    &#125;; &#x2F;&#x2F;
    I2C_SAND_BUFFER(OLED0561_ADD, COM, buf, 28);
&#125;

void OLED_DISPLAY_OFF (void) &#x2F;&#x2F;OLED屏关显示
&#123;
    u8 buf[3] &#x3D;
    &#123;
        0xae,&#x2F;&#x2F;0xae:关显示，0xaf:开显示
        0x8d, 0x10 &#x2F;&#x2F;关闭VCC电源
    &#125;; 
    I2C_SAND_BUFFER(OLED0561_ADD, COM, buf, 3); &#x2F;&#x2F;3：字节数看上面数组大小
&#125;

void OLED_DISPLAY_LIT (u8 x) &#x2F;&#x2F;OLED屏亮度设置（0~255）
&#123;
    I2C_SAND_BYTE(OLED0561_ADD, COM, 0x81);
    I2C_SAND_BYTE(OLED0561_ADD, COM, x); &#x2F;&#x2F;亮度值
&#125;

void OLED_DISPLAY_CLEAR(void) &#x2F;&#x2F;清屏操作
&#123;
    u8 j, t;
    for(t &#x3D; 0xB0; t &lt; 0xB8; t++) 	&#x2F;&#x2F;设置起始页地址为0xB0
    &#123;
        I2C_SAND_BYTE(OLED0561_ADD, COM, t); 	&#x2F;&#x2F;页地址（从0xB0到0xB7）
        I2C_SAND_BYTE(OLED0561_ADD, COM, 0x10); &#x2F;&#x2F;起始列地址的高4位
        I2C_SAND_BYTE(OLED0561_ADD, COM, 0x00);	&#x2F;&#x2F;起始列地址的低4位
        for(j &#x3D; 0; j &lt; 132; j++) 	&#x2F;&#x2F;整页内容填充（其实是128，但是屏幕一共132只是可以显示的只有128）
        &#123;
            I2C_SAND_BYTE(OLED0561_ADD, DAT, 0x00);&#x2F;&#x2F;屏幕清0，注意这里是发送数据DAT不是指令COM（改成0xff整个屏幕都点亮）
        &#125;
    &#125;
&#125;

&#x2F;&#x2F;显示英文与数字8*16的ASCII码
&#x2F;&#x2F;取模大小为16*16，取模方式为“从左到右从上到下”“纵向8点下高位”
void OLED_DISPLAY_8x16(u8 x, &#x2F;&#x2F;显示英文与数字的页坐标（从0到7）（此处不可修改）
                       u8 y, &#x2F;&#x2F;显示英文与数字的列坐标（从0到127）
                       u16 w)  &#x2F;&#x2F;要显示英文与数字的编号
&#123;
    u8 j, t, c &#x3D; 0;
    y &#x3D; y + 2; &#x2F;&#x2F;因OLED屏的内置驱动芯片是从0x02列作为屏上最左一列，所以要加上偏移量
    for(t &#x3D; 0; t &lt; 2; t++)
    &#123;
        I2C_SAND_BYTE(OLED0561_ADD, COM, 0xb0 + x); &#x2F;&#x2F;页地址（从0xB0到0xB7）
        I2C_SAND_BYTE(OLED0561_ADD, COM, y &#x2F; 16 + 0x10); &#x2F;&#x2F;起始列地址的高4位是+0x10
        I2C_SAND_BYTE(OLED0561_ADD, COM, y % 16);	&#x2F;&#x2F;起始列地址的低4位是+0x00（省略了而已）
        for(j &#x3D; 0; j &lt; 8; j++) &#x2F;&#x2F;整页内容填充
        &#123;
            I2C_SAND_BYTE(OLED0561_ADD, DAT, ASCII_8x16[(w * 16) + c - 512]); &#x2F;&#x2F;为了和ASII表对应要减512
            c++;
        &#125;
        x++; &#x2F;&#x2F;页地址加1（因为字符是8x16像素首先是第1行显示然后再显示第2行这样刚刚好是16）
    &#125;
&#125;

&#x2F;&#x2F;向LCM发送一个字符串,长度64字符之内。
&#x2F;&#x2F;应用：OLED_DISPLAY_8_16_BUFFER(0,&quot; DoYoung Studio&quot;);
void OLED_DISPLAY_8x16_BUFFER(u8 row, u8 *str)
&#123;
    u8 r &#x3D; 0;
    while(*str !&#x3D; &#39;\0&#39;)
    &#123;
        OLED_DISPLAY_8x16(row, r * 8, *str++);&#x2F;&#x2F;每次移动为8列（因为一个字符占8x16）
        r++;
    &#125;
&#125;</code></pre>
<p>oled0561.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __OLED_H
# define __OLED_H	 
# include &quot;sys.h&quot;
# include &quot;i2c.h&quot;

# define OLED0561_ADD	0x78  &#x2F;&#x2F; OLED的I2C地址（禁止修改）
# define COM				0x00  &#x2F;&#x2F; OLED 指令（禁止修改）
# define DAT 			0x40  &#x2F;&#x2F; OLED 数据（禁止修改）

void OLED0561_Init(void);&#x2F;&#x2F;初始化
void OLED_DISPLAY_ON (void);&#x2F;&#x2F;OLED屏开显示
void OLED_DISPLAY_OFF (void);&#x2F;&#x2F;OLED屏关显示
void OLED_DISPLAY_LIT (u8 x);&#x2F;&#x2F;OLED屏亮度设置（0~255）
void OLED_DISPLAY_CLEAR(void);&#x2F;&#x2F;清屏操作
void OLED_DISPLAY_8x16(u8 x,u8 y,u16 w);&#x2F;&#x2F;显示8x16的单个字符 
void OLED_DISPLAY_8x16_BUFFER(u8 row,u8 *str);&#x2F;&#x2F;显示8x16的字符串

		 				    
# endif</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	温度值OLED屏显示程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;lm75a.h&quot;

# include &quot;oled0561.h&quot;

int main (void) &#x2F;&#x2F;主程序
&#123;
    u8 buffer[3];
    delay_ms(100); &#x2F;&#x2F;上电时等待其他器件就绪
    RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化

    I2C_Configuration();&#x2F;&#x2F;I2C初始化
    LM75A_GetTemp(buffer); &#x2F;&#x2F;读取LM75A的温度数据

    OLED0561_Init(); &#x2F;&#x2F;OLED初始化

    OLED_DISPLAY_8x16_BUFFER(0, &quot;   I LOVE YOU&quot;); &#x2F;&#x2F;显示字符串（空格加字符一定要是16个字符，不能少，空格占两个字符）
    OLED_DISPLAY_8x16_BUFFER(6, &quot;  Temp:&quot;); &#x2F;&#x2F;显示字符串

    while(1)
    &#123;
        LM75A_GetTemp(buffer); &#x2F;&#x2F;读取LM75A的温度数据

        if(buffer[0])OLED_DISPLAY_8x16(6, 7 * 8, &#39;-&#39;); &#x2F;&#x2F;如果第1组为1即是负温度
        OLED_DISPLAY_8x16(6, 8 * 8, buffer[1] &#x2F; 10 + 0x30); &#x2F;&#x2F;显示温度值
        OLED_DISPLAY_8x16(6, 9 * 8, buffer[1] % 10 + 0x30); &#x2F;&#x2F;
        OLED_DISPLAY_8x16(6, 10 * 8, &#39;.&#39;); &#x2F;&#x2F;
        OLED_DISPLAY_8x16(6, 11 * 8, buffer[2] &#x2F; 10 + 0x30); &#x2F;&#x2F;
        OLED_DISPLAY_8x16(6, 12 * 8, buffer[2] % 10 + 0x30); &#x2F;&#x2F;
        OLED_DISPLAY_8x16(6, 13 * 8, &#39;C&#39;); &#x2F;&#x2F;

        delay_ms(200); &#x2F;&#x2F;延时
    &#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204292241272.jpg" alt=""></p>
<h3 id="OLED屏汉字与图片显示程序">OLED屏汉字与图片显示程序</h3>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>Im75a.c，Im75a.h</font> 和 <font color='orange'>16</font> 相同； <font color='gree'>oled0561.c，oled0561.h</font> 在 <font color='orange'>17</font> 的基础上增加下面的东西（需要添加<font color='green'> ASCII_8x16.h</font>（字库）和 <font color='gree'>CHS_16x16.h（显示汉字），PIC1.h（显示图片）</font>）</p>
<p>oled0561.h 增加</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void OLED_DISPLAY_16x16(u8 x,u8 y,u16 w); &#x2F;&#x2F;汉字显示
void OLED_DISPLAY_PIC1(void);&#x2F;&#x2F;图片显示</code></pre>
<p>oled0561.c开头增加</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;CHS_16x16.h&quot; &#x2F;&#x2F;引入汉字字体 
# include &quot;PIC1.h&quot; &#x2F;&#x2F;引入图片</code></pre>
<p>oled0561.c在下面增加</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;----- 用于汉字显示的程序 ------&#x2F;&#x2F;

&#x2F;&#x2F;显示汉字16*16
&#x2F;&#x2F;取模大小为16*16，取模方式为“从左到右从上到下”“纵向8点下高位”
void OLED_DISPLAY_16x16(u8 x, &#x2F;&#x2F;显示汉字的页坐标（从0xB0到0xB7）
                        u8 y, &#x2F;&#x2F;显示汉字的列坐标（从0到63）
                        u16 w)  &#x2F;&#x2F;要显示汉字的编号
&#123;
    u8 j, t, c &#x3D; 0;
    for(t &#x3D; 0; t &lt; 2; t++)
    &#123;
        I2C_SAND_BYTE(OLED0561_ADD, COM, 0xb0 + x); &#x2F;&#x2F;页地址（从0xB0到0xB7）
        I2C_SAND_BYTE(OLED0561_ADD, COM, y &#x2F; 16 + 0x10); &#x2F;&#x2F;起始列地址的高4位
        I2C_SAND_BYTE(OLED0561_ADD, COM, y % 16);	&#x2F;&#x2F;起始列地址的低4位
        for(j &#x3D; 0; j &lt; 16; j++) &#x2F;&#x2F;整页内容填充
        &#123;
            I2C_SAND_BYTE(OLED0561_ADD, DAT, GB_16[(w * 32) + c]);
            c++;
        &#125;
        x++; &#x2F;&#x2F;页地址加1
    &#125;
    I2C_SAND_BYTE(OLED0561_ADD, COM, 0xAF); &#x2F;&#x2F;开显示
&#125;

void OLED_DISPLAY_PIC1(void)  &#x2F;&#x2F;显示全屏图片
&#123;
    u8 m, i;
    for(m &#x3D; 0; m &lt; 8; m++) &#x2F;&#x2F;
    &#123;
        I2C_SAND_BYTE(OLED0561_ADD, COM, 0xb0 + m);
        I2C_SAND_BYTE(OLED0561_ADD, COM, 0x10); &#x2F;&#x2F;起始列地址的高4位
        I2C_SAND_BYTE(OLED0561_ADD, COM, 0x02);	&#x2F;&#x2F;起始列地址的低4位
        for(i &#x3D; 0; i &lt; 128; i++) &#x2F;&#x2F;送入128次图片显示内容
        &#123;
            I2C_SAND_BYTE(OLED0561_ADD, DAT, PIC1[i + m * 128]);
        &#125;
    &#125;
&#125;</code></pre>
<p>显示图片的main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;lm75a.h&quot;

# include &quot;oled0561.h&quot;

int main(void)
&#123;
 	delay_ms(100); &#x2F;&#x2F;上电时等待其他器件就绪
    RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化
    I2C_Configuration();&#x2F;&#x2F;I2C初始化
    OLED0561_Init(); &#x2F;&#x2F;OLED初始化
    OLED_DISPLAY_LIT(100);&#x2F;&#x2F;亮度设置
    OLED_DISPLAY_PIC1();&#x2F;&#x2F;显示全屏图片
    delay_ms(1000); &#x2F;&#x2F;延时   
&#125;</code></pre>
<p>显示汉字的main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;lm75a.h&quot;

# include &quot;oled0561.h&quot;

int main(void)
&#123;
	u8 buffer[3];
	delay_ms(100); &#x2F;&#x2F;上电时等待其他器件就绪
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 

	I2C_Configuration();&#x2F;&#x2F;I2C初始化
    LM75A_GetTemp(buffer); &#x2F;&#x2F;读取LM75A的温度数据
    OLED0561_Init(); &#x2F;&#x2F;OLED初始化
    OLED_DISPLAY_8x16_BUFFER(0, &quot;   I LOVE YOU&quot;); &#x2F;&#x2F;显示字符串（空格加字符一定要是16个字符，不能少，空格占两个字符）
    OLED_DISPLAY_8x16_BUFFER(6, &quot;  Temp:&quot;); &#x2F;&#x2F;显示字符串
     OLED_DISPLAY_16x16(2,0*16,0);&#x2F;&#x2F;汉字显示	 广东理工职业学院
	OLED_DISPLAY_16x16(2,1*16,1);
	OLED_DISPLAY_16x16(2,2*16,2);
	OLED_DISPLAY_16x16(2,3*16,3);
	OLED_DISPLAY_16x16(2,4*16,4);
	OLED_DISPLAY_16x16(2,5*16,5);
	OLED_DISPLAY_16x16(2,6*16,6);
	OLED_DISPLAY_16x16(2,7*16,7);

    while(1)
    &#123;
        LM75A_GetTemp(buffer); &#x2F;&#x2F;读取LM75A的温度数据

        if(buffer[0])OLED_DISPLAY_8x16(6, 7 * 8, &#39;-&#39;); &#x2F;&#x2F;如果第1组为1即是负温度
        OLED_DISPLAY_8x16(6, 8 * 8, buffer[1] &#x2F; 10 + 0x30); &#x2F;&#x2F;显示温度值
        OLED_DISPLAY_8x16(6, 9 * 8, buffer[1] % 10 + 0x30); &#x2F;&#x2F;
        OLED_DISPLAY_8x16(6, 10 * 8, &#39;.&#39;); &#x2F;&#x2F;
        OLED_DISPLAY_8x16(6, 11 * 8, buffer[2] &#x2F; 10 + 0x30); &#x2F;&#x2F;
        OLED_DISPLAY_8x16(6, 12 * 8, buffer[2] % 10 + 0x30); &#x2F;&#x2F;
        OLED_DISPLAY_8x16(6, 13 * 8, &#39;C&#39;); &#x2F;&#x2F;

        delay_ms(200); &#x2F;&#x2F;延时
    &#125;

&#125;</code></pre>
<p>CHS_16x16.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __CHS_16x16_H
# define __CHS_16x16_H	 

uc8 GB_16[] &#x3D; &#123;         &#x2F;&#x2F; 数据表
	&#x2F;&#x2F;&quot;广&quot;
    0x00, 0x00, 0xFC, 0x04, 0x04, 0x04, 0x04, 0x05,
    0x06, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00,
    0x40, 0x30, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    &#x2F;&#x2F;&quot;东&quot;
    0x08, 0x08, 0x08, 0x88, 0x68, 0x18, 0x0F, 0xE8,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
    0x00, 0x40, 0x21, 0x11, 0x0D, 0x41, 0x81, 0x7F,
    0x01, 0x05, 0x09, 0x31, 0x61, 0x00, 0x00, 0x00,

    &#x2F;&#x2F;&quot;理&quot;
    0x44, 0x44, 0xFC, 0x44, 0x44, 0x00, 0xFE, 0x92,
    0x92, 0xFE, 0x92, 0x92, 0xFE, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x1F, 0x08, 0x48, 0x48, 0x44, 0x44,
    0x44, 0x7F, 0x44, 0x44, 0x44, 0x40, 0x40, 0x00,

    &#x2F;&#x2F;&quot;工&quot;
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0xFC,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3F,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,

    &#x2F;&#x2F;&quot;职&quot;
    0x02, 0x02, 0xFE, 0x92, 0x92, 0xFE, 0x02, 0x00,
    0xFC, 0x04, 0x04, 0x04, 0x04, 0xFC, 0x00, 0x00,
    0x08, 0x08, 0x0F, 0x08, 0x08, 0xFF, 0x04, 0x44,
    0x33, 0x0D, 0x01, 0x01, 0x0D, 0x33, 0x60, 0x00,

    &#x2F;&#x2F;&quot;业&quot;
    0x00, 0x10, 0x60, 0x80, 0x00, 0xFF, 0x00, 0x00,
    0x00, 0xFF, 0x00, 0x00, 0xC0, 0x30, 0x00, 0x00,
    0x40, 0x40, 0x40, 0x47, 0x40, 0x7F, 0x40, 0x40,
    0x40, 0x7F, 0x44, 0x43, 0x40, 0x40, 0x40, 0x00,

    &#x2F;&#x2F;&quot;学&quot;
    0x40, 0x30, 0x11, 0x96, 0x90, 0x90, 0x91, 0x96,
    0x90, 0x90, 0x98, 0x14, 0x13, 0x50, 0x30, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x84, 0x7E,
    0x06, 0x05, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00,

    &#x2F;&#x2F;&quot;院&quot;
    0x00, 0xFE, 0x22, 0x5A, 0x96, 0x0C, 0x24, 0x24,
    0x25, 0x26, 0x24, 0x24, 0x24, 0x04, 0x0C, 0x00,
    0x00, 0xFF, 0x04, 0x08, 0x87, 0x81, 0x41, 0x31,
    0x0F, 0x01, 0x3F, 0x41, 0x41, 0x41, 0x70, 0x00
&#125;;

# endif</code></pre>
<p>PIC1.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; Bitmap点阵数据表                                                    &#x2F;&#x2F;
&#x2F;&#x2F; 图片: E:\..萌∧246.bmp,纵向取模下高位,数据排列:从左到右从上到下   &#x2F;&#x2F;
&#x2F;&#x2F; 图片尺寸: 128 * 64                                                  &#x2F;&#x2F;
&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
uc8 PIC1[] &#x3D;                  &#x2F;&#x2F; 数据表
&#123;
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0xF8,0xFC,0x1C,0x38,0x30,0x38,0x1C,
      0xFC,0xF8,0x00,0xF8,0xF8,0x00,0xF8,0xF8,
      0x00,0x00,0x00,0xF8,0xFC,0x8C,0x8C,0x8C,
      0x00,0x80,0xD0,0x50,0xF0,0xE0,0x00,0xF0,
      0xF0,0x20,0x30,0x00,0x00,0x80,0x80,0x00,
      0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x0C,
      0x12,0x24,0x12,0x0C,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x18,0x24,0x44,0x88,
      0x44,0x24,0x18,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x03,0x83,0x80,0x00,0x80,0x80,0x00,
      0x03,0x03,0x00,0x08,0x0B,0x0B,0x0F,0x07,
      0x80,0x40,0x80,0x40,0x83,0x03,0x03,0x03,
      0x00,0x00,0x03,0x03,0x03,0x03,0x00,0x03,
      0x83,0x80,0x80,0x80,0x80,0xC3,0xC3,0xC0,
      0xC3,0xC3,0xC0,0xC3,0xC3,0xC0,0xC0,0xC0,
      0xC0,0xC0,0x80,0x80,0x80,0xC0,0xC0,0x40,
      0x20,0x18,0x04,0x03,0x00,0x00,0x00,0x00,
      0x00,0x20,0x50,0xA0,0x50,0x20,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x03,0x04,0x08,0x11,0x08,0x04,0x03,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x01,0x02,0x84,0xC2,0xE1,0x60,0x30,0x10,
      0x78,0xEC,0xFC,0xF6,0x3A,0x1B,0x05,0x85,
      0x97,0x13,0x12,0x13,0x13,0x11,0x11,0x11,
      0x11,0x11,0x11,0x01,0x81,0xFF,0xF9,0xF9,
      0xF2,0xC2,0x82,0x22,0x25,0x05,0x8D,0x8B,
      0x93,0xB3,0xE6,0xC6,0x8C,0x1C,0x18,0x38,
      0x70,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,
      0x00,0x00,0x00,0x18,0x24,0x48,0x24,0x18,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x80,0xE0,0xE0,0x70,0x30,0x18,
      0x18,0x1C,0x1C,0x1C,0x0C,0x1C,0x16,0x16,
      0x16,0x06,0x27,0x63,0x6D,0xAE,0xCE,0x0E,
      0x0E,0x0F,0x0F,0x0F,0x0E,0x06,0x06,0x07,
      0x07,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
      0x06,0x06,0x06,0x66,0x77,0x67,0x67,0xE7,
      0x07,0x07,0x07,0x06,0x06,0x06,0x07,0x07,
      0x87,0xC7,0x67,0x23,0x23,0x12,0x10,0x00,
      0x08,0x08,0x09,0x0B,0x0F,0x0E,0x0E,0x0C,
      0x3C,0x70,0xF0,0xC0,0x80,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xF8,
      0xDE,0xFF,0xF6,0x36,0x11,0xE0,0xF0,0xF8,
      0xFC,0xFE,0xDE,0x1E,0x3F,0x3F,0x1E,0xFE,
      0xFE,0xFC,0xF8,0xF2,0xE4,0x08,0x01,0x07,
      0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
      0x00,0x00,0x00,0x00,0x00,0x3C,0xFF,0xE7,
      0x31,0x1C,0xE6,0xFF,0xFF,0xFF,0xFE,0xFE,
      0x1F,0x3F,0x3F,0x1F,0xFF,0xFE,0xFE,0xFC,
      0xF8,0xF8,0xF0,0x31,0xFB,0xFF,0xFE,0xFC,
      0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
      0x07,0x4F,0x4C,0x60,0x60,0x7F,0x7F,0x7F,
      0x7F,0x7D,0x4D,0x44,0x72,0x72,0x40,0x79,
      0x7D,0x7F,0x7F,0x7F,0x7F,0x7C,0x70,0x70,
      0x73,0x73,0x70,0x70,0x74,0x74,0x74,0x74,
      0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,
      0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x73,
      0x70,0x70,0x72,0x72,0x72,0x73,0x70,0x70,
      0x70,0x7C,0x7F,0x7F,0x7F,0x7F,0x7D,0x7D,
      0x62,0x72,0x72,0x60,0x68,0x7D,0x7F,0x7F,
      0x7F,0x7F,0x77,0x74,0x67,0x67,0x63,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
&#125;;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204300003529.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204300003376.jpg" alt=""></p>
<h3 id="取模软件的使用">取模软件的使用</h3>
<p>在上面的 <font color='green'>ASCII_8x16.h，PIC1.h，CHS_16x16.h</font> 里面的数据都是通过<font color='orange'>取模软件生成的</font>（软件可在书签第一个内找）下面介绍如何使用：</p>
<ul>
<li>ASCII_8x16.h</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181831051.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181831722.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181831140.png","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<ul>
<li>CHS_16x16.h</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181838883.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181838069.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181838526.png","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<ul>
<li>PIC1.h</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181935894.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181935573.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181935965.png","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181935421.png","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<p><font color='red'>注：</font>把数组里面内容替换即可别把数组名也替换了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204181935843.png" alt=""></p>
<h2 id="继电器的原理与驱动程序">继电器的原理与驱动程序</h2>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>本节用到的固件库函数</p>
</div>
<ul>
<li>GPIO_PinRemapConfig（<font color='orange'>手册 10.2.16</font>）</li>
</ul>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>touch_key.c，touch_key.h</font> 与 <font color='orange'>13 </font>相同；只需增加<font color='green'> relay.c，relay.h</font> 即可</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181950442.jpg" style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204181950625.jpg" style="zoom:50%;" />
<p>继电器是一种自动控制开关，通常用在<font color='orange'>小电流电路控制大电流电路</font></p>
<p>应用：<font color='orange'>自动控制</font>（单片机领域），电气隔离，安全保护，转换电路</p>
<ul>
<li>通过控制 PA13，PA14端口，输出高电平时对应的继电器吸合，反之松开（和控制 LED 差不多）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204182054427.png" alt=""></p>
<ul>
<li><font color='orange'>上电时默认是 JTAG 模式</font>，需要关闭它才能用I/O模式</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204301325919.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204182058032.png" alt=""></p>
<ul>
<li>因为<font color='orange'>继电器的线圈需要很大的电流才能驱动</font>，单凭单片机 I/O口输出电平是无法驱动继电器的，所以要使用 ULN2003芯片，将单片机端口连接芯片输入端，则输出端就可以输出很大电流</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204301312740.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204182051530.jpg" alt=""></p>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>ULN2003 芯片</p>
</div>
<p>ULN2003 是<font color='orange'>高耐压、大电流达林顿陈列</font>，由七个硅NPN 达林顿管组成。ULN2003 <font color='orange'>工作电压高，工作电流大，灌电流可达500mA，并且能够在关态时承受50V 的电压，输出还可以在高负载电流并行运行</font>。</p>
<p><code>in</code>：输入	<code>out</code>：输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204182100574.jpg" alt=""></p>
<ul>
<li>XQ：线圈（线圈不分正负极只要有电流通过就可以吸合）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204301405827.jpg" alt=""></p>
<p>relay.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __RELAY_H
# define __RELAY_H	 
# include &quot;sys.h&quot;


# define RELAYPORT	GPIOA	&#x2F;&#x2F;定义IO接口
# define RELAY1	GPIO_Pin_14	&#x2F;&#x2F;定义IO接口
# define RELAY2	GPIO_Pin_13	&#x2F;&#x2F;定义IO接口



void RELAY_Init(void);&#x2F;&#x2F;继电器初始化
void RELAY_1(u8 c);&#x2F;&#x2F;继电器控制1
void RELAY_2(u8 c);&#x2F;&#x2F;继电器控制2
		 				    
# endif</code></pre>
<p>relay.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*
注意：
本程序所占用的GPIO接口PA13、PA14上电后为JTAG功能，
需要在RCC程序里启动AFIO时钟，再在RELAY_Init函数里加入：
GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);
&#x2F;&#x2F; 改变指定管脚的映射,完全禁用JTAG+SW-DP才能将JATG接口重定义为GPIO

*&#x2F;


# include &quot;relay.h&quot;

void RELAY_Init(void)  &#x2F;&#x2F;继电器的接口初始化
&#123;
    GPIO_InitTypeDef  GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE); &#x2F;&#x2F;APB2外设时钟使能
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);&#x2F;&#x2F;启动AFIO重映射功能时钟
    GPIO_InitStructure.GPIO_Pin &#x3D; RELAY1 | RELAY2; &#x2F;&#x2F;选择端口号（0~15或all）
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_Out_PP; &#x2F;&#x2F;选择IO接口工作方式
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz; &#x2F;&#x2F;设置IO接口速度（2&#x2F;10&#x2F;50MHz）
    GPIO_Init(RELAYPORT, &amp;GPIO_InitStructure);
    &#x2F;&#x2F;必须将禁用JTAG功能才能做GPIO使用
    GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);&#x2F;&#x2F; 改变指定管脚的映射,完全禁用JTAG+SW-DP
    GPIO_ResetBits(RELAYPORT, RELAY1 | RELAY2); &#x2F;&#x2F;都为低电平（0） 初始为关继电器
&#125;

void RELAY_1(u8 c)  &#x2F;&#x2F;继电器的控制程序（c&#x3D;0继电器放开，c&#x3D;1继电器吸合）
&#123;
    GPIO_WriteBit(RELAYPORT, RELAY1, (BitAction)(c)); &#x2F;&#x2F;通过参数值写入接口
&#125;
void RELAY_2(u8 c)  &#x2F;&#x2F;继电器的控制程序（c&#x3D;0继电器放开，c&#x3D;1继电器吸合）
&#123;
    GPIO_WriteBit(RELAYPORT, RELAY2, (BitAction)(c)); &#x2F;&#x2F;通过参数值写入接口
&#125;</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	按键控制继电器程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;touch_key.h&quot;

# include &quot;relay.h&quot;

int main (void)&#123;&#x2F;&#x2F;主程序
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	TOUCH_KEY_Init();&#x2F;&#x2F;触摸按键初始化

	RELAY_Init();&#x2F;&#x2F;继电器初始化

	while(1)&#123;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))
            RELAY_1(1); &#x2F;&#x2F;当按键A按下时继电器1标志置位		
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))
            RELAY_1(0); &#x2F;&#x2F;当按键B按下时继电器1标志置位		
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))
            RELAY_2(1); &#x2F;&#x2F;当按键C按下时继电器2标志置位
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))
            RELAY_2(0); &#x2F;&#x2F;当按键D按下时继电器2标志置位
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=981208725&bvid=BV1f44y1M7fY&cid=588615996&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
<h2 id="步进电机的原理与驱动程序">步进电机的原理与驱动程序</h2>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>touch_key.c，touch_key.h</font> 与 <font color='orange'>13 </font>相同；<font color='green'> relay.c，relay.h</font> 和 <font color='orange'>18 </font>相同，只需增加 <font color='green'>step_motor.c，step_motor.h</font></p>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204182134698.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204182134173.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204301921783.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204182159812.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<ul>
<li>因为单片机 I/O口不能输出很大的驱动电流，无法直接带动步进电机，所以通过<font color='cornflowerblue'> ULN2003L</font> 芯片输出强大电流带动步进电机</li>
<li>型号：28BJY48  (<font color='orange'>28</font>表示电机直径28毫米,<font color='orange'>B</font>表示步进电机，<font color='orange'>Y</font>表示永磁,<font color='orange'>J</font>表示带减速箱,<font color='orange'>48</font>表示可以<font color='cornflowerblue'>四拍和八拍运行</font>。)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204182201352.jpg" alt=""></p>
<ul>
<li><font color='orange'>4拍的顺序图</font></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204182150643.jpg" alt=""></p>
<ul>
<li><font color='orange'>8拍的顺序图</font></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204182159508.jpg" alt=""></p>
<p>具体步进电机信息可查看 <font color='pink'>51单片机~步进电机</font> 文章</p>
<p><font color='red'>步进电机的重要说明:</font></p>
<ul>
<li>不同型号的步进电机有不同的驱动电压，使用前要确定标称电压。</li>
<li>步进电机停转时<font color='orange'>不能给线圈长时间通电，会导致电机发热损坏</font>。</li>
<li>除4步、8步驱动方式外，还可用专用步进驱动器做最大256倍的精细角度驱动。</li>
<li><font color='cornflowerblue'>步进电机的扭矩（力度）是与电流相关的。旋转速度是与切换时间相关的。</font></li>
</ul>
<p>step_motor.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __STEP_MOTOR_H
# define __STEP_MOTOR_H	 
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;

extern u8 STEP; &#x2F;&#x2F;定义单步计数 全局变量

# define STEP_MOTOR_PORT	GPIOB	&#x2F;&#x2F;定义IO接口所在组
# define STEP_MOTOR_A	GPIO_Pin_3	&#x2F;&#x2F;定义IO接口
# define STEP_MOTOR_B	GPIO_Pin_4	&#x2F;&#x2F;定义IO接口
# define STEP_MOTOR_C	GPIO_Pin_8	&#x2F;&#x2F;定义IO接口
# define STEP_MOTOR_D	GPIO_Pin_9	&#x2F;&#x2F;定义IO接口



void STEP_MOTOR_Init(void);&#x2F;&#x2F;初始化
void STEP_MOTOR_OFF (void);&#x2F;&#x2F;断电状态
void STEP_MOTOR_8A (u8 a,u16 speed);
void STEP_MOTOR_NUM (u8 RL,u16 num,u8 speed);&#x2F;&#x2F;电机按步数运行
void STEP_MOTOR_LOOP (u8 RL,u8 LOOP,u8 speed);&#x2F;&#x2F;电机按圈数运行


		 				    
# endif</code></pre>
<p>step_motor.c</p>
<ul>
<li>单步8拍</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204302020305.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/202204302057663.jpg" alt=""></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;step_motor.h&quot;

u8 STEP; 


void STEP_MOTOR_Init(void)&#123; &#x2F;&#x2F;接口初始化
	GPIO_InitTypeDef  GPIO_InitStructure; 	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE); &#x2F;&#x2F;APB2外设GPIO时钟使能      
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);&#x2F;&#x2F;启动AFIO重映射功能时钟    
    GPIO_InitStructure.GPIO_Pin &#x3D; STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D; &#x2F;&#x2F;选择端口                        
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_Out_PP; &#x2F;&#x2F;选择IO接口工作方式       
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz; &#x2F;&#x2F;设置IO接口速度（2&#x2F;10&#x2F;50MHz）    
	GPIO_Init(STEP_MOTOR_PORT, &amp;GPIO_InitStructure);
	&#x2F;&#x2F;必须将禁用JTAG功能才能做GPIO使用
	GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);&#x2F;&#x2F; 改变指定管脚的映射,完全禁用JTAG+SW-DP	
	STEP_MOTOR_OFF(); &#x2F;&#x2F;初始状态是断电状态 			
&#125;

void STEP_MOTOR_OFF (void)&#123;&#x2F;&#x2F;电机断电
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;各接口置0
&#125;

void STEP_MOTOR_8A (u8 a,u16 speed)&#123;&#x2F;&#x2F;电机单步8拍
	switch (a)&#123;
		case 0:
		GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0（B,C,D不通电）
		GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A);&#x2F;&#x2F;1（给A通电）
			break;
		case 1:
		GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
		GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;1
			break;
		case 2:
		GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
		GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B);&#x2F;&#x2F;1
			break;
		case 3:
		GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;0
		GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;1
			break;
		case 4:
		GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_D);&#x2F;&#x2F;0
		GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_C);&#x2F;&#x2F;1
			break;
		case 5:
		GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;0
		GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;1
			break;
		case 6:
		GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;0
		GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_D);&#x2F;&#x2F;1
			break;
		case 7:
		GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;0
		GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;1
			break;
		default:
			break;
	&#125;
	delay_ms(speed); &#x2F;&#x2F;延时
	STEP_MOTOR_OFF(); &#x2F;&#x2F;进入断电状态，防电机过热
&#125;

void STEP_MOTOR_NUM (u8 RL,u16 num,u8 speed)&#123;&#x2F;&#x2F;电机按步数运行
	u16 i;
	for(i&#x3D;0;i&lt;num;i++)&#123;	
		if(RL&#x3D;&#x3D;1)&#123; &#x2F;&#x2F;当RL&#x3D;1右转，RL&#x3D;0左转
			STEP++;
			if(STEP&gt;7)STEP&#x3D;0;
		&#125;else&#123;
			if(STEP&#x3D;&#x3D;0)STEP&#x3D;8;
			STEP--;
		&#125;
		STEP_MOTOR_8A(STEP,speed);
	&#125;
&#125;

void STEP_MOTOR_LOOP (u8 RL,u8 LOOP,u8 speed)&#123;&#x2F;&#x2F;电机按圈数运行
	STEP_MOTOR_NUM(RL,LOOP*4076,speed); &#x2F;&#x2F;具体数值需要自己测试，一圈刚刚好是4076
&#125;</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	步进电机步数控制程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;touch_key.h&quot;
# include &quot;relay.h&quot;

# include &quot;step_motor.h&quot;

int main (void)&#123;&#x2F;&#x2F;主程序
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	TOUCH_KEY_Init();&#x2F;&#x2F;触摸按键初始化
	RELAY_Init();&#x2F;&#x2F;继电器初始化

	STEP_MOTOR_Init();&#x2F;&#x2F;步进电机初始化

	while(1)&#123;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))
            STEP_MOTOR_LOOP(0,1,3); &#x2F;&#x2F; 按圈数左转 参1:RL,参2:LOOP	,参3:speed（值越小速度越快不能为0不然不会动）
        
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))
            STEP_MOTOR_LOOP(1,1,3); &#x2F;&#x2F;按圈数右转	
        
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))
            STEP_MOTOR_NUM(0,100,3); &#x2F;&#x2F;按步数左转 参1:RL,参2:num,参3:speed
        
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))
            STEP_MOTOR_NUM(1,100,3); &#x2F;&#x2F;按步数右转 参1:RL,参2:num,参3:speed
        
		else STEP_MOTOR_OFF();&#x2F;&#x2F;当没有按键时步进电机断电
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=256199447&bvid=BV12Y411w7rs&cid=588880736&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
<h3 id="按键控制步进电机程序">按键控制步进电机程序</h3>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>touch_key.c，touch_key.h</font> 与 <font color='orange'>13 </font>相同；<font color='green'> relay.c，relay.h</font> 和 <font color='orange'>18 </font>相同，只需增加 <font color='green'>step_motor.c，step_motor.h</font></p>
<p>step_motor.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __STEP_MOTOR_H
# define __STEP_MOTOR_H	 
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;


# define STEP_MOTOR_PORT	GPIOB	&#x2F;&#x2F;定义IO接口所在组
# define STEP_MOTOR_A	GPIO_Pin_3	&#x2F;&#x2F;定义IO接口
# define STEP_MOTOR_B	GPIO_Pin_4	&#x2F;&#x2F;定义IO接口
# define STEP_MOTOR_C	GPIO_Pin_8	&#x2F;&#x2F;定义IO接口
# define STEP_MOTOR_D	GPIO_Pin_9	&#x2F;&#x2F;定义IO接口



void STEP_MOTOR_Init(void);&#x2F;&#x2F;初始化
void STEP_MOTOR_OFF (void);&#x2F;&#x2F;断电状态
void STEP_MOTOR_4S (u8 speed);&#x2F;&#x2F;固定位置（制动）
void STEP_MOTOR_4R (u8 speed);&#x2F;&#x2F;
void STEP_MOTOR_4L (u8 speed);
void STEP_MOTOR_8R (u8 speed);
void STEP_MOTOR_8L (u8 speed);


		 				    
# endif</code></pre>
<p>step_motor.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;step_motor.h&quot;

 


void STEP_MOTOR_Init(void)&#123; &#x2F;&#x2F;LED灯的接口初始化
	GPIO_InitTypeDef  GPIO_InitStructure; 	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE, ENABLE); &#x2F;&#x2F;APB2外设GPIO时钟使能      
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);&#x2F;&#x2F;启动AFIO重映射功能时钟    
    GPIO_InitStructure.GPIO_Pin &#x3D; STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D; &#x2F;&#x2F;选择端口                        
    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_Out_PP; &#x2F;&#x2F;选择IO接口工作方式       
    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz; &#x2F;&#x2F;设置IO接口速度（2&#x2F;10&#x2F;50MHz）    
	GPIO_Init(STEP_MOTOR_PORT, &amp;GPIO_InitStructure);
	&#x2F;&#x2F;必须将禁用JTAG功能才能做GPIO使用
	GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);&#x2F;&#x2F; 改变指定管脚的映射,完全禁用JTAG+SW-DP	
	STEP_MOTOR_OFF(); &#x2F;&#x2F;初始状态是断电状态 			
&#125;

void STEP_MOTOR_OFF (void)&#123;&#x2F;&#x2F;电机断电
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;各接口置0
&#125;

void STEP_MOTOR_4S (u8 speed)&#123;&#x2F;&#x2F;电机固定位置
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A| STEP_MOTOR_C);	&#x2F;&#x2F;各接口置0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_D); &#x2F;&#x2F;各接口置1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D);
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_C); &#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D);
	delay_ms(speed); &#x2F;&#x2F;延时
	STEP_MOTOR_OFF(); &#x2F;&#x2F;进入断电状态，防电机过热
&#125;

void STEP_MOTOR_4R (u8 speed)&#123;&#x2F;&#x2F;电机顺时针，4拍，速度快，力小
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A| STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	STEP_MOTOR_OFF(); &#x2F;&#x2F;进入断电状态，防电机过热
&#125;

void STEP_MOTOR_4L (u8 speed)&#123;&#x2F;&#x2F;电机逆时针，4拍，速度快，力小
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	STEP_MOTOR_OFF(); &#x2F;&#x2F;进入断电状态，防电机过热
&#125;


void STEP_MOTOR_8R (u8 speed)&#123;&#x2F;&#x2F;电机顺时针，8拍，角度小，速度慢，力大
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_C);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	STEP_MOTOR_OFF(); &#x2F;&#x2F;进入断电状态，防电机过热
&#125;

void STEP_MOTOR_8L (u8 speed)&#123;&#x2F;&#x2F;电机逆时针，8拍，角度小，速度慢，力大
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_C);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_B);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_B);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C | STEP_MOTOR_D);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	GPIO_ResetBits(STEP_MOTOR_PORT,STEP_MOTOR_B | STEP_MOTOR_C);&#x2F;&#x2F;0
	GPIO_SetBits(STEP_MOTOR_PORT,STEP_MOTOR_A | STEP_MOTOR_D);&#x2F;&#x2F;1
	delay_ms(speed); &#x2F;&#x2F;延时
	STEP_MOTOR_OFF(); &#x2F;&#x2F;进入断电状态，防电机过热
&#125;</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	按键控制步进电机程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  						
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;touch_key.h&quot;
# include &quot;relay.h&quot;

# include &quot;step_motor.h&quot;

int main (void)&#123;&#x2F;&#x2F;主程序
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	TOUCH_KEY_Init();&#x2F;&#x2F;触摸按键初始化
	RELAY_Init();&#x2F;&#x2F;继电器初始化

	STEP_MOTOR_Init();&#x2F;&#x2F;步进电机初始化

	while(1)&#123;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))STEP_MOTOR_4R(3); &#x2F;&#x2F;当按键A按下时步进电机4步右转		
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))STEP_MOTOR_4L(3); &#x2F;&#x2F;当按键B按下时步进电机4步左转		
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))STEP_MOTOR_8R(3); &#x2F;&#x2F;当按键C按下时步进电机8步右转
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))STEP_MOTOR_8L(3); &#x2F;&#x2F;当按键D按下时步进电机8步左转
		else STEP_MOTOR_OFF();&#x2F;&#x2F;当没有按键时步进电机断电
	&#125;
&#125;</code></pre>
<h2 id="RS232-原理与驱动程序">RS232 原理与驱动程序</h2>
<p><font color='green'>sys.h，sys.c，delay.c，delay.h</font> 和 <font color='orange'>10 </font>一样；<font color='green'>touch_key.c，touch_key.h</font> 与 <font color='orange'>13 </font>相同；<font color='green'> relay.c，relay.h</font> 和 <font color='orange'>18 </font>相同；<font color='green'>oled0561.c，oled0561.h</font> 和 <font color='orange'>17</font> 相同；只需更改一下<font color='green'> usart.c，usart.h</font></p>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190920400.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190920496.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190920508.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<ul>
<li>如果没有RS232的线可以用<font color='orange'>杜邦线</font>代替实验，只需把上方第二针和第三针短接（<font color='orange'>RX 和 TX</font>）</li>
</ul>
<div class="gallery">
    <div class="fj-gallery " data-rowHeight="220" data-limit="10">
    <span class="gallery-data">[{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190939139.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202205010451213.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202205010451321.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190939321.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190939675.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190942882.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190947605.jpg","alt":""},{"url":"https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/202204190948610.jpg","alt":""}]</span>
    </div>
    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>
    </div>
<p>usart.h</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># ifndef __USART_H
# define __USART_H
# include &lt;stdarg.h&gt;
# include &lt;stdlib.h&gt;
# include &lt;string.h&gt;
# include &quot;stdio.h&quot;	
# include &quot;sys.h&quot; 


# define USART_n		USART1  &#x2F;&#x2F;定义使用printf函数的串口，其他串口要使用USART_printf专用函数发送

# define USART1_REC_LEN  			200  	&#x2F;&#x2F;定义USART1最大接收字节数
# define USART2_REC_LEN  			200  	&#x2F;&#x2F;定义USART2最大接收字节数
# define USART3_REC_LEN  			200  	&#x2F;&#x2F;定义USART3最大接收字节数

&#x2F;&#x2F;不使用某个串口时要禁止此串口，以减少编译量
# define EN_USART1 			1		&#x2F;&#x2F;使能（1）&#x2F;禁止（0）串口1
# define EN_USART2 			0		&#x2F;&#x2F;使能（1）&#x2F;禁止（0）串口2
# define EN_USART3 			1		&#x2F;&#x2F;使能（1）&#x2F;禁止（0）串口3
	  	
extern u8  USART1_RX_BUF[USART1_REC_LEN]; &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.末字节为换行符 
extern u8  USART2_RX_BUF[USART2_REC_LEN]; &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.末字节为换行符
extern u8  USART3_RX_BUF[USART3_REC_LEN]; &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.末字节为换行符
 
extern u16 USART1_RX_STA;         		&#x2F;&#x2F;接收状态标记	
extern u16 USART2_RX_STA;         		&#x2F;&#x2F;接收状态标记	
extern u16 USART3_RX_STA;         		&#x2F;&#x2F;接收状态标记	

&#x2F;&#x2F;函数声明
void USART1_Init(u32 bound);&#x2F;&#x2F;串口1初始化并启动
void USART2_Init(u32 bound);&#x2F;&#x2F;串口2初始化并启动
void USART3_Init(u32 bound);&#x2F;&#x2F;串口3初始化并启动
void USART1_printf(char* fmt,...); &#x2F;&#x2F;串口1的专用printf函数
void USART2_printf(char* fmt,...); &#x2F;&#x2F;串口2的专用printf函数
void USART3_printf(char* fmt,...); &#x2F;&#x2F;串口3的专用printf函数

# endif</code></pre>
<p>usart.c</p>
<ul>
<li>因为使用的是串口3所以我把其他串口的函数删除只留下串口3的</li>
<li>RS232通常遵循“<font color='cornflowerblue'>96-N-8-1</font>”格式，96指波特率9600，N指无校验，8指8bits数据位，1指1bit停止位</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &quot;sys.h&quot;
# include &quot;usart.h&quot;
	  	 
&#x2F;&#x2F;使UASRT串口可用printf函数发送
&#x2F;&#x2F;在usart.h文件里可更换使用printf函数的串口号	  
# if 1
# pragma import(__use_no_semihosting)             
&#x2F;&#x2F;标准库需要的支持函数                 
struct __FILE &#123;
	int handle; 
&#125;; 
FILE __stdout;       
&#x2F;&#x2F;定义_sys_exit()以避免使用半主机模式    
_sys_exit(int x)&#123; 
	x &#x3D; x; 
&#125; 
&#x2F;&#x2F;重定义fputc函数 
int fputc(int ch, FILE *f)&#123;      
	while((USART_n-&gt;SR&amp;0X40)&#x3D;&#x3D;0);&#x2F;&#x2F;循环发送,直到发送完毕   
    USART_n-&gt;DR &#x3D; (u8) ch;      
	return ch;
&#125;
# endif 

# if EN_USART3   &#x2F;&#x2F;如果使能了接收
u8 USART3_RX_BUF[USART3_REC_LEN];     &#x2F;&#x2F;接收缓冲,最大USART_REC_LEN个字节.
&#x2F;&#x2F;接收状态
&#x2F;&#x2F;bit15，	接收完成标志
&#x2F;&#x2F;bit14，	接收到0x0d
&#x2F;&#x2F;bit13~0，	接收到的有效字节数目
u16 USART3_RX_STA&#x3D;0;       &#x2F;&#x2F;接收状态标记	  

&#x2F;*
USART3专用的printf函数
当同时开启2个以上串口时，printf函数只能用于其中之一，其他串口要自创独立的printf函数
调用方法：USART3_printf(&quot;123&quot;); &#x2F;&#x2F;向USART3发送字符123
*&#x2F;
void USART3_printf (char *fmt, ...)&#123; 
	char buffer[USART3_REC_LEN+1];  &#x2F;&#x2F; 数据长度
	u8 i &#x3D; 0;	
	va_list arg_ptr;
	va_start(arg_ptr, fmt);  
	vsnprintf(buffer, USART3_REC_LEN+1, fmt, arg_ptr);
	while ((i &lt; USART3_REC_LEN) &amp;&amp; (i &lt; strlen(buffer)))&#123;
        USART_SendData(USART3, (u8) buffer[i++]);
        while (USART_GetFlagStatus(USART3, USART_FLAG_TC) &#x3D;&#x3D; RESET); 
	&#125;
	va_end(arg_ptr);
&#125;

void USART3_Init(u32 BaudRate)&#123; &#x2F;&#x2F;USART3初始化并启动
   GPIO_InitTypeDef GPIO_InitStructure;
   USART_InitTypeDef USART_InitStructure;
   NVIC_InitTypeDef NVIC_InitStructure; 

   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE); &#x2F;&#x2F;使能UART3所在GPIOB的时钟
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE); &#x2F;&#x2F;使能串口的RCC时钟

   &#x2F;&#x2F;串口使用的GPIO口配置
   GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_11;&#x2F;&#x2F;设置USART3的RX接口是PB11
   GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IN_FLOATING;&#x2F;&#x2F;接口模式 浮空输入
   GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

   GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_10;&#x2F;&#x2F;设置USART3的TX接口是PB10
   GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz;&#x2F;&#x2F;输出速度50MHz
   GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_AF_PP;&#x2F;&#x2F;接口模式 复用推挽输出
   GPIO_Init(GPIOB, &amp;GPIO_InitStructure);

   &#x2F;&#x2F;配置串口
   USART_InitStructure.USART_BaudRate &#x3D; BaudRate;
   USART_InitStructure.USART_WordLength &#x3D; USART_WordLength_8b;&#x2F;&#x2F;字长为8位数据格式
   USART_InitStructure.USART_StopBits &#x3D; USART_StopBits_1;&#x2F;&#x2F;一个停止位
   USART_InitStructure.USART_Parity &#x3D; USART_Parity_No;&#x2F;&#x2F;无奇偶校验位
   USART_InitStructure.USART_HardwareFlowControl &#x3D; USART_HardwareFlowControl_None;&#x2F;&#x2F;无硬件数据流控制
   USART_InitStructure.USART_Mode &#x3D; USART_Mode_Rx | USART_Mode_Tx;	&#x2F;&#x2F;收发模式

   USART_Init(USART3, &amp;USART_InitStructure);&#x2F;&#x2F;配置串口3
   USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);&#x2F;&#x2F;使能串口接收中断  
   &#x2F;&#x2F;USART_ITConfig(USART3, USART_IT_TXE, ENABLE);&#x2F;&#x2F;串口发送中断在发送数据时开启
   USART_Cmd(USART3, ENABLE);&#x2F;&#x2F;使能串口3

   &#x2F;&#x2F;串口中断配置
   NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
   NVIC_InitStructure.NVIC_IRQChannel &#x3D; USART3_IRQn;&#x2F;&#x2F;允许USART3中断
   NVIC_InitStructure.NVIC_IRQChannelSubPriority &#x3D; 0;&#x2F;&#x2F;中断等级
   NVIC_InitStructure.NVIC_IRQChannelCmd &#x3D; ENABLE;
   NVIC_Init(&amp;NVIC_InitStructure);
&#125;

&#x2F;&#x2F;串口3中断服务程序（固定的函数名不能修改）
void USART3_IRQHandler(void)&#123; 	
	&#x2F;&#x2F;这里没有用中断，所以上面 USART_ITConfig是 DISABLE
&#125;
# endif	
</code></pre>
<p>main.c</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*********************************************************************************************
程序名：	RS232通信测试程序
硬件支持：	STM32F103C8   外部晶振8MHz RCC函数设置主频72MHz　  							
说明：
 # 本模板加载了STM32F103内部的RCC时钟设置，并加入了利用滴答定时器的延时函数。
 # 可根据自己的需要增加或删减。

*********************************************************************************************&#x2F;
# include &quot;stm32f10x.h&quot; &#x2F;&#x2F;STM32头文件
# include &quot;sys.h&quot;
# include &quot;delay.h&quot;
# include &quot;touch_key.h&quot;
# include &quot;relay.h&quot;
# include &quot;oled0561.h&quot;

# include &quot;usart.h&quot;


int main (void)&#123;&#x2F;&#x2F;主程序
	u8 a;
	delay_ms(100); &#x2F;&#x2F;上电时等待其他器件就绪
	RCC_Configuration(); &#x2F;&#x2F;系统时钟初始化 
	TOUCH_KEY_Init();&#x2F;&#x2F;触摸按键初始化
	RELAY_Init();&#x2F;&#x2F;继电器初始化

	I2C_Configuration();&#x2F;&#x2F;I2C初始化
	OLED0561_Init(); &#x2F;&#x2F;OLED初始化
	OLED_DISPLAY_8x16_BUFFER(0,&quot;   YoungTalk &quot;); &#x2F;&#x2F;显示字符串
	OLED_DISPLAY_8x16_BUFFER(2,&quot;  RS232 TEST &quot;); &#x2F;&#x2F;显示字符串
	OLED_DISPLAY_8x16_BUFFER(6,&quot;TX:    RX:   &quot;); &#x2F;&#x2F;显示字符串

	USART3_Init(115200);&#x2F;&#x2F;串口3初始化并启动

	while(1)&#123;
		if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_A))&#123;USART3_printf(&quot;%c&quot;,&#39;A&#39;);OLED_DISPLAY_8x16(6,4*8,&#39;A&#39;);&#125; &#x2F;&#x2F;向RS232串口发送字符并在OLED上显示		
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_B))&#123;USART3_printf(&quot;%c&quot;,&#39;B&#39;);OLED_DISPLAY_8x16(6,4*8,&#39;B&#39;);&#125; &#x2F;&#x2F;向RS232串口发送字符并在OLED上显示		
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_C))&#123;USART3_printf(&quot;%c&quot;,&#39;C&#39;);OLED_DISPLAY_8x16(6,4*8,&#39;C&#39;);&#125; &#x2F;&#x2F;向RS232串口发送字符并在OLED上显示
		else if(!GPIO_ReadInputDataBit(TOUCH_KEYPORT,TOUCH_KEY_D))&#123;USART3_printf(&quot;%c&quot;,&#39;D&#39;);OLED_DISPLAY_8x16(6,4*8,&#39;D&#39;);&#125; &#x2F;&#x2F;向RS232串口发送字符并在OLED上显示

		&#x2F;&#x2F;查询方式接收
		if(USART_GetFlagStatus(USART3,USART_FLAG_RXNE) !&#x3D; RESET)&#123;  &#x2F;&#x2F;查询串口待处理标志位
			a &#x3D;USART_ReceiveData(USART3);&#x2F;&#x2F;读取接收到的数据
			OLED_DISPLAY_8x16(6,11*8,a);&#x2F;&#x2F;在OLED上显示
		&#125;
	&#125;
&#125;</code></pre>
<div class="note blue icon-padding flat"><i class="note-icon fas fa-fan"></i><p>实验现象</p>
</div>
<div class="video-bilibili">
  <iframe
    src="https://player.bilibili.com/player.html?aid=981134640&bvid=BV1M44y137uu&cid=589211693&page=1"
    scrolling="no"
    border="0"
    frameborder="no"
    framespacing="0"
    high_quality="1"
    danmaku="1"
    allowfullscreen="true"
  ></iframe>
</div>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/I2C/">I2C</a><a class="post-meta__tags" href="/tags/%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/">步进电机</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E7%A0%81%E7%AE%A1/">数码管</a><a class="post-meta__tags" href="/tags/%E5%85%A5%E9%97%A8100%E6%AD%A5/">入门100步</a><a class="post-meta__tags" href="/tags/STM32F1/">STM32F1</a><a class="post-meta__tags" href="/tags/USART/">USART</a><a class="post-meta__tags" href="/tags/RTC/">RTC</a><a class="post-meta__tags" href="/tags/%E8%A7%A6%E6%91%B8%E6%8C%89%E9%94%AE/">触摸按键</a><a class="post-meta__tags" href="/tags/%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8/">旋转编码器</a><a class="post-meta__tags" href="/tags/OLED/">OLED</a><a class="post-meta__tags" href="/tags/%E7%BB%A7%E7%94%B5%E5%99%A8/">继电器</a><a class="post-meta__tags" href="/tags/RS232/">RS232</a></div><div class="post_share"><div class="social-share" data-image="/img/num51.webp" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#USART-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">USART 驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">发送程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">接收程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART-%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">USART 控制程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E7%BB%88%E7%AB%AF%E4%B8%B2%E5%8F%A3%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">超级终端串口控制程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTC%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">RTC原理与驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E6%97%A5%E5%8E%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">超级终端显示日历程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E6%8C%89%E9%94%AE%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A9%B1%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text">触摸按键的原理与驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E5%8F%8C%E5%87%BB%E5%92%8C%E9%95%BF%E6%8C%89"><span class="toc-number">3.1.</span> <span class="toc-text">按键双击和长按</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E6%8C%89%E9%94%AE%E6%BB%91%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">触摸按键滑动程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">数码管原理与驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A9%B1%E5%8A%A8"><span class="toc-number">5.</span> <span class="toc-text">旋转编码器原理与驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C%E6%80%BB%E7%BA%BF%E4%B9%8B%E8%AF%BB%E5%8F%96%E6%B8%A9%E5%BA%A6%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text">I2C总线之读取温度值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FI2C"><span class="toc-number">6.1.</span> <span class="toc-text">软件模拟I2C</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OLED%E5%B1%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">OLED屏原理与驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OLED%E5%B1%8F%E6%B1%89%E5%AD%97%E4%B8%8E%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">OLED屏汉字与图片显示程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">取模软件的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E7%94%B5%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">继电器的原理与驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">步进电机的原理与驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.1.</span> <span class="toc-text">按键控制步进电机程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RS232-%E5%8E%9F%E7%90%86%E4%B8%8E%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">RS232 原理与驱动程序</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Luckys-Yang</div><div class="footer_custom_text"><div class="github-badge"><a href="http://beian.miit.gov.cn/" target="_blank" title="粤ICP备 2022026282号-1" ), pointer;"><span class="badge-subject">粤ICP备</span><span class="badge-value bg-green">2022026282号-1</span></a></div><div class="github-badge"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44070502000559" title="44070502000559号"><span class="badge-subject"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bed.attainment.cn/img/40.png" style="float:left;" />粤公网安备</span><span class="badge-value bg-green">44070502000559号</span></a></div><div><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Frame-Hexo-blue.svg" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Theme-Butterfly-6513df.svg" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/Hosted-Vercel-brightgreen.svg" title="本站采用多线部署，次线路托管于Vercel" alt="HEXO"></a></div></div><div id="running-time" style="color: #5c5c5c;"><script>setInterval(()=>{let create_time=Math.round(new Date('3/10/2022 08:00:00').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已苟活了 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><meting-js id="8183137343" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-paw"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="https://yang5201314.cn/"><i class="fa fa-home"></i><span>主页</span></a><a class="rightMenu-item" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a><a class="rightMenu-item" href="/archives/"><i class="fa-solid fa-folder-open"></i><span>文章归档</span></a><a class="rightMenu-item" href="https://www.foreverblog.cn/go.html" target="_blank"><i class="fa fa-certificate"></i><span>虫洞</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script defer src="/js/tw_cn.js"></script><script defer src="https://cdn.staticfile.org/fancyapps-ui/4.0.27/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module" defer></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script defer src="https://jsd.onmicrosoft.cn/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script defer src="https://jsd.onmicrosoft.cn/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia.js"></script><div class="js-pjax"></div><script src="https://jsd.onmicrosoft.cn/npm/prismjs/prism.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async type="text/javascript" src="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/js/iziToast.min.js"></script><script>
    document.body.oncopy = function () {
        iziToast.info({
            timeout: 4000, // 关闭弹窗的时间
          // icon: 'Fontawesome', // 图标类别
            closeOnEscape: 'true', // 允许使用Esc键关闭弹窗
            transitionIn: 'bounceInLeft', // 弹窗打开动画
            transitionOut: 'fadeOutRight', // 弹窗关闭动画
            displayMode: 'replace', // 替换已经打开的弹窗
            layout: '2', // Medium模式
            position: 'topRight', // 弹窗位置
            //icon: 'fad fa-copy', // 图标类名
            iconUrl:'https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/1122star.svg',
            backgroundColor: 'rgb(179, 182, 180)', // 弹窗背景色
            title: '复制成功', // 通知标题
            message: '键盘敲烂 月薪过万' // 通知消息内容
        });
    }
</script>
<script defer type="text/javascript" src="/js/rightmenu.js"></script><script  type="text/javascript" src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script defer type="text/javascript" src="/js/IPdw.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer data-pjax src="/js/newYear.js"></script><script defer src="/js/my_aplayer.js"></script><script defer src="/js/meting.js"></script><script id="click-heart" src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '250ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>